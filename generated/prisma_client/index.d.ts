
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Area
 * 
 */
export type Area = $Result.DefaultSelection<Prisma.$AreaPayload>
/**
 * Model Court
 * 
 */
export type Court = $Result.DefaultSelection<Prisma.$CourtPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model ReservationRule
 * 
 */
export type ReservationRule = $Result.DefaultSelection<Prisma.$ReservationRulePayload>
/**
 * Model Abonnement
 * 
 */
export type Abonnement = $Result.DefaultSelection<Prisma.$AbonnementPayload>
/**
 * Model UserRole
 * 
 */
export type UserRole = $Result.DefaultSelection<Prisma.$UserRolePayload>
/**
 * Model Permission
 * 
 */
export type Permission = $Result.DefaultSelection<Prisma.$PermissionPayload>
/**
 * Model Hallencard
 * 
 */
export type Hallencard = $Result.DefaultSelection<Prisma.$HallencardPayload>
/**
 * Model Price
 * 
 */
export type Price = $Result.DefaultSelection<Prisma.$PricePayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model Season
 * 
 */
export type Season = $Result.DefaultSelection<Prisma.$SeasonPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamSeason
 * 
 */
export type TeamSeason = $Result.DefaultSelection<Prisma.$TeamSeasonPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Benefit
 * 
 */
export type Benefit = $Result.DefaultSelection<Prisma.$BenefitPayload>
/**
 * Model ControlInterface
 * 
 */
export type ControlInterface = $Result.DefaultSelection<Prisma.$ControlInterfacePayload>
/**
 * Model Organisation
 * 
 */
export type Organisation = $Result.DefaultSelection<Prisma.$OrganisationPayload>
/**
 * Model OrganisationMember
 * 
 */
export type OrganisationMember = $Result.DefaultSelection<Prisma.$OrganisationMemberPayload>
/**
 * Model EventCategory
 * 
 */
export type EventCategory = $Result.DefaultSelection<Prisma.$EventCategoryPayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ReservationStatus: {
  REQUESTED: 'REQUESTED',
  BILLED: 'BILLED',
  APPROVED: 'APPROVED'
};

export type ReservationStatus = (typeof ReservationStatus)[keyof typeof ReservationStatus]


export const ReservationType: {
  TOURNAMENT: 'TOURNAMENT',
  MAINTENANCE: 'MAINTENANCE',
  TEAM_PRACTICE: 'TEAM_PRACTICE',
  TEAM_COMPETITION: 'TEAM_COMPETITION'
};

export type ReservationType = (typeof ReservationType)[keyof typeof ReservationType]


export const ReservationRuleCheckOn: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE'
};

export type ReservationRuleCheckOn = (typeof ReservationRuleCheckOn)[keyof typeof ReservationRuleCheckOn]


export const AbonnementStatus: {
  REQUESTED: 'REQUESTED',
  APPROVED: 'APPROVED',
  BILLED: 'BILLED',
  PAID: 'PAID',
  DELETED: 'DELETED'
};

export type AbonnementStatus = (typeof AbonnementStatus)[keyof typeof AbonnementStatus]


export const PermissionState: {
  NONE: 'NONE',
  OWN: 'OWN',
  ALL: 'ALL'
};

export type PermissionState = (typeof PermissionState)[keyof typeof PermissionState]


export const TransactionReason: {
  HALLENCARD_RECHARGE: 'HALLENCARD_RECHARGE',
  INVOICE: 'INVOICE',
  ONLINE_PAYMENT: 'ONLINE_PAYMENT',
  BANK_TRANSFER: 'BANK_TRANSFER',
  COURT_RESERVATION: 'COURT_RESERVATION',
  COURT_RESERVATION_STORNO: 'COURT_RESERVATION_STORNO',
  REFUND: 'REFUND',
  DONATION: 'DONATION'
};

export type TransactionReason = (typeof TransactionReason)[keyof typeof TransactionReason]


export const TeamCategory: {
  Men: 'Men',
  Women: 'Women',
  Youth: 'Youth'
};

export type TeamCategory = (typeof TeamCategory)[keyof typeof TeamCategory]


export const NotificationSeverity: {
  ERROR: 'ERROR',
  WARNING: 'WARNING',
  INFO: 'INFO',
  SUCCESS: 'SUCCESS'
};

export type NotificationSeverity = (typeof NotificationSeverity)[keyof typeof NotificationSeverity]

}

export type ReservationStatus = $Enums.ReservationStatus

export const ReservationStatus: typeof $Enums.ReservationStatus

export type ReservationType = $Enums.ReservationType

export const ReservationType: typeof $Enums.ReservationType

export type ReservationRuleCheckOn = $Enums.ReservationRuleCheckOn

export const ReservationRuleCheckOn: typeof $Enums.ReservationRuleCheckOn

export type AbonnementStatus = $Enums.AbonnementStatus

export const AbonnementStatus: typeof $Enums.AbonnementStatus

export type PermissionState = $Enums.PermissionState

export const PermissionState: typeof $Enums.PermissionState

export type TransactionReason = $Enums.TransactionReason

export const TransactionReason: typeof $Enums.TransactionReason

export type TeamCategory = $Enums.TeamCategory

export const TeamCategory: typeof $Enums.TeamCategory

export type NotificationSeverity = $Enums.NotificationSeverity

export const NotificationSeverity: typeof $Enums.NotificationSeverity

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs>;

  /**
   * `prisma.area`: Exposes CRUD operations for the **Area** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.area.findMany()
    * ```
    */
  get area(): Prisma.AreaDelegate<ExtArgs>;

  /**
   * `prisma.court`: Exposes CRUD operations for the **Court** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courts
    * const courts = await prisma.court.findMany()
    * ```
    */
  get court(): Prisma.CourtDelegate<ExtArgs>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs>;

  /**
   * `prisma.reservationRule`: Exposes CRUD operations for the **ReservationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReservationRules
    * const reservationRules = await prisma.reservationRule.findMany()
    * ```
    */
  get reservationRule(): Prisma.ReservationRuleDelegate<ExtArgs>;

  /**
   * `prisma.abonnement`: Exposes CRUD operations for the **Abonnement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Abonnements
    * const abonnements = await prisma.abonnement.findMany()
    * ```
    */
  get abonnement(): Prisma.AbonnementDelegate<ExtArgs>;

  /**
   * `prisma.userRole`: Exposes CRUD operations for the **UserRole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserRoles
    * const userRoles = await prisma.userRole.findMany()
    * ```
    */
  get userRole(): Prisma.UserRoleDelegate<ExtArgs>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **Permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.PermissionDelegate<ExtArgs>;

  /**
   * `prisma.hallencard`: Exposes CRUD operations for the **Hallencard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hallencards
    * const hallencards = await prisma.hallencard.findMany()
    * ```
    */
  get hallencard(): Prisma.HallencardDelegate<ExtArgs>;

  /**
   * `prisma.price`: Exposes CRUD operations for the **Price** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prices
    * const prices = await prisma.price.findMany()
    * ```
    */
  get price(): Prisma.PriceDelegate<ExtArgs>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **Season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.SeasonDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamSeason`: Exposes CRUD operations for the **TeamSeason** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamSeasons
    * const teamSeasons = await prisma.teamSeason.findMany()
    * ```
    */
  get teamSeason(): Prisma.TeamSeasonDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.benefit`: Exposes CRUD operations for the **Benefit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Benefits
    * const benefits = await prisma.benefit.findMany()
    * ```
    */
  get benefit(): Prisma.BenefitDelegate<ExtArgs>;

  /**
   * `prisma.controlInterface`: Exposes CRUD operations for the **ControlInterface** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ControlInterfaces
    * const controlInterfaces = await prisma.controlInterface.findMany()
    * ```
    */
  get controlInterface(): Prisma.ControlInterfaceDelegate<ExtArgs>;

  /**
   * `prisma.organisation`: Exposes CRUD operations for the **Organisation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisations
    * const organisations = await prisma.organisation.findMany()
    * ```
    */
  get organisation(): Prisma.OrganisationDelegate<ExtArgs>;

  /**
   * `prisma.organisationMember`: Exposes CRUD operations for the **OrganisationMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrganisationMembers
    * const organisationMembers = await prisma.organisationMember.findMany()
    * ```
    */
  get organisationMember(): Prisma.OrganisationMemberDelegate<ExtArgs>;

  /**
   * `prisma.eventCategory`: Exposes CRUD operations for the **EventCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCategories
    * const eventCategories = await prisma.eventCategory.findMany()
    * ```
    */
  get eventCategory(): Prisma.EventCategoryDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    VerificationToken: 'VerificationToken',
    Area: 'Area',
    Court: 'Court',
    Reservation: 'Reservation',
    ReservationRule: 'ReservationRule',
    Abonnement: 'Abonnement',
    UserRole: 'UserRole',
    Permission: 'Permission',
    Hallencard: 'Hallencard',
    Price: 'Price',
    Transaction: 'Transaction',
    Season: 'Season',
    Team: 'Team',
    TeamSeason: 'TeamSeason',
    TeamMember: 'TeamMember',
    Notification: 'Notification',
    Benefit: 'Benefit',
    ControlInterface: 'ControlInterface',
    Organisation: 'Organisation',
    OrganisationMember: 'OrganisationMember',
    EventCategory: 'EventCategory',
    Event: 'Event'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "verificationToken" | "area" | "court" | "reservation" | "reservationRule" | "abonnement" | "userRole" | "permission" | "hallencard" | "price" | "transaction" | "season" | "team" | "teamSeason" | "teamMember" | "notification" | "benefit" | "controlInterface" | "organisation" | "organisationMember" | "eventCategory" | "event"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Area: {
        payload: Prisma.$AreaPayload<ExtArgs>
        fields: Prisma.AreaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findFirst: {
            args: Prisma.AreaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          findMany: {
            args: Prisma.AreaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>[]
          }
          create: {
            args: Prisma.AreaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          createMany: {
            args: Prisma.AreaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AreaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          update: {
            args: Prisma.AreaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          deleteMany: {
            args: Prisma.AreaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AreaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreaPayload>
          }
          aggregate: {
            args: Prisma.AreaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArea>
          }
          groupBy: {
            args: Prisma.AreaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreaCountArgs<ExtArgs>
            result: $Utils.Optional<AreaCountAggregateOutputType> | number
          }
        }
      }
      Court: {
        payload: Prisma.$CourtPayload<ExtArgs>
        fields: Prisma.CourtFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourtFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourtFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findFirst: {
            args: Prisma.CourtFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourtFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          findMany: {
            args: Prisma.CourtFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>[]
          }
          create: {
            args: Prisma.CourtCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          createMany: {
            args: Prisma.CourtCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CourtDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          update: {
            args: Prisma.CourtUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          deleteMany: {
            args: Prisma.CourtDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourtUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourtUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourtPayload>
          }
          aggregate: {
            args: Prisma.CourtAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourt>
          }
          groupBy: {
            args: Prisma.CourtGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourtGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourtCountArgs<ExtArgs>
            result: $Utils.Optional<CourtCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      ReservationRule: {
        payload: Prisma.$ReservationRulePayload<ExtArgs>
        fields: Prisma.ReservationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          findFirst: {
            args: Prisma.ReservationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          findMany: {
            args: Prisma.ReservationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>[]
          }
          create: {
            args: Prisma.ReservationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          createMany: {
            args: Prisma.ReservationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReservationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          update: {
            args: Prisma.ReservationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          deleteMany: {
            args: Prisma.ReservationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationRulePayload>
          }
          aggregate: {
            args: Prisma.ReservationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservationRule>
          }
          groupBy: {
            args: Prisma.ReservationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationRuleCountAggregateOutputType> | number
          }
        }
      }
      Abonnement: {
        payload: Prisma.$AbonnementPayload<ExtArgs>
        fields: Prisma.AbonnementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AbonnementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AbonnementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          findFirst: {
            args: Prisma.AbonnementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AbonnementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          findMany: {
            args: Prisma.AbonnementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>[]
          }
          create: {
            args: Prisma.AbonnementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          createMany: {
            args: Prisma.AbonnementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AbonnementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          update: {
            args: Prisma.AbonnementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          deleteMany: {
            args: Prisma.AbonnementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AbonnementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AbonnementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AbonnementPayload>
          }
          aggregate: {
            args: Prisma.AbonnementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAbonnement>
          }
          groupBy: {
            args: Prisma.AbonnementGroupByArgs<ExtArgs>
            result: $Utils.Optional<AbonnementGroupByOutputType>[]
          }
          count: {
            args: Prisma.AbonnementCountArgs<ExtArgs>
            result: $Utils.Optional<AbonnementCountAggregateOutputType> | number
          }
        }
      }
      UserRole: {
        payload: Prisma.$UserRolePayload<ExtArgs>
        fields: Prisma.UserRoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserRoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserRoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findFirst: {
            args: Prisma.UserRoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserRoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          findMany: {
            args: Prisma.UserRoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>[]
          }
          create: {
            args: Prisma.UserRoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          createMany: {
            args: Prisma.UserRoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserRoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          update: {
            args: Prisma.UserRoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          deleteMany: {
            args: Prisma.UserRoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserRoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserRoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserRolePayload>
          }
          aggregate: {
            args: Prisma.UserRoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserRole>
          }
          groupBy: {
            args: Prisma.UserRoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserRoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserRoleCountArgs<ExtArgs>
            result: $Utils.Optional<UserRoleCountAggregateOutputType> | number
          }
        }
      }
      Permission: {
        payload: Prisma.$PermissionPayload<ExtArgs>
        fields: Prisma.PermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findFirst: {
            args: Prisma.PermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          findMany: {
            args: Prisma.PermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>[]
          }
          create: {
            args: Prisma.PermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          createMany: {
            args: Prisma.PermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          update: {
            args: Prisma.PermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          deleteMany: {
            args: Prisma.PermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionPayload>
          }
          aggregate: {
            args: Prisma.PermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermission>
          }
          groupBy: {
            args: Prisma.PermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionCountAggregateOutputType> | number
          }
        }
      }
      Hallencard: {
        payload: Prisma.$HallencardPayload<ExtArgs>
        fields: Prisma.HallencardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HallencardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HallencardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          findFirst: {
            args: Prisma.HallencardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HallencardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          findMany: {
            args: Prisma.HallencardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>[]
          }
          create: {
            args: Prisma.HallencardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          createMany: {
            args: Prisma.HallencardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.HallencardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          update: {
            args: Prisma.HallencardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          deleteMany: {
            args: Prisma.HallencardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HallencardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HallencardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HallencardPayload>
          }
          aggregate: {
            args: Prisma.HallencardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHallencard>
          }
          groupBy: {
            args: Prisma.HallencardGroupByArgs<ExtArgs>
            result: $Utils.Optional<HallencardGroupByOutputType>[]
          }
          count: {
            args: Prisma.HallencardCountArgs<ExtArgs>
            result: $Utils.Optional<HallencardCountAggregateOutputType> | number
          }
        }
      }
      Price: {
        payload: Prisma.$PricePayload<ExtArgs>
        fields: Prisma.PriceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findFirst: {
            args: Prisma.PriceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          findMany: {
            args: Prisma.PriceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>[]
          }
          create: {
            args: Prisma.PriceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          createMany: {
            args: Prisma.PriceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PriceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          update: {
            args: Prisma.PriceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          deleteMany: {
            args: Prisma.PriceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricePayload>
          }
          aggregate: {
            args: Prisma.PriceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrice>
          }
          groupBy: {
            args: Prisma.PriceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceCountArgs<ExtArgs>
            result: $Utils.Optional<PriceCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      Season: {
        payload: Prisma.$SeasonPayload<ExtArgs>
        fields: Prisma.SeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findFirst: {
            args: Prisma.SeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          findMany: {
            args: Prisma.SeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>[]
          }
          create: {
            args: Prisma.SeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          createMany: {
            args: Prisma.SeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          update: {
            args: Prisma.SeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          deleteMany: {
            args: Prisma.SeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeasonPayload>
          }
          aggregate: {
            args: Prisma.SeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeason>
          }
          groupBy: {
            args: Prisma.SeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeasonCountArgs<ExtArgs>
            result: $Utils.Optional<SeasonCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamSeason: {
        payload: Prisma.$TeamSeasonPayload<ExtArgs>
        fields: Prisma.TeamSeasonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamSeasonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamSeasonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          findFirst: {
            args: Prisma.TeamSeasonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamSeasonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          findMany: {
            args: Prisma.TeamSeasonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>[]
          }
          create: {
            args: Prisma.TeamSeasonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          createMany: {
            args: Prisma.TeamSeasonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamSeasonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          update: {
            args: Prisma.TeamSeasonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          deleteMany: {
            args: Prisma.TeamSeasonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamSeasonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamSeasonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamSeasonPayload>
          }
          aggregate: {
            args: Prisma.TeamSeasonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamSeason>
          }
          groupBy: {
            args: Prisma.TeamSeasonGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamSeasonGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamSeasonCountArgs<ExtArgs>
            result: $Utils.Optional<TeamSeasonCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Benefit: {
        payload: Prisma.$BenefitPayload<ExtArgs>
        fields: Prisma.BenefitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BenefitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BenefitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          findFirst: {
            args: Prisma.BenefitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BenefitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          findMany: {
            args: Prisma.BenefitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>[]
          }
          create: {
            args: Prisma.BenefitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          createMany: {
            args: Prisma.BenefitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BenefitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          update: {
            args: Prisma.BenefitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          deleteMany: {
            args: Prisma.BenefitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BenefitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BenefitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BenefitPayload>
          }
          aggregate: {
            args: Prisma.BenefitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBenefit>
          }
          groupBy: {
            args: Prisma.BenefitGroupByArgs<ExtArgs>
            result: $Utils.Optional<BenefitGroupByOutputType>[]
          }
          count: {
            args: Prisma.BenefitCountArgs<ExtArgs>
            result: $Utils.Optional<BenefitCountAggregateOutputType> | number
          }
        }
      }
      ControlInterface: {
        payload: Prisma.$ControlInterfacePayload<ExtArgs>
        fields: Prisma.ControlInterfaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ControlInterfaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ControlInterfaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          findFirst: {
            args: Prisma.ControlInterfaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ControlInterfaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          findMany: {
            args: Prisma.ControlInterfaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>[]
          }
          create: {
            args: Prisma.ControlInterfaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          createMany: {
            args: Prisma.ControlInterfaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ControlInterfaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          update: {
            args: Prisma.ControlInterfaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          deleteMany: {
            args: Prisma.ControlInterfaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ControlInterfaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ControlInterfaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ControlInterfacePayload>
          }
          aggregate: {
            args: Prisma.ControlInterfaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateControlInterface>
          }
          groupBy: {
            args: Prisma.ControlInterfaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ControlInterfaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ControlInterfaceCountArgs<ExtArgs>
            result: $Utils.Optional<ControlInterfaceCountAggregateOutputType> | number
          }
        }
      }
      Organisation: {
        payload: Prisma.$OrganisationPayload<ExtArgs>
        fields: Prisma.OrganisationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findFirst: {
            args: Prisma.OrganisationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          findMany: {
            args: Prisma.OrganisationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>[]
          }
          create: {
            args: Prisma.OrganisationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          createMany: {
            args: Prisma.OrganisationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          update: {
            args: Prisma.OrganisationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationPayload>
          }
          aggregate: {
            args: Prisma.OrganisationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisation>
          }
          groupBy: {
            args: Prisma.OrganisationGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationCountAggregateOutputType> | number
          }
        }
      }
      OrganisationMember: {
        payload: Prisma.$OrganisationMemberPayload<ExtArgs>
        fields: Prisma.OrganisationMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrganisationMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrganisationMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          findFirst: {
            args: Prisma.OrganisationMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrganisationMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          findMany: {
            args: Prisma.OrganisationMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>[]
          }
          create: {
            args: Prisma.OrganisationMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          createMany: {
            args: Prisma.OrganisationMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrganisationMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          update: {
            args: Prisma.OrganisationMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          deleteMany: {
            args: Prisma.OrganisationMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrganisationMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrganisationMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrganisationMemberPayload>
          }
          aggregate: {
            args: Prisma.OrganisationMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrganisationMember>
          }
          groupBy: {
            args: Prisma.OrganisationMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrganisationMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrganisationMemberCountArgs<ExtArgs>
            result: $Utils.Optional<OrganisationMemberCountAggregateOutputType> | number
          }
        }
      }
      EventCategory: {
        payload: Prisma.$EventCategoryPayload<ExtArgs>
        fields: Prisma.EventCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findFirst: {
            args: Prisma.EventCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findMany: {
            args: Prisma.EventCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>[]
          }
          create: {
            args: Prisma.EventCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          createMany: {
            args: Prisma.EventCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          update: {
            args: Prisma.EventCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          deleteMany: {
            args: Prisma.EventCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          aggregate: {
            args: Prisma.EventCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCategory>
          }
          groupBy: {
            args: Prisma.EventCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    abonnements: number
    ownedReservations: number
    fellowedReservations: number
    transactions: number
    teams: number
    leadTeams: number
    roles: number
    likedEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abonnements?: boolean | UserCountOutputTypeCountAbonnementsArgs
    ownedReservations?: boolean | UserCountOutputTypeCountOwnedReservationsArgs
    fellowedReservations?: boolean | UserCountOutputTypeCountFellowedReservationsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    leadTeams?: boolean | UserCountOutputTypeCountLeadTeamsArgs
    roles?: boolean | UserCountOutputTypeCountRolesArgs
    likedEvents?: boolean | UserCountOutputTypeCountLikedEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAbonnementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbonnementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountOwnedReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFellowedReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeadTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamSeasonWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLikedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type AreaCountOutputType
   */

  export type AreaCountOutputType = {
    courts: number
    reservationRules: number
    prices: number
  }

  export type AreaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courts?: boolean | AreaCountOutputTypeCountCourtsArgs
    reservationRules?: boolean | AreaCountOutputTypeCountReservationRulesArgs
    prices?: boolean | AreaCountOutputTypeCountPricesArgs
  }

  // Custom InputTypes
  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreaCountOutputType
     */
    select?: AreaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountReservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationRuleWhereInput
  }

  /**
   * AreaCountOutputType without action
   */
  export type AreaCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
  }


  /**
   * Count Type CourtCountOutputType
   */

  export type CourtCountOutputType = {
    abonnements: number
    reservations: number
    reservationRules: number
    controlInterfaces: number
  }

  export type CourtCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abonnements?: boolean | CourtCountOutputTypeCountAbonnementsArgs
    reservations?: boolean | CourtCountOutputTypeCountReservationsArgs
    reservationRules?: boolean | CourtCountOutputTypeCountReservationRulesArgs
    controlInterfaces?: boolean | CourtCountOutputTypeCountControlInterfacesArgs
  }

  // Custom InputTypes
  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourtCountOutputType
     */
    select?: CourtCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountAbonnementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbonnementWhereInput
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountReservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationRuleWhereInput
  }

  /**
   * CourtCountOutputType without action
   */
  export type CourtCountOutputTypeCountControlInterfacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlInterfaceWhereInput
  }


  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    fellows: number
    transactions: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fellows?: boolean | ReservationCountOutputTypeCountFellowsArgs
    transactions?: boolean | ReservationCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountFellowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type ReservationRuleCountOutputType
   */

  export type ReservationRuleCountOutputType = {
    validFor: number
    affectedAreas: number
    affectedCourts: number
  }

  export type ReservationRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validFor?: boolean | ReservationRuleCountOutputTypeCountValidForArgs
    affectedAreas?: boolean | ReservationRuleCountOutputTypeCountAffectedAreasArgs
    affectedCourts?: boolean | ReservationRuleCountOutputTypeCountAffectedCourtsArgs
  }

  // Custom InputTypes
  /**
   * ReservationRuleCountOutputType without action
   */
  export type ReservationRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRuleCountOutputType
     */
    select?: ReservationRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationRuleCountOutputType without action
   */
  export type ReservationRuleCountOutputTypeCountValidForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * ReservationRuleCountOutputType without action
   */
  export type ReservationRuleCountOutputTypeCountAffectedAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
  }

  /**
   * ReservationRuleCountOutputType without action
   */
  export type ReservationRuleCountOutputTypeCountAffectedCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
  }


  /**
   * Count Type AbonnementCountOutputType
   */

  export type AbonnementCountOutputType = {
    transactions: number
    reservations: number
  }

  export type AbonnementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | AbonnementCountOutputTypeCountTransactionsArgs
    reservations?: boolean | AbonnementCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * AbonnementCountOutputType without action
   */
  export type AbonnementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AbonnementCountOutputType
     */
    select?: AbonnementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AbonnementCountOutputType without action
   */
  export type AbonnementCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * AbonnementCountOutputType without action
   */
  export type AbonnementCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type UserRoleCountOutputType
   */

  export type UserRoleCountOutputType = {
    permissions: number
    users: number
    prices: number
    reservationRules: number
  }

  export type UserRoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | UserRoleCountOutputTypeCountPermissionsArgs
    users?: boolean | UserRoleCountOutputTypeCountUsersArgs
    prices?: boolean | UserRoleCountOutputTypeCountPricesArgs
    reservationRules?: boolean | UserRoleCountOutputTypeCountReservationRulesArgs
  }

  // Custom InputTypes
  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRoleCountOutputType
     */
    select?: UserRoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
  }

  /**
   * UserRoleCountOutputType without action
   */
  export type UserRoleCountOutputTypeCountReservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationRuleWhereInput
  }


  /**
   * Count Type PriceCountOutputType
   */

  export type PriceCountOutputType = {
    roles: number
    areas: number
  }

  export type PriceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | PriceCountOutputTypeCountRolesArgs
    areas?: boolean | PriceCountOutputTypeCountAreasArgs
  }

  // Custom InputTypes
  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceCountOutputType
     */
    select?: PriceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeCountRolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
  }

  /**
   * PriceCountOutputType without action
   */
  export type PriceCountOutputTypeCountAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
  }


  /**
   * Count Type SeasonCountOutputType
   */

  export type SeasonCountOutputType = {
    teams: number
    players: number
  }

  export type SeasonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | SeasonCountOutputTypeCountTeamsArgs
    players?: boolean | SeasonCountOutputTypeCountPlayersArgs
  }

  // Custom InputTypes
  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamSeasonWhereInput
  }

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeCountPlayersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    teamSeasons: number
    members: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamSeasons?: boolean | TeamCountOutputTypeCountTeamSeasonsArgs
    members?: boolean | TeamCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeamSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamSeasonWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }


  /**
   * Count Type ControlInterfaceCountOutputType
   */

  export type ControlInterfaceCountOutputType = {
    affectedCourts: number
  }

  export type ControlInterfaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectedCourts?: boolean | ControlInterfaceCountOutputTypeCountAffectedCourtsArgs
  }

  // Custom InputTypes
  /**
   * ControlInterfaceCountOutputType without action
   */
  export type ControlInterfaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterfaceCountOutputType
     */
    select?: ControlInterfaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ControlInterfaceCountOutputType without action
   */
  export type ControlInterfaceCountOutputTypeCountAffectedCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
  }


  /**
   * Count Type OrganisationCountOutputType
   */

  export type OrganisationCountOutputType = {
    members: number
  }

  export type OrganisationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | OrganisationCountOutputTypeCountMembersArgs
  }

  // Custom InputTypes
  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationCountOutputType
     */
    select?: OrganisationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationCountOutputType without action
   */
  export type OrganisationCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationMemberWhereInput
  }


  /**
   * Count Type OrganisationMemberCountOutputType
   */

  export type OrganisationMemberCountOutputType = {
    childMembers: number
  }

  export type OrganisationMemberCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    childMembers?: boolean | OrganisationMemberCountOutputTypeCountChildMembersArgs
  }

  // Custom InputTypes
  /**
   * OrganisationMemberCountOutputType without action
   */
  export type OrganisationMemberCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMemberCountOutputType
     */
    select?: OrganisationMemberCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrganisationMemberCountOutputType without action
   */
  export type OrganisationMemberCountOutputTypeCountChildMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationMemberWhereInput
  }


  /**
   * Count Type EventCategoryCountOutputType
   */

  export type EventCategoryCountOutputType = {
    events: number
  }

  export type EventCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | EventCategoryCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategoryCountOutputType
     */
    select?: EventCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    likedByUsers: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    likedByUsers?: boolean | EventCountOutputTypeCountLikedByUsersArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountLikedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    image: string | null
    auth0Id: string | null
    address: string | null
    cityCode: string | null
    cityName: string | null
    countryCode: string | null
    needsSetup: boolean | null
    publicName: boolean | null
    phoneNumber: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    image: string | null
    auth0Id: string | null
    address: string | null
    cityCode: string | null
    cityName: string | null
    countryCode: string | null
    needsSetup: boolean | null
    publicName: boolean | null
    phoneNumber: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    image: number
    auth0Id: number
    address: number
    cityCode: number
    cityName: number
    countryCode: number
    needsSetup: number
    publicName: number
    phoneNumber: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    auth0Id?: true
    address?: true
    cityCode?: true
    cityName?: true
    countryCode?: true
    needsSetup?: true
    publicName?: true
    phoneNumber?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    auth0Id?: true
    address?: true
    cityCode?: true
    cityName?: true
    countryCode?: true
    needsSetup?: true
    publicName?: true
    phoneNumber?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    image?: true
    auth0Id?: true
    address?: true
    cityCode?: true
    cityName?: true
    countryCode?: true
    needsSetup?: true
    publicName?: true
    phoneNumber?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string | null
    image: string | null
    auth0Id: string
    address: string | null
    cityCode: string | null
    cityName: string | null
    countryCode: string | null
    needsSetup: boolean
    publicName: boolean
    phoneNumber: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    auth0Id?: boolean
    address?: boolean
    cityCode?: boolean
    cityName?: boolean
    countryCode?: boolean
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: boolean
    abonnements?: boolean | User$abonnementsArgs<ExtArgs>
    ownedReservations?: boolean | User$ownedReservationsArgs<ExtArgs>
    fellowedReservations?: boolean | User$fellowedReservationsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    leadTeams?: boolean | User$leadTeamsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    likedEvents?: boolean | User$likedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    image?: boolean
    auth0Id?: boolean
    address?: boolean
    cityCode?: boolean
    cityName?: boolean
    countryCode?: boolean
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    abonnements?: boolean | User$abonnementsArgs<ExtArgs>
    ownedReservations?: boolean | User$ownedReservationsArgs<ExtArgs>
    fellowedReservations?: boolean | User$fellowedReservationsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    leadTeams?: boolean | User$leadTeamsArgs<ExtArgs>
    roles?: boolean | User$rolesArgs<ExtArgs>
    likedEvents?: boolean | User$likedEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      abonnements: Prisma.$AbonnementPayload<ExtArgs>[]
      ownedReservations: Prisma.$ReservationPayload<ExtArgs>[]
      fellowedReservations: Prisma.$ReservationPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      teams: Prisma.$TeamMemberPayload<ExtArgs>[]
      leadTeams: Prisma.$TeamSeasonPayload<ExtArgs>[]
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      likedEvents: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string | null
      image: string | null
      auth0Id: string
      address: string | null
      cityCode: string | null
      cityName: string | null
      countryCode: string | null
      needsSetup: boolean
      publicName: boolean
      phoneNumber: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    abonnements<T extends User$abonnementsArgs<ExtArgs> = {}>(args?: Subset<T, User$abonnementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findMany"> | Null>
    ownedReservations<T extends User$ownedReservationsArgs<ExtArgs> = {}>(args?: Subset<T, User$ownedReservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    fellowedReservations<T extends User$fellowedReservationsArgs<ExtArgs> = {}>(args?: Subset<T, User$fellowedReservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    leadTeams<T extends User$leadTeamsArgs<ExtArgs> = {}>(args?: Subset<T, User$leadTeamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findMany"> | Null>
    roles<T extends User$rolesArgs<ExtArgs> = {}>(args?: Subset<T, User$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    likedEvents<T extends User$likedEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$likedEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly image: FieldRef<"User", 'String'>
    readonly auth0Id: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly cityCode: FieldRef<"User", 'String'>
    readonly cityName: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly needsSetup: FieldRef<"User", 'Boolean'>
    readonly publicName: FieldRef<"User", 'Boolean'>
    readonly phoneNumber: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.abonnements
   */
  export type User$abonnementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    where?: AbonnementWhereInput
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    cursor?: AbonnementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbonnementScalarFieldEnum | AbonnementScalarFieldEnum[]
  }

  /**
   * User.ownedReservations
   */
  export type User$ownedReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * User.fellowedReservations
   */
  export type User$fellowedReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.leadTeams
   */
  export type User$leadTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    where?: TeamSeasonWhereInput
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    cursor?: TeamSeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * User.roles
   */
  export type User$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * User.likedEvents
   */
  export type User$likedEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>


  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }


  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */ 
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
  }


  /**
   * Model Area
   */

  export type AggregateArea = {
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  export type AreaAvgAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type AreaSumAggregateOutputType = {
    id: number | null
    order: number | null
  }

  export type AreaMinAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    activeFrom: Date | null
    activeTo: Date | null
    bookableFrom: Date | null
    order: number | null
  }

  export type AreaMaxAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    activeFrom: Date | null
    activeTo: Date | null
    bookableFrom: Date | null
    order: number | null
  }

  export type AreaCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    activeFrom: number
    activeTo: number
    bookableFrom: number
    order: number
    _all: number
  }


  export type AreaAvgAggregateInputType = {
    id?: true
    order?: true
  }

  export type AreaSumAggregateInputType = {
    id?: true
    order?: true
  }

  export type AreaMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    activeFrom?: true
    activeTo?: true
    bookableFrom?: true
    order?: true
  }

  export type AreaMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    activeFrom?: true
    activeTo?: true
    bookableFrom?: true
    order?: true
  }

  export type AreaCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    activeFrom?: true
    activeTo?: true
    bookableFrom?: true
    order?: true
    _all?: true
  }

  export type AreaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Area to aggregate.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreaMaxAggregateInputType
  }

  export type GetAreaAggregateType<T extends AreaAggregateArgs> = {
        [P in keyof T & keyof AggregateArea]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArea[P]>
      : GetScalarType<T[P], AggregateArea[P]>
  }




  export type AreaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithAggregationInput | AreaOrderByWithAggregationInput[]
    by: AreaScalarFieldEnum[] | AreaScalarFieldEnum
    having?: AreaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreaCountAggregateInputType | true
    _avg?: AreaAvgAggregateInputType
    _sum?: AreaSumAggregateInputType
    _min?: AreaMinAggregateInputType
    _max?: AreaMaxAggregateInputType
  }

  export type AreaGroupByOutputType = {
    id: number
    name: string
    shortName: string
    activeFrom: Date | null
    activeTo: Date | null
    bookableFrom: Date | null
    order: number | null
    _count: AreaCountAggregateOutputType | null
    _avg: AreaAvgAggregateOutputType | null
    _sum: AreaSumAggregateOutputType | null
    _min: AreaMinAggregateOutputType | null
    _max: AreaMaxAggregateOutputType | null
  }

  type GetAreaGroupByPayload<T extends AreaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreaGroupByOutputType[P]>
            : GetScalarType<T[P], AreaGroupByOutputType[P]>
        }
      >
    >


  export type AreaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    activeFrom?: boolean
    activeTo?: boolean
    bookableFrom?: boolean
    order?: boolean
    courts?: boolean | Area$courtsArgs<ExtArgs>
    reservationRules?: boolean | Area$reservationRulesArgs<ExtArgs>
    prices?: boolean | Area$pricesArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["area"]>


  export type AreaSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    activeFrom?: boolean
    activeTo?: boolean
    bookableFrom?: boolean
    order?: boolean
  }

  export type AreaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    courts?: boolean | Area$courtsArgs<ExtArgs>
    reservationRules?: boolean | Area$reservationRulesArgs<ExtArgs>
    prices?: boolean | Area$pricesArgs<ExtArgs>
    _count?: boolean | AreaCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AreaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Area"
    objects: {
      courts: Prisma.$CourtPayload<ExtArgs>[]
      reservationRules: Prisma.$ReservationRulePayload<ExtArgs>[]
      prices: Prisma.$PricePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      shortName: string
      activeFrom: Date | null
      activeTo: Date | null
      bookableFrom: Date | null
      order: number | null
    }, ExtArgs["result"]["area"]>
    composites: {}
  }

  type AreaGetPayload<S extends boolean | null | undefined | AreaDefaultArgs> = $Result.GetResult<Prisma.$AreaPayload, S>

  type AreaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AreaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AreaCountAggregateInputType | true
    }

  export interface AreaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Area'], meta: { name: 'Area' } }
    /**
     * Find zero or one Area that matches the filter.
     * @param {AreaFindUniqueArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreaFindUniqueArgs>(args: SelectSubset<T, AreaFindUniqueArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Area that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AreaFindUniqueOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreaFindUniqueOrThrowArgs>(args: SelectSubset<T, AreaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Area that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreaFindFirstArgs>(args?: SelectSubset<T, AreaFindFirstArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Area that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindFirstOrThrowArgs} args - Arguments to find a Area
     * @example
     * // Get one Area
     * const area = await prisma.area.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreaFindFirstOrThrowArgs>(args?: SelectSubset<T, AreaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.area.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.area.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areaWithIdOnly = await prisma.area.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreaFindManyArgs>(args?: SelectSubset<T, AreaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Area.
     * @param {AreaCreateArgs} args - Arguments to create a Area.
     * @example
     * // Create one Area
     * const Area = await prisma.area.create({
     *   data: {
     *     // ... data to create a Area
     *   }
     * })
     * 
     */
    create<T extends AreaCreateArgs>(args: SelectSubset<T, AreaCreateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Areas.
     * @param {AreaCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const area = await prisma.area.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreaCreateManyArgs>(args?: SelectSubset<T, AreaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Area.
     * @param {AreaDeleteArgs} args - Arguments to delete one Area.
     * @example
     * // Delete one Area
     * const Area = await prisma.area.delete({
     *   where: {
     *     // ... filter to delete one Area
     *   }
     * })
     * 
     */
    delete<T extends AreaDeleteArgs>(args: SelectSubset<T, AreaDeleteArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Area.
     * @param {AreaUpdateArgs} args - Arguments to update one Area.
     * @example
     * // Update one Area
     * const area = await prisma.area.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreaUpdateArgs>(args: SelectSubset<T, AreaUpdateArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Areas.
     * @param {AreaDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.area.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreaDeleteManyArgs>(args?: SelectSubset<T, AreaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const area = await prisma.area.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreaUpdateManyArgs>(args: SelectSubset<T, AreaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Area.
     * @param {AreaUpsertArgs} args - Arguments to update or create a Area.
     * @example
     * // Update or create a Area
     * const area = await prisma.area.upsert({
     *   create: {
     *     // ... data to create a Area
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Area we want to update
     *   }
     * })
     */
    upsert<T extends AreaUpsertArgs>(args: SelectSubset<T, AreaUpsertArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.area.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreaCountArgs>(
      args?: Subset<T, AreaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreaAggregateArgs>(args: Subset<T, AreaAggregateArgs>): Prisma.PrismaPromise<GetAreaAggregateType<T>>

    /**
     * Group by Area.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreaGroupByArgs['orderBy'] }
        : { orderBy?: AreaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Area model
   */
  readonly fields: AreaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Area.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    courts<T extends Area$courtsArgs<ExtArgs> = {}>(args?: Subset<T, Area$courtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany"> | Null>
    reservationRules<T extends Area$reservationRulesArgs<ExtArgs> = {}>(args?: Subset<T, Area$reservationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findMany"> | Null>
    prices<T extends Area$pricesArgs<ExtArgs> = {}>(args?: Subset<T, Area$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Area model
   */ 
  interface AreaFieldRefs {
    readonly id: FieldRef<"Area", 'Int'>
    readonly name: FieldRef<"Area", 'String'>
    readonly shortName: FieldRef<"Area", 'String'>
    readonly activeFrom: FieldRef<"Area", 'DateTime'>
    readonly activeTo: FieldRef<"Area", 'DateTime'>
    readonly bookableFrom: FieldRef<"Area", 'DateTime'>
    readonly order: FieldRef<"Area", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Area findUnique
   */
  export type AreaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findUniqueOrThrow
   */
  export type AreaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area findFirst
   */
  export type AreaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findFirstOrThrow
   */
  export type AreaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Area to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area findMany
   */
  export type AreaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Area create
   */
  export type AreaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to create a Area.
     */
    data: XOR<AreaCreateInput, AreaUncheckedCreateInput>
  }

  /**
   * Area createMany
   */
  export type AreaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreaCreateManyInput | AreaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Area update
   */
  export type AreaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The data needed to update a Area.
     */
    data: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
    /**
     * Choose, which Area to update.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area updateMany
   */
  export type AreaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreaWhereInput
  }

  /**
   * Area upsert
   */
  export type AreaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * The filter to search for the Area to update in case it exists.
     */
    where: AreaWhereUniqueInput
    /**
     * In case the Area found by the `where` argument doesn't exist, create a new Area with this data.
     */
    create: XOR<AreaCreateInput, AreaUncheckedCreateInput>
    /**
     * In case the Area was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreaUpdateInput, AreaUncheckedUpdateInput>
  }

  /**
   * Area delete
   */
  export type AreaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    /**
     * Filter which Area to delete.
     */
    where: AreaWhereUniqueInput
  }

  /**
   * Area deleteMany
   */
  export type AreaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreaWhereInput
  }

  /**
   * Area.courts
   */
  export type Area$courtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    cursor?: CourtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Area.reservationRules
   */
  export type Area$reservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    where?: ReservationRuleWhereInput
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    cursor?: ReservationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * Area.prices
   */
  export type Area$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    cursor?: PriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Area without action
   */
  export type AreaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
  }


  /**
   * Model Court
   */

  export type AggregateCourt = {
    _count: CourtCountAggregateOutputType | null
    _avg: CourtAvgAggregateOutputType | null
    _sum: CourtSumAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  export type CourtAvgAggregateOutputType = {
    order: number | null
    areaId: number | null
  }

  export type CourtSumAggregateOutputType = {
    order: number | null
    areaId: number | null
  }

  export type CourtMinAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    description: string | null
    order: number | null
    active: boolean | null
    activeFrom: Date | null
    activeTo: Date | null
    areaId: number | null
  }

  export type CourtMaxAggregateOutputType = {
    id: string | null
    name: string | null
    shortName: string | null
    description: string | null
    order: number | null
    active: boolean | null
    activeFrom: Date | null
    activeTo: Date | null
    areaId: number | null
  }

  export type CourtCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    description: number
    order: number
    active: number
    activeFrom: number
    activeTo: number
    areaId: number
    _all: number
  }


  export type CourtAvgAggregateInputType = {
    order?: true
    areaId?: true
  }

  export type CourtSumAggregateInputType = {
    order?: true
    areaId?: true
  }

  export type CourtMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    description?: true
    order?: true
    active?: true
    activeFrom?: true
    activeTo?: true
    areaId?: true
  }

  export type CourtMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    description?: true
    order?: true
    active?: true
    activeFrom?: true
    activeTo?: true
    areaId?: true
  }

  export type CourtCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    description?: true
    order?: true
    active?: true
    activeFrom?: true
    activeTo?: true
    areaId?: true
    _all?: true
  }

  export type CourtAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Court to aggregate.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courts
    **/
    _count?: true | CourtCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourtAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourtSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourtMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourtMaxAggregateInputType
  }

  export type GetCourtAggregateType<T extends CourtAggregateArgs> = {
        [P in keyof T & keyof AggregateCourt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourt[P]>
      : GetScalarType<T[P], AggregateCourt[P]>
  }




  export type CourtGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithAggregationInput | CourtOrderByWithAggregationInput[]
    by: CourtScalarFieldEnum[] | CourtScalarFieldEnum
    having?: CourtScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourtCountAggregateInputType | true
    _avg?: CourtAvgAggregateInputType
    _sum?: CourtSumAggregateInputType
    _min?: CourtMinAggregateInputType
    _max?: CourtMaxAggregateInputType
  }

  export type CourtGroupByOutputType = {
    id: string
    name: string
    shortName: string | null
    description: string | null
    order: number | null
    active: boolean
    activeFrom: Date | null
    activeTo: Date | null
    areaId: number
    _count: CourtCountAggregateOutputType | null
    _avg: CourtAvgAggregateOutputType | null
    _sum: CourtSumAggregateOutputType | null
    _min: CourtMinAggregateOutputType | null
    _max: CourtMaxAggregateOutputType | null
  }

  type GetCourtGroupByPayload<T extends CourtGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourtGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourtGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourtGroupByOutputType[P]>
            : GetScalarType<T[P], CourtGroupByOutputType[P]>
        }
      >
    >


  export type CourtSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    activeFrom?: boolean
    activeTo?: boolean
    areaId?: boolean
    area?: boolean | AreaDefaultArgs<ExtArgs>
    abonnements?: boolean | Court$abonnementsArgs<ExtArgs>
    reservations?: boolean | Court$reservationsArgs<ExtArgs>
    reservationRules?: boolean | Court$reservationRulesArgs<ExtArgs>
    controlInterfaces?: boolean | Court$controlInterfacesArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["court"]>


  export type CourtSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    activeFrom?: boolean
    activeTo?: boolean
    areaId?: boolean
  }

  export type CourtInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreaDefaultArgs<ExtArgs>
    abonnements?: boolean | Court$abonnementsArgs<ExtArgs>
    reservations?: boolean | Court$reservationsArgs<ExtArgs>
    reservationRules?: boolean | Court$reservationRulesArgs<ExtArgs>
    controlInterfaces?: boolean | Court$controlInterfacesArgs<ExtArgs>
    _count?: boolean | CourtCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CourtPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Court"
    objects: {
      area: Prisma.$AreaPayload<ExtArgs>
      abonnements: Prisma.$AbonnementPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      reservationRules: Prisma.$ReservationRulePayload<ExtArgs>[]
      controlInterfaces: Prisma.$ControlInterfacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      shortName: string | null
      description: string | null
      order: number | null
      active: boolean
      activeFrom: Date | null
      activeTo: Date | null
      areaId: number
    }, ExtArgs["result"]["court"]>
    composites: {}
  }

  type CourtGetPayload<S extends boolean | null | undefined | CourtDefaultArgs> = $Result.GetResult<Prisma.$CourtPayload, S>

  type CourtCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourtFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourtCountAggregateInputType | true
    }

  export interface CourtDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Court'], meta: { name: 'Court' } }
    /**
     * Find zero or one Court that matches the filter.
     * @param {CourtFindUniqueArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourtFindUniqueArgs>(args: SelectSubset<T, CourtFindUniqueArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Court that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourtFindUniqueOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourtFindUniqueOrThrowArgs>(args: SelectSubset<T, CourtFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Court that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourtFindFirstArgs>(args?: SelectSubset<T, CourtFindFirstArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Court that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindFirstOrThrowArgs} args - Arguments to find a Court
     * @example
     * // Get one Court
     * const court = await prisma.court.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourtFindFirstOrThrowArgs>(args?: SelectSubset<T, CourtFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courts
     * const courts = await prisma.court.findMany()
     * 
     * // Get first 10 Courts
     * const courts = await prisma.court.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courtWithIdOnly = await prisma.court.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourtFindManyArgs>(args?: SelectSubset<T, CourtFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Court.
     * @param {CourtCreateArgs} args - Arguments to create a Court.
     * @example
     * // Create one Court
     * const Court = await prisma.court.create({
     *   data: {
     *     // ... data to create a Court
     *   }
     * })
     * 
     */
    create<T extends CourtCreateArgs>(args: SelectSubset<T, CourtCreateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courts.
     * @param {CourtCreateManyArgs} args - Arguments to create many Courts.
     * @example
     * // Create many Courts
     * const court = await prisma.court.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourtCreateManyArgs>(args?: SelectSubset<T, CourtCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Court.
     * @param {CourtDeleteArgs} args - Arguments to delete one Court.
     * @example
     * // Delete one Court
     * const Court = await prisma.court.delete({
     *   where: {
     *     // ... filter to delete one Court
     *   }
     * })
     * 
     */
    delete<T extends CourtDeleteArgs>(args: SelectSubset<T, CourtDeleteArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Court.
     * @param {CourtUpdateArgs} args - Arguments to update one Court.
     * @example
     * // Update one Court
     * const court = await prisma.court.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourtUpdateArgs>(args: SelectSubset<T, CourtUpdateArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courts.
     * @param {CourtDeleteManyArgs} args - Arguments to filter Courts to delete.
     * @example
     * // Delete a few Courts
     * const { count } = await prisma.court.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourtDeleteManyArgs>(args?: SelectSubset<T, CourtDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courts
     * const court = await prisma.court.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourtUpdateManyArgs>(args: SelectSubset<T, CourtUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Court.
     * @param {CourtUpsertArgs} args - Arguments to update or create a Court.
     * @example
     * // Update or create a Court
     * const court = await prisma.court.upsert({
     *   create: {
     *     // ... data to create a Court
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Court we want to update
     *   }
     * })
     */
    upsert<T extends CourtUpsertArgs>(args: SelectSubset<T, CourtUpsertArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtCountArgs} args - Arguments to filter Courts to count.
     * @example
     * // Count the number of Courts
     * const count = await prisma.court.count({
     *   where: {
     *     // ... the filter for the Courts we want to count
     *   }
     * })
    **/
    count<T extends CourtCountArgs>(
      args?: Subset<T, CourtCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourtCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourtAggregateArgs>(args: Subset<T, CourtAggregateArgs>): Prisma.PrismaPromise<GetCourtAggregateType<T>>

    /**
     * Group by Court.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourtGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourtGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourtGroupByArgs['orderBy'] }
        : { orderBy?: CourtGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourtGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourtGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Court model
   */
  readonly fields: CourtFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Court.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourtClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreaDefaultArgs<ExtArgs>>): Prisma__AreaClient<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    abonnements<T extends Court$abonnementsArgs<ExtArgs> = {}>(args?: Subset<T, Court$abonnementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findMany"> | Null>
    reservations<T extends Court$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Court$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    reservationRules<T extends Court$reservationRulesArgs<ExtArgs> = {}>(args?: Subset<T, Court$reservationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findMany"> | Null>
    controlInterfaces<T extends Court$controlInterfacesArgs<ExtArgs> = {}>(args?: Subset<T, Court$controlInterfacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Court model
   */ 
  interface CourtFieldRefs {
    readonly id: FieldRef<"Court", 'String'>
    readonly name: FieldRef<"Court", 'String'>
    readonly shortName: FieldRef<"Court", 'String'>
    readonly description: FieldRef<"Court", 'String'>
    readonly order: FieldRef<"Court", 'Int'>
    readonly active: FieldRef<"Court", 'Boolean'>
    readonly activeFrom: FieldRef<"Court", 'DateTime'>
    readonly activeTo: FieldRef<"Court", 'DateTime'>
    readonly areaId: FieldRef<"Court", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Court findUnique
   */
  export type CourtFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findUniqueOrThrow
   */
  export type CourtFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court findFirst
   */
  export type CourtFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findFirstOrThrow
   */
  export type CourtFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Court to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courts.
     */
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court findMany
   */
  export type CourtFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter, which Courts to fetch.
     */
    where?: CourtWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courts to fetch.
     */
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courts.
     */
    cursor?: CourtWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courts.
     */
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * Court create
   */
  export type CourtCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to create a Court.
     */
    data: XOR<CourtCreateInput, CourtUncheckedCreateInput>
  }

  /**
   * Court createMany
   */
  export type CourtCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courts.
     */
    data: CourtCreateManyInput | CourtCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Court update
   */
  export type CourtUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The data needed to update a Court.
     */
    data: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
    /**
     * Choose, which Court to update.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court updateMany
   */
  export type CourtUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courts.
     */
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyInput>
    /**
     * Filter which Courts to update
     */
    where?: CourtWhereInput
  }

  /**
   * Court upsert
   */
  export type CourtUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * The filter to search for the Court to update in case it exists.
     */
    where: CourtWhereUniqueInput
    /**
     * In case the Court found by the `where` argument doesn't exist, create a new Court with this data.
     */
    create: XOR<CourtCreateInput, CourtUncheckedCreateInput>
    /**
     * In case the Court was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourtUpdateInput, CourtUncheckedUpdateInput>
  }

  /**
   * Court delete
   */
  export type CourtDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    /**
     * Filter which Court to delete.
     */
    where: CourtWhereUniqueInput
  }

  /**
   * Court deleteMany
   */
  export type CourtDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courts to delete
     */
    where?: CourtWhereInput
  }

  /**
   * Court.abonnements
   */
  export type Court$abonnementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    where?: AbonnementWhereInput
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    cursor?: AbonnementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AbonnementScalarFieldEnum | AbonnementScalarFieldEnum[]
  }

  /**
   * Court.reservations
   */
  export type Court$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Court.reservationRules
   */
  export type Court$reservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    where?: ReservationRuleWhereInput
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    cursor?: ReservationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * Court.controlInterfaces
   */
  export type Court$controlInterfacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    where?: ControlInterfaceWhereInput
    orderBy?: ControlInterfaceOrderByWithRelationInput | ControlInterfaceOrderByWithRelationInput[]
    cursor?: ControlInterfaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ControlInterfaceScalarFieldEnum | ControlInterfaceScalarFieldEnum[]
  }

  /**
   * Court without action
   */
  export type CourtDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    price: number | null
    taxRate: number | null
  }

  export type ReservationSumAggregateOutputType = {
    price: number | null
    taxRate: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: string | null
    title: string | null
    start: Date | null
    end: Date | null
    courtId: string | null
    status: $Enums.ReservationStatus | null
    type: $Enums.ReservationType | null
    paypalTransactionId: string | null
    price: number | null
    taxRate: number | null
    light: boolean | null
    radiator: boolean | null
    abonnementId: string | null
    ownerId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    start: Date | null
    end: Date | null
    courtId: string | null
    status: $Enums.ReservationStatus | null
    type: $Enums.ReservationType | null
    paypalTransactionId: string | null
    price: number | null
    taxRate: number | null
    light: boolean | null
    radiator: boolean | null
    abonnementId: string | null
    ownerId: string | null
    createdAt: Date | null
    deletedAt: Date | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    title: number
    start: number
    end: number
    courtId: number
    status: number
    type: number
    paypalTransactionId: number
    price: number
    taxRate: number
    light: number
    radiator: number
    abonnementId: number
    ownerId: number
    createdAt: number
    deletedAt: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    price?: true
    taxRate?: true
  }

  export type ReservationSumAggregateInputType = {
    price?: true
    taxRate?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    courtId?: true
    status?: true
    type?: true
    paypalTransactionId?: true
    price?: true
    taxRate?: true
    light?: true
    radiator?: true
    abonnementId?: true
    ownerId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    courtId?: true
    status?: true
    type?: true
    paypalTransactionId?: true
    price?: true
    taxRate?: true
    light?: true
    radiator?: true
    abonnementId?: true
    ownerId?: true
    createdAt?: true
    deletedAt?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    title?: true
    start?: true
    end?: true
    courtId?: true
    status?: true
    type?: true
    paypalTransactionId?: true
    price?: true
    taxRate?: true
    light?: true
    radiator?: true
    abonnementId?: true
    ownerId?: true
    createdAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: string
    title: string
    start: Date
    end: Date
    courtId: string | null
    status: $Enums.ReservationStatus
    type: $Enums.ReservationType | null
    paypalTransactionId: string | null
    price: number | null
    taxRate: number | null
    light: boolean
    radiator: boolean
    abonnementId: string | null
    ownerId: string | null
    createdAt: Date
    deletedAt: Date | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    courtId?: boolean
    status?: boolean
    type?: boolean
    paypalTransactionId?: boolean
    price?: boolean
    taxRate?: boolean
    light?: boolean
    radiator?: boolean
    abonnementId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
    court?: boolean | Reservation$courtArgs<ExtArgs>
    abo?: boolean | Reservation$aboArgs<ExtArgs>
    owner?: boolean | Reservation$ownerArgs<ExtArgs>
    fellows?: boolean | Reservation$fellowsArgs<ExtArgs>
    transactions?: boolean | Reservation$transactionsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>


  export type ReservationSelectScalar = {
    id?: boolean
    title?: boolean
    start?: boolean
    end?: boolean
    courtId?: boolean
    status?: boolean
    type?: boolean
    paypalTransactionId?: boolean
    price?: boolean
    taxRate?: boolean
    light?: boolean
    radiator?: boolean
    abonnementId?: boolean
    ownerId?: boolean
    createdAt?: boolean
    deletedAt?: boolean
  }

  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | Reservation$courtArgs<ExtArgs>
    abo?: boolean | Reservation$aboArgs<ExtArgs>
    owner?: boolean | Reservation$ownerArgs<ExtArgs>
    fellows?: boolean | Reservation$fellowsArgs<ExtArgs>
    transactions?: boolean | Reservation$transactionsArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      court: Prisma.$CourtPayload<ExtArgs> | null
      abo: Prisma.$AbonnementPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs> | null
      fellows: Prisma.$UserPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      start: Date
      end: Date
      courtId: string | null
      status: $Enums.ReservationStatus
      type: $Enums.ReservationType | null
      paypalTransactionId: string | null
      price: number | null
      taxRate: number | null
      light: boolean
      radiator: boolean
      abonnementId: string | null
      ownerId: string | null
      createdAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    court<T extends Reservation$courtArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$courtArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    abo<T extends Reservation$aboArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$aboArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends Reservation$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fellows<T extends Reservation$fellowsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$fellowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends Reservation$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */ 
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'String'>
    readonly title: FieldRef<"Reservation", 'String'>
    readonly start: FieldRef<"Reservation", 'DateTime'>
    readonly end: FieldRef<"Reservation", 'DateTime'>
    readonly courtId: FieldRef<"Reservation", 'String'>
    readonly status: FieldRef<"Reservation", 'ReservationStatus'>
    readonly type: FieldRef<"Reservation", 'ReservationType'>
    readonly paypalTransactionId: FieldRef<"Reservation", 'String'>
    readonly price: FieldRef<"Reservation", 'Float'>
    readonly taxRate: FieldRef<"Reservation", 'Float'>
    readonly light: FieldRef<"Reservation", 'Boolean'>
    readonly radiator: FieldRef<"Reservation", 'Boolean'>
    readonly abonnementId: FieldRef<"Reservation", 'String'>
    readonly ownerId: FieldRef<"Reservation", 'String'>
    readonly createdAt: FieldRef<"Reservation", 'DateTime'>
    readonly deletedAt: FieldRef<"Reservation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation.court
   */
  export type Reservation$courtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
  }

  /**
   * Reservation.abo
   */
  export type Reservation$aboArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    where?: AbonnementWhereInput
  }

  /**
   * Reservation.owner
   */
  export type Reservation$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Reservation.fellows
   */
  export type Reservation$fellowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Reservation.transactions
   */
  export type Reservation$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model ReservationRule
   */

  export type AggregateReservationRule = {
    _count: ReservationRuleCountAggregateOutputType | null
    _min: ReservationRuleMinAggregateOutputType | null
    _max: ReservationRuleMaxAggregateOutputType | null
  }

  export type ReservationRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    errorDescription: string | null
    checkOn: $Enums.ReservationRuleCheckOn | null
    ruleCheckPluginName: string | null
    value: string | null
  }

  export type ReservationRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    errorDescription: string | null
    checkOn: $Enums.ReservationRuleCheckOn | null
    ruleCheckPluginName: string | null
    value: string | null
  }

  export type ReservationRuleCountAggregateOutputType = {
    id: number
    name: number
    errorDescription: number
    checkOn: number
    ruleCheckPluginName: number
    value: number
    _all: number
  }


  export type ReservationRuleMinAggregateInputType = {
    id?: true
    name?: true
    errorDescription?: true
    checkOn?: true
    ruleCheckPluginName?: true
    value?: true
  }

  export type ReservationRuleMaxAggregateInputType = {
    id?: true
    name?: true
    errorDescription?: true
    checkOn?: true
    ruleCheckPluginName?: true
    value?: true
  }

  export type ReservationRuleCountAggregateInputType = {
    id?: true
    name?: true
    errorDescription?: true
    checkOn?: true
    ruleCheckPluginName?: true
    value?: true
    _all?: true
  }

  export type ReservationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationRule to aggregate.
     */
    where?: ReservationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationRules to fetch.
     */
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReservationRules
    **/
    _count?: true | ReservationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationRuleMaxAggregateInputType
  }

  export type GetReservationRuleAggregateType<T extends ReservationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateReservationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservationRule[P]>
      : GetScalarType<T[P], AggregateReservationRule[P]>
  }




  export type ReservationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationRuleWhereInput
    orderBy?: ReservationRuleOrderByWithAggregationInput | ReservationRuleOrderByWithAggregationInput[]
    by: ReservationRuleScalarFieldEnum[] | ReservationRuleScalarFieldEnum
    having?: ReservationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationRuleCountAggregateInputType | true
    _min?: ReservationRuleMinAggregateInputType
    _max?: ReservationRuleMaxAggregateInputType
  }

  export type ReservationRuleGroupByOutputType = {
    id: string
    name: string
    errorDescription: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName: string | null
    value: string
    _count: ReservationRuleCountAggregateOutputType | null
    _min: ReservationRuleMinAggregateOutputType | null
    _max: ReservationRuleMaxAggregateOutputType | null
  }

  type GetReservationRuleGroupByPayload<T extends ReservationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationRuleGroupByOutputType[P]>
        }
      >
    >


  export type ReservationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    errorDescription?: boolean
    checkOn?: boolean
    ruleCheckPluginName?: boolean
    value?: boolean
    validFor?: boolean | ReservationRule$validForArgs<ExtArgs>
    affectedAreas?: boolean | ReservationRule$affectedAreasArgs<ExtArgs>
    affectedCourts?: boolean | ReservationRule$affectedCourtsArgs<ExtArgs>
    _count?: boolean | ReservationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservationRule"]>


  export type ReservationRuleSelectScalar = {
    id?: boolean
    name?: boolean
    errorDescription?: boolean
    checkOn?: boolean
    ruleCheckPluginName?: boolean
    value?: boolean
  }

  export type ReservationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    validFor?: boolean | ReservationRule$validForArgs<ExtArgs>
    affectedAreas?: boolean | ReservationRule$affectedAreasArgs<ExtArgs>
    affectedCourts?: boolean | ReservationRule$affectedCourtsArgs<ExtArgs>
    _count?: boolean | ReservationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReservationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReservationRule"
    objects: {
      validFor: Prisma.$UserRolePayload<ExtArgs>[]
      affectedAreas: Prisma.$AreaPayload<ExtArgs>[]
      affectedCourts: Prisma.$CourtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      errorDescription: string | null
      checkOn: $Enums.ReservationRuleCheckOn
      ruleCheckPluginName: string | null
      value: string
    }, ExtArgs["result"]["reservationRule"]>
    composites: {}
  }

  type ReservationRuleGetPayload<S extends boolean | null | undefined | ReservationRuleDefaultArgs> = $Result.GetResult<Prisma.$ReservationRulePayload, S>

  type ReservationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservationRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationRuleCountAggregateInputType | true
    }

  export interface ReservationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReservationRule'], meta: { name: 'ReservationRule' } }
    /**
     * Find zero or one ReservationRule that matches the filter.
     * @param {ReservationRuleFindUniqueArgs} args - Arguments to find a ReservationRule
     * @example
     * // Get one ReservationRule
     * const reservationRule = await prisma.reservationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationRuleFindUniqueArgs>(args: SelectSubset<T, ReservationRuleFindUniqueArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ReservationRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservationRuleFindUniqueOrThrowArgs} args - Arguments to find a ReservationRule
     * @example
     * // Get one ReservationRule
     * const reservationRule = await prisma.reservationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ReservationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleFindFirstArgs} args - Arguments to find a ReservationRule
     * @example
     * // Get one ReservationRule
     * const reservationRule = await prisma.reservationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationRuleFindFirstArgs>(args?: SelectSubset<T, ReservationRuleFindFirstArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ReservationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleFindFirstOrThrowArgs} args - Arguments to find a ReservationRule
     * @example
     * // Get one ReservationRule
     * const reservationRule = await prisma.reservationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ReservationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReservationRules
     * const reservationRules = await prisma.reservationRule.findMany()
     * 
     * // Get first 10 ReservationRules
     * const reservationRules = await prisma.reservationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationRuleWithIdOnly = await prisma.reservationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationRuleFindManyArgs>(args?: SelectSubset<T, ReservationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ReservationRule.
     * @param {ReservationRuleCreateArgs} args - Arguments to create a ReservationRule.
     * @example
     * // Create one ReservationRule
     * const ReservationRule = await prisma.reservationRule.create({
     *   data: {
     *     // ... data to create a ReservationRule
     *   }
     * })
     * 
     */
    create<T extends ReservationRuleCreateArgs>(args: SelectSubset<T, ReservationRuleCreateArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ReservationRules.
     * @param {ReservationRuleCreateManyArgs} args - Arguments to create many ReservationRules.
     * @example
     * // Create many ReservationRules
     * const reservationRule = await prisma.reservationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationRuleCreateManyArgs>(args?: SelectSubset<T, ReservationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ReservationRule.
     * @param {ReservationRuleDeleteArgs} args - Arguments to delete one ReservationRule.
     * @example
     * // Delete one ReservationRule
     * const ReservationRule = await prisma.reservationRule.delete({
     *   where: {
     *     // ... filter to delete one ReservationRule
     *   }
     * })
     * 
     */
    delete<T extends ReservationRuleDeleteArgs>(args: SelectSubset<T, ReservationRuleDeleteArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ReservationRule.
     * @param {ReservationRuleUpdateArgs} args - Arguments to update one ReservationRule.
     * @example
     * // Update one ReservationRule
     * const reservationRule = await prisma.reservationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationRuleUpdateArgs>(args: SelectSubset<T, ReservationRuleUpdateArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ReservationRules.
     * @param {ReservationRuleDeleteManyArgs} args - Arguments to filter ReservationRules to delete.
     * @example
     * // Delete a few ReservationRules
     * const { count } = await prisma.reservationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationRuleDeleteManyArgs>(args?: SelectSubset<T, ReservationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReservationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReservationRules
     * const reservationRule = await prisma.reservationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationRuleUpdateManyArgs>(args: SelectSubset<T, ReservationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ReservationRule.
     * @param {ReservationRuleUpsertArgs} args - Arguments to update or create a ReservationRule.
     * @example
     * // Update or create a ReservationRule
     * const reservationRule = await prisma.reservationRule.upsert({
     *   create: {
     *     // ... data to create a ReservationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReservationRule we want to update
     *   }
     * })
     */
    upsert<T extends ReservationRuleUpsertArgs>(args: SelectSubset<T, ReservationRuleUpsertArgs<ExtArgs>>): Prisma__ReservationRuleClient<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ReservationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleCountArgs} args - Arguments to filter ReservationRules to count.
     * @example
     * // Count the number of ReservationRules
     * const count = await prisma.reservationRule.count({
     *   where: {
     *     // ... the filter for the ReservationRules we want to count
     *   }
     * })
    **/
    count<T extends ReservationRuleCountArgs>(
      args?: Subset<T, ReservationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReservationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationRuleAggregateArgs>(args: Subset<T, ReservationRuleAggregateArgs>): Prisma.PrismaPromise<GetReservationRuleAggregateType<T>>

    /**
     * Group by ReservationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationRuleGroupByArgs['orderBy'] }
        : { orderBy?: ReservationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReservationRule model
   */
  readonly fields: ReservationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReservationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    validFor<T extends ReservationRule$validForArgs<ExtArgs> = {}>(args?: Subset<T, ReservationRule$validForArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    affectedAreas<T extends ReservationRule$affectedAreasArgs<ExtArgs> = {}>(args?: Subset<T, ReservationRule$affectedAreasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany"> | Null>
    affectedCourts<T extends ReservationRule$affectedCourtsArgs<ExtArgs> = {}>(args?: Subset<T, ReservationRule$affectedCourtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReservationRule model
   */ 
  interface ReservationRuleFieldRefs {
    readonly id: FieldRef<"ReservationRule", 'String'>
    readonly name: FieldRef<"ReservationRule", 'String'>
    readonly errorDescription: FieldRef<"ReservationRule", 'String'>
    readonly checkOn: FieldRef<"ReservationRule", 'ReservationRuleCheckOn'>
    readonly ruleCheckPluginName: FieldRef<"ReservationRule", 'String'>
    readonly value: FieldRef<"ReservationRule", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ReservationRule findUnique
   */
  export type ReservationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReservationRule to fetch.
     */
    where: ReservationRuleWhereUniqueInput
  }

  /**
   * ReservationRule findUniqueOrThrow
   */
  export type ReservationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReservationRule to fetch.
     */
    where: ReservationRuleWhereUniqueInput
  }

  /**
   * ReservationRule findFirst
   */
  export type ReservationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReservationRule to fetch.
     */
    where?: ReservationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationRules to fetch.
     */
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationRules.
     */
    cursor?: ReservationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationRules.
     */
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * ReservationRule findFirstOrThrow
   */
  export type ReservationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReservationRule to fetch.
     */
    where?: ReservationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationRules to fetch.
     */
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReservationRules.
     */
    cursor?: ReservationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReservationRules.
     */
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * ReservationRule findMany
   */
  export type ReservationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter, which ReservationRules to fetch.
     */
    where?: ReservationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReservationRules to fetch.
     */
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReservationRules.
     */
    cursor?: ReservationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReservationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReservationRules.
     */
    skip?: number
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * ReservationRule create
   */
  export type ReservationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ReservationRule.
     */
    data: XOR<ReservationRuleCreateInput, ReservationRuleUncheckedCreateInput>
  }

  /**
   * ReservationRule createMany
   */
  export type ReservationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReservationRules.
     */
    data: ReservationRuleCreateManyInput | ReservationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReservationRule update
   */
  export type ReservationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ReservationRule.
     */
    data: XOR<ReservationRuleUpdateInput, ReservationRuleUncheckedUpdateInput>
    /**
     * Choose, which ReservationRule to update.
     */
    where: ReservationRuleWhereUniqueInput
  }

  /**
   * ReservationRule updateMany
   */
  export type ReservationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReservationRules.
     */
    data: XOR<ReservationRuleUpdateManyMutationInput, ReservationRuleUncheckedUpdateManyInput>
    /**
     * Filter which ReservationRules to update
     */
    where?: ReservationRuleWhereInput
  }

  /**
   * ReservationRule upsert
   */
  export type ReservationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ReservationRule to update in case it exists.
     */
    where: ReservationRuleWhereUniqueInput
    /**
     * In case the ReservationRule found by the `where` argument doesn't exist, create a new ReservationRule with this data.
     */
    create: XOR<ReservationRuleCreateInput, ReservationRuleUncheckedCreateInput>
    /**
     * In case the ReservationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationRuleUpdateInput, ReservationRuleUncheckedUpdateInput>
  }

  /**
   * ReservationRule delete
   */
  export type ReservationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    /**
     * Filter which ReservationRule to delete.
     */
    where: ReservationRuleWhereUniqueInput
  }

  /**
   * ReservationRule deleteMany
   */
  export type ReservationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReservationRules to delete
     */
    where?: ReservationRuleWhereInput
  }

  /**
   * ReservationRule.validFor
   */
  export type ReservationRule$validForArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * ReservationRule.affectedAreas
   */
  export type ReservationRule$affectedAreasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    cursor?: AreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * ReservationRule.affectedCourts
   */
  export type ReservationRule$affectedCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    cursor?: CourtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * ReservationRule without action
   */
  export type ReservationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
  }


  /**
   * Model Abonnement
   */

  export type AggregateAbonnement = {
    _count: AbonnementCountAggregateOutputType | null
    _avg: AbonnementAvgAggregateOutputType | null
    _sum: AbonnementSumAggregateOutputType | null
    _min: AbonnementMinAggregateOutputType | null
    _max: AbonnementMaxAggregateOutputType | null
  }

  export type AbonnementAvgAggregateOutputType = {
    weekday: number | null
    duration: number | null
  }

  export type AbonnementSumAggregateOutputType = {
    weekday: number | null
    duration: number | null
  }

  export type AbonnementMinAggregateOutputType = {
    id: string | null
    name: string | null
    weekday: number | null
    start: Date | null
    duration: number | null
    status: $Enums.AbonnementStatus | null
    courtId: string | null
    ownerId: string | null
  }

  export type AbonnementMaxAggregateOutputType = {
    id: string | null
    name: string | null
    weekday: number | null
    start: Date | null
    duration: number | null
    status: $Enums.AbonnementStatus | null
    courtId: string | null
    ownerId: string | null
  }

  export type AbonnementCountAggregateOutputType = {
    id: number
    name: number
    weekday: number
    start: number
    duration: number
    status: number
    courtId: number
    ownerId: number
    _all: number
  }


  export type AbonnementAvgAggregateInputType = {
    weekday?: true
    duration?: true
  }

  export type AbonnementSumAggregateInputType = {
    weekday?: true
    duration?: true
  }

  export type AbonnementMinAggregateInputType = {
    id?: true
    name?: true
    weekday?: true
    start?: true
    duration?: true
    status?: true
    courtId?: true
    ownerId?: true
  }

  export type AbonnementMaxAggregateInputType = {
    id?: true
    name?: true
    weekday?: true
    start?: true
    duration?: true
    status?: true
    courtId?: true
    ownerId?: true
  }

  export type AbonnementCountAggregateInputType = {
    id?: true
    name?: true
    weekday?: true
    start?: true
    duration?: true
    status?: true
    courtId?: true
    ownerId?: true
    _all?: true
  }

  export type AbonnementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abonnement to aggregate.
     */
    where?: AbonnementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abonnements to fetch.
     */
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AbonnementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abonnements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abonnements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Abonnements
    **/
    _count?: true | AbonnementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AbonnementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AbonnementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AbonnementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AbonnementMaxAggregateInputType
  }

  export type GetAbonnementAggregateType<T extends AbonnementAggregateArgs> = {
        [P in keyof T & keyof AggregateAbonnement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAbonnement[P]>
      : GetScalarType<T[P], AggregateAbonnement[P]>
  }




  export type AbonnementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AbonnementWhereInput
    orderBy?: AbonnementOrderByWithAggregationInput | AbonnementOrderByWithAggregationInput[]
    by: AbonnementScalarFieldEnum[] | AbonnementScalarFieldEnum
    having?: AbonnementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AbonnementCountAggregateInputType | true
    _avg?: AbonnementAvgAggregateInputType
    _sum?: AbonnementSumAggregateInputType
    _min?: AbonnementMinAggregateInputType
    _max?: AbonnementMaxAggregateInputType
  }

  export type AbonnementGroupByOutputType = {
    id: string
    name: string
    weekday: number
    start: Date
    duration: number
    status: $Enums.AbonnementStatus
    courtId: string | null
    ownerId: string | null
    _count: AbonnementCountAggregateOutputType | null
    _avg: AbonnementAvgAggregateOutputType | null
    _sum: AbonnementSumAggregateOutputType | null
    _min: AbonnementMinAggregateOutputType | null
    _max: AbonnementMaxAggregateOutputType | null
  }

  type GetAbonnementGroupByPayload<T extends AbonnementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AbonnementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AbonnementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AbonnementGroupByOutputType[P]>
            : GetScalarType<T[P], AbonnementGroupByOutputType[P]>
        }
      >
    >


  export type AbonnementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    weekday?: boolean
    start?: boolean
    duration?: boolean
    status?: boolean
    courtId?: boolean
    ownerId?: boolean
    court?: boolean | Abonnement$courtArgs<ExtArgs>
    owner?: boolean | Abonnement$ownerArgs<ExtArgs>
    transactions?: boolean | Abonnement$transactionsArgs<ExtArgs>
    reservations?: boolean | Abonnement$reservationsArgs<ExtArgs>
    _count?: boolean | AbonnementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["abonnement"]>


  export type AbonnementSelectScalar = {
    id?: boolean
    name?: boolean
    weekday?: boolean
    start?: boolean
    duration?: boolean
    status?: boolean
    courtId?: boolean
    ownerId?: boolean
  }

  export type AbonnementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    court?: boolean | Abonnement$courtArgs<ExtArgs>
    owner?: boolean | Abonnement$ownerArgs<ExtArgs>
    transactions?: boolean | Abonnement$transactionsArgs<ExtArgs>
    reservations?: boolean | Abonnement$reservationsArgs<ExtArgs>
    _count?: boolean | AbonnementCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $AbonnementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Abonnement"
    objects: {
      court: Prisma.$CourtPayload<ExtArgs> | null
      owner: Prisma.$UserPayload<ExtArgs> | null
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      weekday: number
      start: Date
      duration: number
      status: $Enums.AbonnementStatus
      courtId: string | null
      ownerId: string | null
    }, ExtArgs["result"]["abonnement"]>
    composites: {}
  }

  type AbonnementGetPayload<S extends boolean | null | undefined | AbonnementDefaultArgs> = $Result.GetResult<Prisma.$AbonnementPayload, S>

  type AbonnementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AbonnementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AbonnementCountAggregateInputType | true
    }

  export interface AbonnementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Abonnement'], meta: { name: 'Abonnement' } }
    /**
     * Find zero or one Abonnement that matches the filter.
     * @param {AbonnementFindUniqueArgs} args - Arguments to find a Abonnement
     * @example
     * // Get one Abonnement
     * const abonnement = await prisma.abonnement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AbonnementFindUniqueArgs>(args: SelectSubset<T, AbonnementFindUniqueArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Abonnement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AbonnementFindUniqueOrThrowArgs} args - Arguments to find a Abonnement
     * @example
     * // Get one Abonnement
     * const abonnement = await prisma.abonnement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AbonnementFindUniqueOrThrowArgs>(args: SelectSubset<T, AbonnementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Abonnement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementFindFirstArgs} args - Arguments to find a Abonnement
     * @example
     * // Get one Abonnement
     * const abonnement = await prisma.abonnement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AbonnementFindFirstArgs>(args?: SelectSubset<T, AbonnementFindFirstArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Abonnement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementFindFirstOrThrowArgs} args - Arguments to find a Abonnement
     * @example
     * // Get one Abonnement
     * const abonnement = await prisma.abonnement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AbonnementFindFirstOrThrowArgs>(args?: SelectSubset<T, AbonnementFindFirstOrThrowArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Abonnements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Abonnements
     * const abonnements = await prisma.abonnement.findMany()
     * 
     * // Get first 10 Abonnements
     * const abonnements = await prisma.abonnement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const abonnementWithIdOnly = await prisma.abonnement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AbonnementFindManyArgs>(args?: SelectSubset<T, AbonnementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Abonnement.
     * @param {AbonnementCreateArgs} args - Arguments to create a Abonnement.
     * @example
     * // Create one Abonnement
     * const Abonnement = await prisma.abonnement.create({
     *   data: {
     *     // ... data to create a Abonnement
     *   }
     * })
     * 
     */
    create<T extends AbonnementCreateArgs>(args: SelectSubset<T, AbonnementCreateArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Abonnements.
     * @param {AbonnementCreateManyArgs} args - Arguments to create many Abonnements.
     * @example
     * // Create many Abonnements
     * const abonnement = await prisma.abonnement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AbonnementCreateManyArgs>(args?: SelectSubset<T, AbonnementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Abonnement.
     * @param {AbonnementDeleteArgs} args - Arguments to delete one Abonnement.
     * @example
     * // Delete one Abonnement
     * const Abonnement = await prisma.abonnement.delete({
     *   where: {
     *     // ... filter to delete one Abonnement
     *   }
     * })
     * 
     */
    delete<T extends AbonnementDeleteArgs>(args: SelectSubset<T, AbonnementDeleteArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Abonnement.
     * @param {AbonnementUpdateArgs} args - Arguments to update one Abonnement.
     * @example
     * // Update one Abonnement
     * const abonnement = await prisma.abonnement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AbonnementUpdateArgs>(args: SelectSubset<T, AbonnementUpdateArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Abonnements.
     * @param {AbonnementDeleteManyArgs} args - Arguments to filter Abonnements to delete.
     * @example
     * // Delete a few Abonnements
     * const { count } = await prisma.abonnement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AbonnementDeleteManyArgs>(args?: SelectSubset<T, AbonnementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Abonnements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Abonnements
     * const abonnement = await prisma.abonnement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AbonnementUpdateManyArgs>(args: SelectSubset<T, AbonnementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Abonnement.
     * @param {AbonnementUpsertArgs} args - Arguments to update or create a Abonnement.
     * @example
     * // Update or create a Abonnement
     * const abonnement = await prisma.abonnement.upsert({
     *   create: {
     *     // ... data to create a Abonnement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Abonnement we want to update
     *   }
     * })
     */
    upsert<T extends AbonnementUpsertArgs>(args: SelectSubset<T, AbonnementUpsertArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Abonnements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementCountArgs} args - Arguments to filter Abonnements to count.
     * @example
     * // Count the number of Abonnements
     * const count = await prisma.abonnement.count({
     *   where: {
     *     // ... the filter for the Abonnements we want to count
     *   }
     * })
    **/
    count<T extends AbonnementCountArgs>(
      args?: Subset<T, AbonnementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AbonnementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Abonnement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AbonnementAggregateArgs>(args: Subset<T, AbonnementAggregateArgs>): Prisma.PrismaPromise<GetAbonnementAggregateType<T>>

    /**
     * Group by Abonnement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AbonnementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AbonnementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AbonnementGroupByArgs['orderBy'] }
        : { orderBy?: AbonnementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AbonnementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAbonnementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Abonnement model
   */
  readonly fields: AbonnementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Abonnement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AbonnementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    court<T extends Abonnement$courtArgs<ExtArgs> = {}>(args?: Subset<T, Abonnement$courtArgs<ExtArgs>>): Prisma__CourtClient<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    owner<T extends Abonnement$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Abonnement$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    transactions<T extends Abonnement$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Abonnement$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany"> | Null>
    reservations<T extends Abonnement$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Abonnement$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Abonnement model
   */ 
  interface AbonnementFieldRefs {
    readonly id: FieldRef<"Abonnement", 'String'>
    readonly name: FieldRef<"Abonnement", 'String'>
    readonly weekday: FieldRef<"Abonnement", 'Int'>
    readonly start: FieldRef<"Abonnement", 'DateTime'>
    readonly duration: FieldRef<"Abonnement", 'Float'>
    readonly status: FieldRef<"Abonnement", 'AbonnementStatus'>
    readonly courtId: FieldRef<"Abonnement", 'String'>
    readonly ownerId: FieldRef<"Abonnement", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Abonnement findUnique
   */
  export type AbonnementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter, which Abonnement to fetch.
     */
    where: AbonnementWhereUniqueInput
  }

  /**
   * Abonnement findUniqueOrThrow
   */
  export type AbonnementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter, which Abonnement to fetch.
     */
    where: AbonnementWhereUniqueInput
  }

  /**
   * Abonnement findFirst
   */
  export type AbonnementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter, which Abonnement to fetch.
     */
    where?: AbonnementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abonnements to fetch.
     */
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abonnements.
     */
    cursor?: AbonnementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abonnements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abonnements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abonnements.
     */
    distinct?: AbonnementScalarFieldEnum | AbonnementScalarFieldEnum[]
  }

  /**
   * Abonnement findFirstOrThrow
   */
  export type AbonnementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter, which Abonnement to fetch.
     */
    where?: AbonnementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abonnements to fetch.
     */
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Abonnements.
     */
    cursor?: AbonnementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abonnements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abonnements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Abonnements.
     */
    distinct?: AbonnementScalarFieldEnum | AbonnementScalarFieldEnum[]
  }

  /**
   * Abonnement findMany
   */
  export type AbonnementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter, which Abonnements to fetch.
     */
    where?: AbonnementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Abonnements to fetch.
     */
    orderBy?: AbonnementOrderByWithRelationInput | AbonnementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Abonnements.
     */
    cursor?: AbonnementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Abonnements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Abonnements.
     */
    skip?: number
    distinct?: AbonnementScalarFieldEnum | AbonnementScalarFieldEnum[]
  }

  /**
   * Abonnement create
   */
  export type AbonnementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * The data needed to create a Abonnement.
     */
    data: XOR<AbonnementCreateInput, AbonnementUncheckedCreateInput>
  }

  /**
   * Abonnement createMany
   */
  export type AbonnementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Abonnements.
     */
    data: AbonnementCreateManyInput | AbonnementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Abonnement update
   */
  export type AbonnementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * The data needed to update a Abonnement.
     */
    data: XOR<AbonnementUpdateInput, AbonnementUncheckedUpdateInput>
    /**
     * Choose, which Abonnement to update.
     */
    where: AbonnementWhereUniqueInput
  }

  /**
   * Abonnement updateMany
   */
  export type AbonnementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Abonnements.
     */
    data: XOR<AbonnementUpdateManyMutationInput, AbonnementUncheckedUpdateManyInput>
    /**
     * Filter which Abonnements to update
     */
    where?: AbonnementWhereInput
  }

  /**
   * Abonnement upsert
   */
  export type AbonnementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * The filter to search for the Abonnement to update in case it exists.
     */
    where: AbonnementWhereUniqueInput
    /**
     * In case the Abonnement found by the `where` argument doesn't exist, create a new Abonnement with this data.
     */
    create: XOR<AbonnementCreateInput, AbonnementUncheckedCreateInput>
    /**
     * In case the Abonnement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AbonnementUpdateInput, AbonnementUncheckedUpdateInput>
  }

  /**
   * Abonnement delete
   */
  export type AbonnementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    /**
     * Filter which Abonnement to delete.
     */
    where: AbonnementWhereUniqueInput
  }

  /**
   * Abonnement deleteMany
   */
  export type AbonnementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Abonnements to delete
     */
    where?: AbonnementWhereInput
  }

  /**
   * Abonnement.court
   */
  export type Abonnement$courtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
  }

  /**
   * Abonnement.owner
   */
  export type Abonnement$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Abonnement.transactions
   */
  export type Abonnement$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Abonnement.reservations
   */
  export type Abonnement$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Abonnement without action
   */
  export type AbonnementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
  }


  /**
   * Model UserRole
   */

  export type AggregateUserRole = {
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  export type UserRoleAvgAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type UserRoleSumAggregateOutputType = {
    id: number | null
    priority: number | null
  }

  export type UserRoleMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isDefault: boolean | null
    priority: number | null
  }

  export type UserRoleMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    isDefault: boolean | null
    priority: number | null
  }

  export type UserRoleCountAggregateOutputType = {
    id: number
    title: number
    description: number
    isDefault: number
    priority: number
    _all: number
  }


  export type UserRoleAvgAggregateInputType = {
    id?: true
    priority?: true
  }

  export type UserRoleSumAggregateInputType = {
    id?: true
    priority?: true
  }

  export type UserRoleMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isDefault?: true
    priority?: true
  }

  export type UserRoleMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isDefault?: true
    priority?: true
  }

  export type UserRoleCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    isDefault?: true
    priority?: true
    _all?: true
  }

  export type UserRoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRole to aggregate.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserRoles
    **/
    _count?: true | UserRoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserRoleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserRoleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserRoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserRoleMaxAggregateInputType
  }

  export type GetUserRoleAggregateType<T extends UserRoleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserRole[P]>
      : GetScalarType<T[P], AggregateUserRole[P]>
  }




  export type UserRoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithAggregationInput | UserRoleOrderByWithAggregationInput[]
    by: UserRoleScalarFieldEnum[] | UserRoleScalarFieldEnum
    having?: UserRoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserRoleCountAggregateInputType | true
    _avg?: UserRoleAvgAggregateInputType
    _sum?: UserRoleSumAggregateInputType
    _min?: UserRoleMinAggregateInputType
    _max?: UserRoleMaxAggregateInputType
  }

  export type UserRoleGroupByOutputType = {
    id: number
    title: string
    description: string | null
    isDefault: boolean
    priority: number
    _count: UserRoleCountAggregateOutputType | null
    _avg: UserRoleAvgAggregateOutputType | null
    _sum: UserRoleSumAggregateOutputType | null
    _min: UserRoleMinAggregateOutputType | null
    _max: UserRoleMaxAggregateOutputType | null
  }

  type GetUserRoleGroupByPayload<T extends UserRoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserRoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserRoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
            : GetScalarType<T[P], UserRoleGroupByOutputType[P]>
        }
      >
    >


  export type UserRoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    isDefault?: boolean
    priority?: boolean
    permissions?: boolean | UserRole$permissionsArgs<ExtArgs>
    users?: boolean | UserRole$usersArgs<ExtArgs>
    prices?: boolean | UserRole$pricesArgs<ExtArgs>
    reservationRules?: boolean | UserRole$reservationRulesArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userRole"]>


  export type UserRoleSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    isDefault?: boolean
    priority?: boolean
  }

  export type UserRoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | UserRole$permissionsArgs<ExtArgs>
    users?: boolean | UserRole$usersArgs<ExtArgs>
    prices?: boolean | UserRole$pricesArgs<ExtArgs>
    reservationRules?: boolean | UserRole$reservationRulesArgs<ExtArgs>
    _count?: boolean | UserRoleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserRolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserRole"
    objects: {
      permissions: Prisma.$PermissionPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      prices: Prisma.$PricePayload<ExtArgs>[]
      reservationRules: Prisma.$ReservationRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      isDefault: boolean
      priority: number
    }, ExtArgs["result"]["userRole"]>
    composites: {}
  }

  type UserRoleGetPayload<S extends boolean | null | undefined | UserRoleDefaultArgs> = $Result.GetResult<Prisma.$UserRolePayload, S>

  type UserRoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserRoleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserRoleCountAggregateInputType | true
    }

  export interface UserRoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserRole'], meta: { name: 'UserRole' } }
    /**
     * Find zero or one UserRole that matches the filter.
     * @param {UserRoleFindUniqueArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserRoleFindUniqueArgs>(args: SelectSubset<T, UserRoleFindUniqueArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserRole that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserRoleFindUniqueOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserRoleFindUniqueOrThrowArgs>(args: SelectSubset<T, UserRoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserRole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserRoleFindFirstArgs>(args?: SelectSubset<T, UserRoleFindFirstArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserRole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindFirstOrThrowArgs} args - Arguments to find a UserRole
     * @example
     * // Get one UserRole
     * const userRole = await prisma.userRole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserRoleFindFirstOrThrowArgs>(args?: SelectSubset<T, UserRoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserRoles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserRoles
     * const userRoles = await prisma.userRole.findMany()
     * 
     * // Get first 10 UserRoles
     * const userRoles = await prisma.userRole.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userRoleWithIdOnly = await prisma.userRole.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserRoleFindManyArgs>(args?: SelectSubset<T, UserRoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserRole.
     * @param {UserRoleCreateArgs} args - Arguments to create a UserRole.
     * @example
     * // Create one UserRole
     * const UserRole = await prisma.userRole.create({
     *   data: {
     *     // ... data to create a UserRole
     *   }
     * })
     * 
     */
    create<T extends UserRoleCreateArgs>(args: SelectSubset<T, UserRoleCreateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserRoles.
     * @param {UserRoleCreateManyArgs} args - Arguments to create many UserRoles.
     * @example
     * // Create many UserRoles
     * const userRole = await prisma.userRole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserRoleCreateManyArgs>(args?: SelectSubset<T, UserRoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserRole.
     * @param {UserRoleDeleteArgs} args - Arguments to delete one UserRole.
     * @example
     * // Delete one UserRole
     * const UserRole = await prisma.userRole.delete({
     *   where: {
     *     // ... filter to delete one UserRole
     *   }
     * })
     * 
     */
    delete<T extends UserRoleDeleteArgs>(args: SelectSubset<T, UserRoleDeleteArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserRole.
     * @param {UserRoleUpdateArgs} args - Arguments to update one UserRole.
     * @example
     * // Update one UserRole
     * const userRole = await prisma.userRole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserRoleUpdateArgs>(args: SelectSubset<T, UserRoleUpdateArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserRoles.
     * @param {UserRoleDeleteManyArgs} args - Arguments to filter UserRoles to delete.
     * @example
     * // Delete a few UserRoles
     * const { count } = await prisma.userRole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserRoleDeleteManyArgs>(args?: SelectSubset<T, UserRoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserRoles
     * const userRole = await prisma.userRole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserRoleUpdateManyArgs>(args: SelectSubset<T, UserRoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserRole.
     * @param {UserRoleUpsertArgs} args - Arguments to update or create a UserRole.
     * @example
     * // Update or create a UserRole
     * const userRole = await prisma.userRole.upsert({
     *   create: {
     *     // ... data to create a UserRole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserRole we want to update
     *   }
     * })
     */
    upsert<T extends UserRoleUpsertArgs>(args: SelectSubset<T, UserRoleUpsertArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserRoles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleCountArgs} args - Arguments to filter UserRoles to count.
     * @example
     * // Count the number of UserRoles
     * const count = await prisma.userRole.count({
     *   where: {
     *     // ... the filter for the UserRoles we want to count
     *   }
     * })
    **/
    count<T extends UserRoleCountArgs>(
      args?: Subset<T, UserRoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserRoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserRoleAggregateArgs>(args: Subset<T, UserRoleAggregateArgs>): Prisma.PrismaPromise<GetUserRoleAggregateType<T>>

    /**
     * Group by UserRole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserRoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserRoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserRoleGroupByArgs['orderBy'] }
        : { orderBy?: UserRoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserRoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserRole model
   */
  readonly fields: UserRoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserRole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserRoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends UserRole$permissionsArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends UserRole$usersArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    prices<T extends UserRole$pricesArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany"> | Null>
    reservationRules<T extends UserRole$reservationRulesArgs<ExtArgs> = {}>(args?: Subset<T, UserRole$reservationRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationRulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserRole model
   */ 
  interface UserRoleFieldRefs {
    readonly id: FieldRef<"UserRole", 'Int'>
    readonly title: FieldRef<"UserRole", 'String'>
    readonly description: FieldRef<"UserRole", 'String'>
    readonly isDefault: FieldRef<"UserRole", 'Boolean'>
    readonly priority: FieldRef<"UserRole", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UserRole findUnique
   */
  export type UserRoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findUniqueOrThrow
   */
  export type UserRoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole findFirst
   */
  export type UserRoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findFirstOrThrow
   */
  export type UserRoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRole to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserRoles.
     */
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole findMany
   */
  export type UserRoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter, which UserRoles to fetch.
     */
    where?: UserRoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserRoles to fetch.
     */
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserRoles.
     */
    cursor?: UserRoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserRoles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserRoles.
     */
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * UserRole create
   */
  export type UserRoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to create a UserRole.
     */
    data: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
  }

  /**
   * UserRole createMany
   */
  export type UserRoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserRoles.
     */
    data: UserRoleCreateManyInput | UserRoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserRole update
   */
  export type UserRoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The data needed to update a UserRole.
     */
    data: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
    /**
     * Choose, which UserRole to update.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole updateMany
   */
  export type UserRoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserRoles.
     */
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyInput>
    /**
     * Filter which UserRoles to update
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole upsert
   */
  export type UserRoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * The filter to search for the UserRole to update in case it exists.
     */
    where: UserRoleWhereUniqueInput
    /**
     * In case the UserRole found by the `where` argument doesn't exist, create a new UserRole with this data.
     */
    create: XOR<UserRoleCreateInput, UserRoleUncheckedCreateInput>
    /**
     * In case the UserRole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserRoleUpdateInput, UserRoleUncheckedUpdateInput>
  }

  /**
   * UserRole delete
   */
  export type UserRoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    /**
     * Filter which UserRole to delete.
     */
    where: UserRoleWhereUniqueInput
  }

  /**
   * UserRole deleteMany
   */
  export type UserRoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserRoles to delete
     */
    where?: UserRoleWhereInput
  }

  /**
   * UserRole.permissions
   */
  export type UserRole$permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    cursor?: PermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * UserRole.users
   */
  export type UserRole$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * UserRole.prices
   */
  export type UserRole$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    cursor?: PriceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * UserRole.reservationRules
   */
  export type UserRole$reservationRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationRule
     */
    select?: ReservationRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationRuleInclude<ExtArgs> | null
    where?: ReservationRuleWhereInput
    orderBy?: ReservationRuleOrderByWithRelationInput | ReservationRuleOrderByWithRelationInput[]
    cursor?: ReservationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationRuleScalarFieldEnum | ReservationRuleScalarFieldEnum[]
  }

  /**
   * UserRole without action
   */
  export type UserRoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
  }


  /**
   * Model Permission
   */

  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionAvgAggregateOutputType = {
    userRoleId: number | null
  }

  export type PermissionSumAggregateOutputType = {
    userRoleId: number | null
  }

  export type PermissionMinAggregateOutputType = {
    router: string | null
    action: string | null
    userRoleId: number | null
    allowed: $Enums.PermissionState | null
  }

  export type PermissionMaxAggregateOutputType = {
    router: string | null
    action: string | null
    userRoleId: number | null
    allowed: $Enums.PermissionState | null
  }

  export type PermissionCountAggregateOutputType = {
    router: number
    action: number
    userRoleId: number
    allowed: number
    _all: number
  }


  export type PermissionAvgAggregateInputType = {
    userRoleId?: true
  }

  export type PermissionSumAggregateInputType = {
    userRoleId?: true
  }

  export type PermissionMinAggregateInputType = {
    router?: true
    action?: true
    userRoleId?: true
    allowed?: true
  }

  export type PermissionMaxAggregateInputType = {
    router?: true
    action?: true
    userRoleId?: true
    allowed?: true
  }

  export type PermissionCountAggregateInputType = {
    router?: true
    action?: true
    userRoleId?: true
    allowed?: true
    _all?: true
  }

  export type PermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permission to aggregate.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionWhereInput
    orderBy?: PermissionOrderByWithAggregationInput | PermissionOrderByWithAggregationInput[]
    by: PermissionScalarFieldEnum[] | PermissionScalarFieldEnum
    having?: PermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _avg?: PermissionAvgAggregateInputType
    _sum?: PermissionSumAggregateInputType
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }

  export type PermissionGroupByOutputType = {
    router: string
    action: string
    userRoleId: number
    allowed: $Enums.PermissionState
    _count: PermissionCountAggregateOutputType | null
    _avg: PermissionAvgAggregateOutputType | null
    _sum: PermissionSumAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type PermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    router?: boolean
    action?: boolean
    userRoleId?: boolean
    allowed?: boolean
    userRole?: boolean | UserRoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permission"]>


  export type PermissionSelectScalar = {
    router?: boolean
    action?: boolean
    userRoleId?: boolean
    allowed?: boolean
  }

  export type PermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userRole?: boolean | UserRoleDefaultArgs<ExtArgs>
  }

  export type $PermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Permission"
    objects: {
      userRole: Prisma.$UserRolePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      router: string
      action: string
      userRoleId: number
      allowed: $Enums.PermissionState
    }, ExtArgs["result"]["permission"]>
    composites: {}
  }

  type PermissionGetPayload<S extends boolean | null | undefined | PermissionDefaultArgs> = $Result.GetResult<Prisma.$PermissionPayload, S>

  type PermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PermissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface PermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Permission'], meta: { name: 'Permission' } }
    /**
     * Find zero or one Permission that matches the filter.
     * @param {PermissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionFindUniqueArgs>(args: SelectSubset<T, PermissionFindUniqueArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Permission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PermissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionFindFirstArgs>(args?: SelectSubset<T, PermissionFindFirstArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Permission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `router`
     * const permissionWithRouterOnly = await prisma.permission.findMany({ select: { router: true } })
     * 
     */
    findMany<T extends PermissionFindManyArgs>(args?: SelectSubset<T, PermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Permission.
     * @param {PermissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
     */
    create<T extends PermissionCreateArgs>(args: SelectSubset<T, PermissionCreateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Permissions.
     * @param {PermissionCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permission = await prisma.permission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionCreateManyArgs>(args?: SelectSubset<T, PermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permission.
     * @param {PermissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
     */
    delete<T extends PermissionDeleteArgs>(args: SelectSubset<T, PermissionDeleteArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Permission.
     * @param {PermissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionUpdateArgs>(args: SelectSubset<T, PermissionUpdateArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Permissions.
     * @param {PermissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionDeleteManyArgs>(args?: SelectSubset<T, PermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionUpdateManyArgs>(args: SelectSubset<T, PermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {PermissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
     */
    upsert<T extends PermissionUpsertArgs>(args: SelectSubset<T, PermissionUpsertArgs<ExtArgs>>): Prisma__PermissionClient<$Result.GetResult<Prisma.$PermissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends PermissionCountArgs>(
      args?: Subset<T, PermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Permission model
   */
  readonly fields: PermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userRole<T extends UserRoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserRoleDefaultArgs<ExtArgs>>): Prisma__UserRoleClient<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Permission model
   */ 
  interface PermissionFieldRefs {
    readonly router: FieldRef<"Permission", 'String'>
    readonly action: FieldRef<"Permission", 'String'>
    readonly userRoleId: FieldRef<"Permission", 'Int'>
    readonly allowed: FieldRef<"Permission", 'PermissionState'>
  }
    

  // Custom InputTypes
  /**
   * Permission findUnique
   */
  export type PermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findUniqueOrThrow
   */
  export type PermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission findFirst
   */
  export type PermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findFirstOrThrow
   */
  export type PermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permission to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Permissions.
     */
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission findMany
   */
  export type PermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter, which Permissions to fetch.
     */
    where?: PermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Permissions to fetch.
     */
    orderBy?: PermissionOrderByWithRelationInput | PermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Permissions.
     */
    cursor?: PermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Permissions.
     */
    skip?: number
    distinct?: PermissionScalarFieldEnum | PermissionScalarFieldEnum[]
  }

  /**
   * Permission create
   */
  export type PermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a Permission.
     */
    data: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
  }

  /**
   * Permission createMany
   */
  export type PermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Permissions.
     */
    data: PermissionCreateManyInput | PermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Permission update
   */
  export type PermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a Permission.
     */
    data: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
    /**
     * Choose, which Permission to update.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission updateMany
   */
  export type PermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Permissions.
     */
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyInput>
    /**
     * Filter which Permissions to update
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission upsert
   */
  export type PermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the Permission to update in case it exists.
     */
    where: PermissionWhereUniqueInput
    /**
     * In case the Permission found by the `where` argument doesn't exist, create a new Permission with this data.
     */
    create: XOR<PermissionCreateInput, PermissionUncheckedCreateInput>
    /**
     * In case the Permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionUpdateInput, PermissionUncheckedUpdateInput>
  }

  /**
   * Permission delete
   */
  export type PermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
    /**
     * Filter which Permission to delete.
     */
    where: PermissionWhereUniqueInput
  }

  /**
   * Permission deleteMany
   */
  export type PermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Permissions to delete
     */
    where?: PermissionWhereInput
  }

  /**
   * Permission without action
   */
  export type PermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Permission
     */
    select?: PermissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionInclude<ExtArgs> | null
  }


  /**
   * Model Hallencard
   */

  export type AggregateHallencard = {
    _count: HallencardCountAggregateOutputType | null
    _avg: HallencardAvgAggregateOutputType | null
    _sum: HallencardSumAggregateOutputType | null
    _min: HallencardMinAggregateOutputType | null
    _max: HallencardMaxAggregateOutputType | null
  }

  export type HallencardAvgAggregateOutputType = {
    value: number | null
  }

  export type HallencardSumAggregateOutputType = {
    value: number | null
  }

  export type HallencardMinAggregateOutputType = {
    code: string | null
    pin: string | null
    value: number | null
    printed: boolean | null
    transactionId: string | null
  }

  export type HallencardMaxAggregateOutputType = {
    code: string | null
    pin: string | null
    value: number | null
    printed: boolean | null
    transactionId: string | null
  }

  export type HallencardCountAggregateOutputType = {
    code: number
    pin: number
    value: number
    printed: number
    transactionId: number
    _all: number
  }


  export type HallencardAvgAggregateInputType = {
    value?: true
  }

  export type HallencardSumAggregateInputType = {
    value?: true
  }

  export type HallencardMinAggregateInputType = {
    code?: true
    pin?: true
    value?: true
    printed?: true
    transactionId?: true
  }

  export type HallencardMaxAggregateInputType = {
    code?: true
    pin?: true
    value?: true
    printed?: true
    transactionId?: true
  }

  export type HallencardCountAggregateInputType = {
    code?: true
    pin?: true
    value?: true
    printed?: true
    transactionId?: true
    _all?: true
  }

  export type HallencardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hallencard to aggregate.
     */
    where?: HallencardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallencards to fetch.
     */
    orderBy?: HallencardOrderByWithRelationInput | HallencardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HallencardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallencards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallencards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hallencards
    **/
    _count?: true | HallencardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HallencardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HallencardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HallencardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HallencardMaxAggregateInputType
  }

  export type GetHallencardAggregateType<T extends HallencardAggregateArgs> = {
        [P in keyof T & keyof AggregateHallencard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHallencard[P]>
      : GetScalarType<T[P], AggregateHallencard[P]>
  }




  export type HallencardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HallencardWhereInput
    orderBy?: HallencardOrderByWithAggregationInput | HallencardOrderByWithAggregationInput[]
    by: HallencardScalarFieldEnum[] | HallencardScalarFieldEnum
    having?: HallencardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HallencardCountAggregateInputType | true
    _avg?: HallencardAvgAggregateInputType
    _sum?: HallencardSumAggregateInputType
    _min?: HallencardMinAggregateInputType
    _max?: HallencardMaxAggregateInputType
  }

  export type HallencardGroupByOutputType = {
    code: string
    pin: string
    value: number
    printed: boolean
    transactionId: string | null
    _count: HallencardCountAggregateOutputType | null
    _avg: HallencardAvgAggregateOutputType | null
    _sum: HallencardSumAggregateOutputType | null
    _min: HallencardMinAggregateOutputType | null
    _max: HallencardMaxAggregateOutputType | null
  }

  type GetHallencardGroupByPayload<T extends HallencardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HallencardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HallencardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HallencardGroupByOutputType[P]>
            : GetScalarType<T[P], HallencardGroupByOutputType[P]>
        }
      >
    >


  export type HallencardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    code?: boolean
    pin?: boolean
    value?: boolean
    printed?: boolean
    transactionId?: boolean
    transaction?: boolean | Hallencard$transactionArgs<ExtArgs>
  }, ExtArgs["result"]["hallencard"]>


  export type HallencardSelectScalar = {
    code?: boolean
    pin?: boolean
    value?: boolean
    printed?: boolean
    transactionId?: boolean
  }

  export type HallencardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | Hallencard$transactionArgs<ExtArgs>
  }

  export type $HallencardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hallencard"
    objects: {
      transaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      code: string
      pin: string
      value: number
      printed: boolean
      transactionId: string | null
    }, ExtArgs["result"]["hallencard"]>
    composites: {}
  }

  type HallencardGetPayload<S extends boolean | null | undefined | HallencardDefaultArgs> = $Result.GetResult<Prisma.$HallencardPayload, S>

  type HallencardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HallencardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HallencardCountAggregateInputType | true
    }

  export interface HallencardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hallencard'], meta: { name: 'Hallencard' } }
    /**
     * Find zero or one Hallencard that matches the filter.
     * @param {HallencardFindUniqueArgs} args - Arguments to find a Hallencard
     * @example
     * // Get one Hallencard
     * const hallencard = await prisma.hallencard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HallencardFindUniqueArgs>(args: SelectSubset<T, HallencardFindUniqueArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hallencard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HallencardFindUniqueOrThrowArgs} args - Arguments to find a Hallencard
     * @example
     * // Get one Hallencard
     * const hallencard = await prisma.hallencard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HallencardFindUniqueOrThrowArgs>(args: SelectSubset<T, HallencardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hallencard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardFindFirstArgs} args - Arguments to find a Hallencard
     * @example
     * // Get one Hallencard
     * const hallencard = await prisma.hallencard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HallencardFindFirstArgs>(args?: SelectSubset<T, HallencardFindFirstArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hallencard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardFindFirstOrThrowArgs} args - Arguments to find a Hallencard
     * @example
     * // Get one Hallencard
     * const hallencard = await prisma.hallencard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HallencardFindFirstOrThrowArgs>(args?: SelectSubset<T, HallencardFindFirstOrThrowArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hallencards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hallencards
     * const hallencards = await prisma.hallencard.findMany()
     * 
     * // Get first 10 Hallencards
     * const hallencards = await prisma.hallencard.findMany({ take: 10 })
     * 
     * // Only select the `code`
     * const hallencardWithCodeOnly = await prisma.hallencard.findMany({ select: { code: true } })
     * 
     */
    findMany<T extends HallencardFindManyArgs>(args?: SelectSubset<T, HallencardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hallencard.
     * @param {HallencardCreateArgs} args - Arguments to create a Hallencard.
     * @example
     * // Create one Hallencard
     * const Hallencard = await prisma.hallencard.create({
     *   data: {
     *     // ... data to create a Hallencard
     *   }
     * })
     * 
     */
    create<T extends HallencardCreateArgs>(args: SelectSubset<T, HallencardCreateArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hallencards.
     * @param {HallencardCreateManyArgs} args - Arguments to create many Hallencards.
     * @example
     * // Create many Hallencards
     * const hallencard = await prisma.hallencard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HallencardCreateManyArgs>(args?: SelectSubset<T, HallencardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hallencard.
     * @param {HallencardDeleteArgs} args - Arguments to delete one Hallencard.
     * @example
     * // Delete one Hallencard
     * const Hallencard = await prisma.hallencard.delete({
     *   where: {
     *     // ... filter to delete one Hallencard
     *   }
     * })
     * 
     */
    delete<T extends HallencardDeleteArgs>(args: SelectSubset<T, HallencardDeleteArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hallencard.
     * @param {HallencardUpdateArgs} args - Arguments to update one Hallencard.
     * @example
     * // Update one Hallencard
     * const hallencard = await prisma.hallencard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HallencardUpdateArgs>(args: SelectSubset<T, HallencardUpdateArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hallencards.
     * @param {HallencardDeleteManyArgs} args - Arguments to filter Hallencards to delete.
     * @example
     * // Delete a few Hallencards
     * const { count } = await prisma.hallencard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HallencardDeleteManyArgs>(args?: SelectSubset<T, HallencardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hallencards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hallencards
     * const hallencard = await prisma.hallencard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HallencardUpdateManyArgs>(args: SelectSubset<T, HallencardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hallencard.
     * @param {HallencardUpsertArgs} args - Arguments to update or create a Hallencard.
     * @example
     * // Update or create a Hallencard
     * const hallencard = await prisma.hallencard.upsert({
     *   create: {
     *     // ... data to create a Hallencard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hallencard we want to update
     *   }
     * })
     */
    upsert<T extends HallencardUpsertArgs>(args: SelectSubset<T, HallencardUpsertArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hallencards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardCountArgs} args - Arguments to filter Hallencards to count.
     * @example
     * // Count the number of Hallencards
     * const count = await prisma.hallencard.count({
     *   where: {
     *     // ... the filter for the Hallencards we want to count
     *   }
     * })
    **/
    count<T extends HallencardCountArgs>(
      args?: Subset<T, HallencardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HallencardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hallencard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HallencardAggregateArgs>(args: Subset<T, HallencardAggregateArgs>): Prisma.PrismaPromise<GetHallencardAggregateType<T>>

    /**
     * Group by Hallencard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HallencardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HallencardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HallencardGroupByArgs['orderBy'] }
        : { orderBy?: HallencardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HallencardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHallencardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hallencard model
   */
  readonly fields: HallencardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hallencard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HallencardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends Hallencard$transactionArgs<ExtArgs> = {}>(args?: Subset<T, Hallencard$transactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hallencard model
   */ 
  interface HallencardFieldRefs {
    readonly code: FieldRef<"Hallencard", 'String'>
    readonly pin: FieldRef<"Hallencard", 'String'>
    readonly value: FieldRef<"Hallencard", 'Float'>
    readonly printed: FieldRef<"Hallencard", 'Boolean'>
    readonly transactionId: FieldRef<"Hallencard", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Hallencard findUnique
   */
  export type HallencardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter, which Hallencard to fetch.
     */
    where: HallencardWhereUniqueInput
  }

  /**
   * Hallencard findUniqueOrThrow
   */
  export type HallencardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter, which Hallencard to fetch.
     */
    where: HallencardWhereUniqueInput
  }

  /**
   * Hallencard findFirst
   */
  export type HallencardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter, which Hallencard to fetch.
     */
    where?: HallencardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallencards to fetch.
     */
    orderBy?: HallencardOrderByWithRelationInput | HallencardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hallencards.
     */
    cursor?: HallencardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallencards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallencards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hallencards.
     */
    distinct?: HallencardScalarFieldEnum | HallencardScalarFieldEnum[]
  }

  /**
   * Hallencard findFirstOrThrow
   */
  export type HallencardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter, which Hallencard to fetch.
     */
    where?: HallencardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallencards to fetch.
     */
    orderBy?: HallencardOrderByWithRelationInput | HallencardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hallencards.
     */
    cursor?: HallencardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallencards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallencards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hallencards.
     */
    distinct?: HallencardScalarFieldEnum | HallencardScalarFieldEnum[]
  }

  /**
   * Hallencard findMany
   */
  export type HallencardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter, which Hallencards to fetch.
     */
    where?: HallencardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hallencards to fetch.
     */
    orderBy?: HallencardOrderByWithRelationInput | HallencardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hallencards.
     */
    cursor?: HallencardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hallencards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hallencards.
     */
    skip?: number
    distinct?: HallencardScalarFieldEnum | HallencardScalarFieldEnum[]
  }

  /**
   * Hallencard create
   */
  export type HallencardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * The data needed to create a Hallencard.
     */
    data: XOR<HallencardCreateInput, HallencardUncheckedCreateInput>
  }

  /**
   * Hallencard createMany
   */
  export type HallencardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hallencards.
     */
    data: HallencardCreateManyInput | HallencardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hallencard update
   */
  export type HallencardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * The data needed to update a Hallencard.
     */
    data: XOR<HallencardUpdateInput, HallencardUncheckedUpdateInput>
    /**
     * Choose, which Hallencard to update.
     */
    where: HallencardWhereUniqueInput
  }

  /**
   * Hallencard updateMany
   */
  export type HallencardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hallencards.
     */
    data: XOR<HallencardUpdateManyMutationInput, HallencardUncheckedUpdateManyInput>
    /**
     * Filter which Hallencards to update
     */
    where?: HallencardWhereInput
  }

  /**
   * Hallencard upsert
   */
  export type HallencardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * The filter to search for the Hallencard to update in case it exists.
     */
    where: HallencardWhereUniqueInput
    /**
     * In case the Hallencard found by the `where` argument doesn't exist, create a new Hallencard with this data.
     */
    create: XOR<HallencardCreateInput, HallencardUncheckedCreateInput>
    /**
     * In case the Hallencard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HallencardUpdateInput, HallencardUncheckedUpdateInput>
  }

  /**
   * Hallencard delete
   */
  export type HallencardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    /**
     * Filter which Hallencard to delete.
     */
    where: HallencardWhereUniqueInput
  }

  /**
   * Hallencard deleteMany
   */
  export type HallencardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hallencards to delete
     */
    where?: HallencardWhereInput
  }

  /**
   * Hallencard.transaction
   */
  export type Hallencard$transactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * Hallencard without action
   */
  export type HallencardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
  }


  /**
   * Model Price
   */

  export type AggregatePrice = {
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  export type PriceAvgAggregateOutputType = {
    from: number | null
    to: number | null
    value: number | null
    taxes: number | null
  }

  export type PriceSumAggregateOutputType = {
    from: number | null
    to: number | null
    value: number | null
    taxes: number | null
  }

  export type PriceMinAggregateOutputType = {
    id: string | null
    validFrom: Date | null
    validTo: Date | null
    isDefault: boolean | null
    mon: boolean | null
    tue: boolean | null
    wed: boolean | null
    thu: boolean | null
    fri: boolean | null
    sat: boolean | null
    sun: boolean | null
    from: number | null
    to: number | null
    value: number | null
    currency: string | null
    taxes: number | null
  }

  export type PriceMaxAggregateOutputType = {
    id: string | null
    validFrom: Date | null
    validTo: Date | null
    isDefault: boolean | null
    mon: boolean | null
    tue: boolean | null
    wed: boolean | null
    thu: boolean | null
    fri: boolean | null
    sat: boolean | null
    sun: boolean | null
    from: number | null
    to: number | null
    value: number | null
    currency: string | null
    taxes: number | null
  }

  export type PriceCountAggregateOutputType = {
    id: number
    validFrom: number
    validTo: number
    isDefault: number
    mon: number
    tue: number
    wed: number
    thu: number
    fri: number
    sat: number
    sun: number
    from: number
    to: number
    value: number
    currency: number
    taxes: number
    _all: number
  }


  export type PriceAvgAggregateInputType = {
    from?: true
    to?: true
    value?: true
    taxes?: true
  }

  export type PriceSumAggregateInputType = {
    from?: true
    to?: true
    value?: true
    taxes?: true
  }

  export type PriceMinAggregateInputType = {
    id?: true
    validFrom?: true
    validTo?: true
    isDefault?: true
    mon?: true
    tue?: true
    wed?: true
    thu?: true
    fri?: true
    sat?: true
    sun?: true
    from?: true
    to?: true
    value?: true
    currency?: true
    taxes?: true
  }

  export type PriceMaxAggregateInputType = {
    id?: true
    validFrom?: true
    validTo?: true
    isDefault?: true
    mon?: true
    tue?: true
    wed?: true
    thu?: true
    fri?: true
    sat?: true
    sun?: true
    from?: true
    to?: true
    value?: true
    currency?: true
    taxes?: true
  }

  export type PriceCountAggregateInputType = {
    id?: true
    validFrom?: true
    validTo?: true
    isDefault?: true
    mon?: true
    tue?: true
    wed?: true
    thu?: true
    fri?: true
    sat?: true
    sun?: true
    from?: true
    to?: true
    value?: true
    currency?: true
    taxes?: true
    _all?: true
  }

  export type PriceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Price to aggregate.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prices
    **/
    _count?: true | PriceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceMaxAggregateInputType
  }

  export type GetPriceAggregateType<T extends PriceAggregateArgs> = {
        [P in keyof T & keyof AggregatePrice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrice[P]>
      : GetScalarType<T[P], AggregatePrice[P]>
  }




  export type PriceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceWhereInput
    orderBy?: PriceOrderByWithAggregationInput | PriceOrderByWithAggregationInput[]
    by: PriceScalarFieldEnum[] | PriceScalarFieldEnum
    having?: PriceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceCountAggregateInputType | true
    _avg?: PriceAvgAggregateInputType
    _sum?: PriceSumAggregateInputType
    _min?: PriceMinAggregateInputType
    _max?: PriceMaxAggregateInputType
  }

  export type PriceGroupByOutputType = {
    id: string
    validFrom: Date | null
    validTo: Date | null
    isDefault: boolean
    mon: boolean
    tue: boolean
    wed: boolean
    thu: boolean
    fri: boolean
    sat: boolean
    sun: boolean
    from: number
    to: number
    value: number
    currency: string
    taxes: number
    _count: PriceCountAggregateOutputType | null
    _avg: PriceAvgAggregateOutputType | null
    _sum: PriceSumAggregateOutputType | null
    _min: PriceMinAggregateOutputType | null
    _max: PriceMaxAggregateOutputType | null
  }

  type GetPriceGroupByPayload<T extends PriceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceGroupByOutputType[P]>
            : GetScalarType<T[P], PriceGroupByOutputType[P]>
        }
      >
    >


  export type PriceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    validFrom?: boolean
    validTo?: boolean
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from?: boolean
    to?: boolean
    value?: boolean
    currency?: boolean
    taxes?: boolean
    roles?: boolean | Price$rolesArgs<ExtArgs>
    areas?: boolean | Price$areasArgs<ExtArgs>
    _count?: boolean | PriceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["price"]>


  export type PriceSelectScalar = {
    id?: boolean
    validFrom?: boolean
    validTo?: boolean
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from?: boolean
    to?: boolean
    value?: boolean
    currency?: boolean
    taxes?: boolean
  }

  export type PriceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | Price$rolesArgs<ExtArgs>
    areas?: boolean | Price$areasArgs<ExtArgs>
    _count?: boolean | PriceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PricePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Price"
    objects: {
      roles: Prisma.$UserRolePayload<ExtArgs>[]
      areas: Prisma.$AreaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      validFrom: Date | null
      validTo: Date | null
      isDefault: boolean
      mon: boolean
      tue: boolean
      wed: boolean
      thu: boolean
      fri: boolean
      sat: boolean
      sun: boolean
      from: number
      to: number
      value: number
      currency: string
      taxes: number
    }, ExtArgs["result"]["price"]>
    composites: {}
  }

  type PriceGetPayload<S extends boolean | null | undefined | PriceDefaultArgs> = $Result.GetResult<Prisma.$PricePayload, S>

  type PriceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceCountAggregateInputType | true
    }

  export interface PriceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Price'], meta: { name: 'Price' } }
    /**
     * Find zero or one Price that matches the filter.
     * @param {PriceFindUniqueArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceFindUniqueArgs>(args: SelectSubset<T, PriceFindUniqueArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Price that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceFindUniqueOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Price that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceFindFirstArgs>(args?: SelectSubset<T, PriceFindFirstArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Price that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindFirstOrThrowArgs} args - Arguments to find a Price
     * @example
     * // Get one Price
     * const price = await prisma.price.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prices
     * const prices = await prisma.price.findMany()
     * 
     * // Get first 10 Prices
     * const prices = await prisma.price.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceWithIdOnly = await prisma.price.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceFindManyArgs>(args?: SelectSubset<T, PriceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Price.
     * @param {PriceCreateArgs} args - Arguments to create a Price.
     * @example
     * // Create one Price
     * const Price = await prisma.price.create({
     *   data: {
     *     // ... data to create a Price
     *   }
     * })
     * 
     */
    create<T extends PriceCreateArgs>(args: SelectSubset<T, PriceCreateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prices.
     * @param {PriceCreateManyArgs} args - Arguments to create many Prices.
     * @example
     * // Create many Prices
     * const price = await prisma.price.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceCreateManyArgs>(args?: SelectSubset<T, PriceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Price.
     * @param {PriceDeleteArgs} args - Arguments to delete one Price.
     * @example
     * // Delete one Price
     * const Price = await prisma.price.delete({
     *   where: {
     *     // ... filter to delete one Price
     *   }
     * })
     * 
     */
    delete<T extends PriceDeleteArgs>(args: SelectSubset<T, PriceDeleteArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Price.
     * @param {PriceUpdateArgs} args - Arguments to update one Price.
     * @example
     * // Update one Price
     * const price = await prisma.price.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceUpdateArgs>(args: SelectSubset<T, PriceUpdateArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prices.
     * @param {PriceDeleteManyArgs} args - Arguments to filter Prices to delete.
     * @example
     * // Delete a few Prices
     * const { count } = await prisma.price.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceDeleteManyArgs>(args?: SelectSubset<T, PriceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prices
     * const price = await prisma.price.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceUpdateManyArgs>(args: SelectSubset<T, PriceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Price.
     * @param {PriceUpsertArgs} args - Arguments to update or create a Price.
     * @example
     * // Update or create a Price
     * const price = await prisma.price.upsert({
     *   create: {
     *     // ... data to create a Price
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Price we want to update
     *   }
     * })
     */
    upsert<T extends PriceUpsertArgs>(args: SelectSubset<T, PriceUpsertArgs<ExtArgs>>): Prisma__PriceClient<$Result.GetResult<Prisma.$PricePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceCountArgs} args - Arguments to filter Prices to count.
     * @example
     * // Count the number of Prices
     * const count = await prisma.price.count({
     *   where: {
     *     // ... the filter for the Prices we want to count
     *   }
     * })
    **/
    count<T extends PriceCountArgs>(
      args?: Subset<T, PriceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceAggregateArgs>(args: Subset<T, PriceAggregateArgs>): Prisma.PrismaPromise<GetPriceAggregateType<T>>

    /**
     * Group by Price.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceGroupByArgs['orderBy'] }
        : { orderBy?: PriceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Price model
   */
  readonly fields: PriceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Price.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends Price$rolesArgs<ExtArgs> = {}>(args?: Subset<T, Price$rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserRolePayload<ExtArgs>, T, "findMany"> | Null>
    areas<T extends Price$areasArgs<ExtArgs> = {}>(args?: Subset<T, Price$areasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Price model
   */ 
  interface PriceFieldRefs {
    readonly id: FieldRef<"Price", 'String'>
    readonly validFrom: FieldRef<"Price", 'DateTime'>
    readonly validTo: FieldRef<"Price", 'DateTime'>
    readonly isDefault: FieldRef<"Price", 'Boolean'>
    readonly mon: FieldRef<"Price", 'Boolean'>
    readonly tue: FieldRef<"Price", 'Boolean'>
    readonly wed: FieldRef<"Price", 'Boolean'>
    readonly thu: FieldRef<"Price", 'Boolean'>
    readonly fri: FieldRef<"Price", 'Boolean'>
    readonly sat: FieldRef<"Price", 'Boolean'>
    readonly sun: FieldRef<"Price", 'Boolean'>
    readonly from: FieldRef<"Price", 'Int'>
    readonly to: FieldRef<"Price", 'Int'>
    readonly value: FieldRef<"Price", 'Float'>
    readonly currency: FieldRef<"Price", 'String'>
    readonly taxes: FieldRef<"Price", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Price findUnique
   */
  export type PriceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findUniqueOrThrow
   */
  export type PriceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price findFirst
   */
  export type PriceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price findFirstOrThrow
   */
  export type PriceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Price to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prices.
     */
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price findMany
   */
  export type PriceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter, which Prices to fetch.
     */
    where?: PriceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prices to fetch.
     */
    orderBy?: PriceOrderByWithRelationInput | PriceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prices.
     */
    cursor?: PriceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prices.
     */
    skip?: number
    distinct?: PriceScalarFieldEnum | PriceScalarFieldEnum[]
  }

  /**
   * Price create
   */
  export type PriceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to create a Price.
     */
    data: XOR<PriceCreateInput, PriceUncheckedCreateInput>
  }

  /**
   * Price createMany
   */
  export type PriceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prices.
     */
    data: PriceCreateManyInput | PriceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Price update
   */
  export type PriceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The data needed to update a Price.
     */
    data: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
    /**
     * Choose, which Price to update.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price updateMany
   */
  export type PriceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prices.
     */
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyInput>
    /**
     * Filter which Prices to update
     */
    where?: PriceWhereInput
  }

  /**
   * Price upsert
   */
  export type PriceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * The filter to search for the Price to update in case it exists.
     */
    where: PriceWhereUniqueInput
    /**
     * In case the Price found by the `where` argument doesn't exist, create a new Price with this data.
     */
    create: XOR<PriceCreateInput, PriceUncheckedCreateInput>
    /**
     * In case the Price was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceUpdateInput, PriceUncheckedUpdateInput>
  }

  /**
   * Price delete
   */
  export type PriceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
    /**
     * Filter which Price to delete.
     */
    where: PriceWhereUniqueInput
  }

  /**
   * Price deleteMany
   */
  export type PriceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prices to delete
     */
    where?: PriceWhereInput
  }

  /**
   * Price.roles
   */
  export type Price$rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserRole
     */
    select?: UserRoleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserRoleInclude<ExtArgs> | null
    where?: UserRoleWhereInput
    orderBy?: UserRoleOrderByWithRelationInput | UserRoleOrderByWithRelationInput[]
    cursor?: UserRoleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserRoleScalarFieldEnum | UserRoleScalarFieldEnum[]
  }

  /**
   * Price.areas
   */
  export type Price$areasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Area
     */
    select?: AreaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreaInclude<ExtArgs> | null
    where?: AreaWhereInput
    orderBy?: AreaOrderByWithRelationInput | AreaOrderByWithRelationInput[]
    cursor?: AreaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AreaScalarFieldEnum | AreaScalarFieldEnum[]
  }

  /**
   * Price without action
   */
  export type PriceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Price
     */
    select?: PriceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    value: number | null
  }

  export type TransactionSumAggregateOutputType = {
    value: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    value: number | null
    currency: string | null
    reason: $Enums.TransactionReason | null
    paymentInformation: string | null
    reservationId: string | null
    abonnementId: string | null
    createdAt: Date | null
    deleted: boolean | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    value: number | null
    currency: string | null
    reason: $Enums.TransactionReason | null
    paymentInformation: string | null
    reservationId: string | null
    abonnementId: string | null
    createdAt: Date | null
    deleted: boolean | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    userId: number
    value: number
    currency: number
    reason: number
    paymentInformation: number
    reservationId: number
    abonnementId: number
    createdAt: number
    deleted: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    value?: true
  }

  export type TransactionSumAggregateInputType = {
    value?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    currency?: true
    reason?: true
    paymentInformation?: true
    reservationId?: true
    abonnementId?: true
    createdAt?: true
    deleted?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    currency?: true
    reason?: true
    paymentInformation?: true
    reservationId?: true
    abonnementId?: true
    createdAt?: true
    deleted?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    userId?: true
    value?: true
    currency?: true
    reason?: true
    paymentInformation?: true
    reservationId?: true
    abonnementId?: true
    createdAt?: true
    deleted?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    userId: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation: string | null
    reservationId: string | null
    abonnementId: string | null
    createdAt: Date
    deleted: boolean
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    value?: boolean
    currency?: boolean
    reason?: boolean
    paymentInformation?: boolean
    reservationId?: boolean
    abonnementId?: boolean
    createdAt?: boolean
    deleted?: boolean
    user?: boolean | Transaction$userArgs<ExtArgs>
    hallencard?: boolean | Transaction$hallencardArgs<ExtArgs>
    reservation?: boolean | Transaction$reservationArgs<ExtArgs>
    abonnement?: boolean | Transaction$abonnementArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>


  export type TransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    value?: boolean
    currency?: boolean
    reason?: boolean
    paymentInformation?: boolean
    reservationId?: boolean
    abonnementId?: boolean
    createdAt?: boolean
    deleted?: boolean
  }

  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Transaction$userArgs<ExtArgs>
    hallencard?: boolean | Transaction$hallencardArgs<ExtArgs>
    reservation?: boolean | Transaction$reservationArgs<ExtArgs>
    abonnement?: boolean | Transaction$abonnementArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      hallencard: Prisma.$HallencardPayload<ExtArgs> | null
      reservation: Prisma.$ReservationPayload<ExtArgs> | null
      abonnement: Prisma.$AbonnementPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      value: number
      currency: string
      reason: $Enums.TransactionReason
      paymentInformation: string | null
      reservationId: string | null
      abonnementId: string | null
      createdAt: Date
      deleted: boolean
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Transaction$userArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    hallencard<T extends Transaction$hallencardArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$hallencardArgs<ExtArgs>>): Prisma__HallencardClient<$Result.GetResult<Prisma.$HallencardPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reservation<T extends Transaction$reservationArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$reservationArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    abonnement<T extends Transaction$abonnementArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$abonnementArgs<ExtArgs>>): Prisma__AbonnementClient<$Result.GetResult<Prisma.$AbonnementPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */ 
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly userId: FieldRef<"Transaction", 'String'>
    readonly value: FieldRef<"Transaction", 'Float'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly reason: FieldRef<"Transaction", 'TransactionReason'>
    readonly paymentInformation: FieldRef<"Transaction", 'String'>
    readonly reservationId: FieldRef<"Transaction", 'String'>
    readonly abonnementId: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly deleted: FieldRef<"Transaction", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
  }

  /**
   * Transaction.user
   */
  export type Transaction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.hallencard
   */
  export type Transaction$hallencardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hallencard
     */
    select?: HallencardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HallencardInclude<ExtArgs> | null
    where?: HallencardWhereInput
  }

  /**
   * Transaction.reservation
   */
  export type Transaction$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
  }

  /**
   * Transaction.abonnement
   */
  export type Transaction$abonnementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Abonnement
     */
    select?: AbonnementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AbonnementInclude<ExtArgs> | null
    where?: AbonnementWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model Season
   */

  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    id: number | null
  }

  export type SeasonSumAggregateOutputType = {
    id: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    starting: Date | null
    ending: Date | null
    current: boolean | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    starting: Date | null
    ending: Date | null
    current: boolean | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    starting: number
    ending: number
    current: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    id?: true
  }

  export type SeasonSumAggregateInputType = {
    id?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    starting?: true
    ending?: true
    current?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    starting?: true
    ending?: true
    current?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    starting?: true
    ending?: true
    current?: true
    _all?: true
  }

  export type SeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Season to aggregate.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeasonWhereInput
    orderBy?: SeasonOrderByWithAggregationInput | SeasonOrderByWithAggregationInput[]
    by: SeasonScalarFieldEnum[] | SeasonScalarFieldEnum
    having?: SeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }

  export type SeasonGroupByOutputType = {
    id: number
    name: string
    shortName: string
    starting: Date
    ending: Date
    current: boolean
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type SeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    starting?: boolean
    ending?: boolean
    current?: boolean
    teams?: boolean | Season$teamsArgs<ExtArgs>
    players?: boolean | Season$playersArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["season"]>


  export type SeasonSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    starting?: boolean
    ending?: boolean
    current?: boolean
  }

  export type SeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teams?: boolean | Season$teamsArgs<ExtArgs>
    players?: boolean | Season$playersArgs<ExtArgs>
    _count?: boolean | SeasonCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Season"
    objects: {
      teams: Prisma.$TeamSeasonPayload<ExtArgs>[]
      players: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      shortName: string
      starting: Date
      ending: Date
      current: boolean
    }, ExtArgs["result"]["season"]>
    composites: {}
  }

  type SeasonGetPayload<S extends boolean | null | undefined | SeasonDefaultArgs> = $Result.GetResult<Prisma.$SeasonPayload, S>

  type SeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SeasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface SeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Season'], meta: { name: 'Season' } }
    /**
     * Find zero or one Season that matches the filter.
     * @param {SeasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeasonFindUniqueArgs>(args: SelectSubset<T, SeasonFindUniqueArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Season that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SeasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, SeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeasonFindFirstArgs>(args?: SelectSubset<T, SeasonFindFirstArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Season that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, SeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeasonFindManyArgs>(args?: SelectSubset<T, SeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Season.
     * @param {SeasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
     */
    create<T extends SeasonCreateArgs>(args: SelectSubset<T, SeasonCreateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Seasons.
     * @param {SeasonCreateManyArgs} args - Arguments to create many Seasons.
     * @example
     * // Create many Seasons
     * const season = await prisma.season.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeasonCreateManyArgs>(args?: SelectSubset<T, SeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Season.
     * @param {SeasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
     */
    delete<T extends SeasonDeleteArgs>(args: SelectSubset<T, SeasonDeleteArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Season.
     * @param {SeasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeasonUpdateArgs>(args: SelectSubset<T, SeasonUpdateArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Seasons.
     * @param {SeasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeasonDeleteManyArgs>(args?: SelectSubset<T, SeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeasonUpdateManyArgs>(args: SelectSubset<T, SeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season.
     * @param {SeasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
     */
    upsert<T extends SeasonUpsertArgs>(args: SelectSubset<T, SeasonUpsertArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends SeasonCountArgs>(
      args?: Subset<T, SeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Season model
   */
  readonly fields: SeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teams<T extends Season$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Season$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findMany"> | Null>
    players<T extends Season$playersArgs<ExtArgs> = {}>(args?: Subset<T, Season$playersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Season model
   */ 
  interface SeasonFieldRefs {
    readonly id: FieldRef<"Season", 'Int'>
    readonly name: FieldRef<"Season", 'String'>
    readonly shortName: FieldRef<"Season", 'String'>
    readonly starting: FieldRef<"Season", 'DateTime'>
    readonly ending: FieldRef<"Season", 'DateTime'>
    readonly current: FieldRef<"Season", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Season findUnique
   */
  export type SeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findUniqueOrThrow
   */
  export type SeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season findFirst
   */
  export type SeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findFirstOrThrow
   */
  export type SeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Season to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Seasons.
     */
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season findMany
   */
  export type SeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter, which Seasons to fetch.
     */
    where?: SeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Seasons to fetch.
     */
    orderBy?: SeasonOrderByWithRelationInput | SeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Seasons.
     */
    cursor?: SeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Seasons.
     */
    skip?: number
    distinct?: SeasonScalarFieldEnum | SeasonScalarFieldEnum[]
  }

  /**
   * Season create
   */
  export type SeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a Season.
     */
    data: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
  }

  /**
   * Season createMany
   */
  export type SeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Seasons.
     */
    data: SeasonCreateManyInput | SeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Season update
   */
  export type SeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a Season.
     */
    data: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
    /**
     * Choose, which Season to update.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season updateMany
   */
  export type SeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Seasons.
     */
    data: XOR<SeasonUpdateManyMutationInput, SeasonUncheckedUpdateManyInput>
    /**
     * Filter which Seasons to update
     */
    where?: SeasonWhereInput
  }

  /**
   * Season upsert
   */
  export type SeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the Season to update in case it exists.
     */
    where: SeasonWhereUniqueInput
    /**
     * In case the Season found by the `where` argument doesn't exist, create a new Season with this data.
     */
    create: XOR<SeasonCreateInput, SeasonUncheckedCreateInput>
    /**
     * In case the Season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeasonUpdateInput, SeasonUncheckedUpdateInput>
  }

  /**
   * Season delete
   */
  export type SeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
    /**
     * Filter which Season to delete.
     */
    where: SeasonWhereUniqueInput
  }

  /**
   * Season deleteMany
   */
  export type SeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seasons to delete
     */
    where?: SeasonWhereInput
  }

  /**
   * Season.teams
   */
  export type Season$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    where?: TeamSeasonWhereInput
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    cursor?: TeamSeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * Season.players
   */
  export type Season$playersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Season without action
   */
  export type SeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Season
     */
    select?: SeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeasonInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamAvgAggregateOutputType = {
    id: number | null
    orderNumber: number | null
  }

  export type TeamSumAggregateOutputType = {
    id: number | null
    orderNumber: number | null
  }

  export type TeamMinAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    category: $Enums.TeamCategory | null
    orderNumber: number | null
  }

  export type TeamMaxAggregateOutputType = {
    id: number | null
    name: string | null
    shortName: string | null
    category: $Enums.TeamCategory | null
    orderNumber: number | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    shortName: number
    category: number
    orderNumber: number
    _all: number
  }


  export type TeamAvgAggregateInputType = {
    id?: true
    orderNumber?: true
  }

  export type TeamSumAggregateInputType = {
    id?: true
    orderNumber?: true
  }

  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    category?: true
    orderNumber?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    category?: true
    orderNumber?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    shortName?: true
    category?: true
    orderNumber?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _avg?: TeamAvgAggregateInputType
    _sum?: TeamSumAggregateInputType
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: number
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    _count: TeamCountAggregateOutputType | null
    _avg: TeamAvgAggregateOutputType | null
    _sum: TeamSumAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    shortName?: boolean
    category?: boolean
    orderNumber?: boolean
    teamSeasons?: boolean | Team$teamSeasonsArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>


  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
    shortName?: boolean
    category?: boolean
    orderNumber?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teamSeasons?: boolean | Team$teamSeasonsArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      teamSeasons: Prisma.$TeamSeasonPayload<ExtArgs>[]
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      shortName: string
      category: $Enums.TeamCategory
      orderNumber: number
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teamSeasons<T extends Team$teamSeasonsArgs<ExtArgs> = {}>(args?: Subset<T, Team$teamSeasonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findMany"> | Null>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'Int'>
    readonly name: FieldRef<"Team", 'String'>
    readonly shortName: FieldRef<"Team", 'String'>
    readonly category: FieldRef<"Team", 'TeamCategory'>
    readonly orderNumber: FieldRef<"Team", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.teamSeasons
   */
  export type Team$teamSeasonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    where?: TeamSeasonWhereInput
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    cursor?: TeamSeasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamSeason
   */

  export type AggregateTeamSeason = {
    _count: TeamSeasonCountAggregateOutputType | null
    _avg: TeamSeasonAvgAggregateOutputType | null
    _sum: TeamSeasonSumAggregateOutputType | null
    _min: TeamSeasonMinAggregateOutputType | null
    _max: TeamSeasonMaxAggregateOutputType | null
  }

  export type TeamSeasonAvgAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
  }

  export type TeamSeasonSumAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
  }

  export type TeamSeasonMinAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
    teamLeaderId: string | null
    nuGroupId: string | null
    nuTeamId: string | null
    leagueName: string | null
  }

  export type TeamSeasonMaxAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
    teamLeaderId: string | null
    nuGroupId: string | null
    nuTeamId: string | null
    leagueName: string | null
  }

  export type TeamSeasonCountAggregateOutputType = {
    teamId: number
    seasonId: number
    teamLeaderId: number
    nuGroupId: number
    nuTeamId: number
    leagueName: number
    _all: number
  }


  export type TeamSeasonAvgAggregateInputType = {
    teamId?: true
    seasonId?: true
  }

  export type TeamSeasonSumAggregateInputType = {
    teamId?: true
    seasonId?: true
  }

  export type TeamSeasonMinAggregateInputType = {
    teamId?: true
    seasonId?: true
    teamLeaderId?: true
    nuGroupId?: true
    nuTeamId?: true
    leagueName?: true
  }

  export type TeamSeasonMaxAggregateInputType = {
    teamId?: true
    seasonId?: true
    teamLeaderId?: true
    nuGroupId?: true
    nuTeamId?: true
    leagueName?: true
  }

  export type TeamSeasonCountAggregateInputType = {
    teamId?: true
    seasonId?: true
    teamLeaderId?: true
    nuGroupId?: true
    nuTeamId?: true
    leagueName?: true
    _all?: true
  }

  export type TeamSeasonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamSeason to aggregate.
     */
    where?: TeamSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamSeasons to fetch.
     */
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamSeasons
    **/
    _count?: true | TeamSeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamSeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamSeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamSeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamSeasonMaxAggregateInputType
  }

  export type GetTeamSeasonAggregateType<T extends TeamSeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamSeason[P]>
      : GetScalarType<T[P], AggregateTeamSeason[P]>
  }




  export type TeamSeasonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamSeasonWhereInput
    orderBy?: TeamSeasonOrderByWithAggregationInput | TeamSeasonOrderByWithAggregationInput[]
    by: TeamSeasonScalarFieldEnum[] | TeamSeasonScalarFieldEnum
    having?: TeamSeasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamSeasonCountAggregateInputType | true
    _avg?: TeamSeasonAvgAggregateInputType
    _sum?: TeamSeasonSumAggregateInputType
    _min?: TeamSeasonMinAggregateInputType
    _max?: TeamSeasonMaxAggregateInputType
  }

  export type TeamSeasonGroupByOutputType = {
    teamId: number
    seasonId: number
    teamLeaderId: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
    _count: TeamSeasonCountAggregateOutputType | null
    _avg: TeamSeasonAvgAggregateOutputType | null
    _sum: TeamSeasonSumAggregateOutputType | null
    _min: TeamSeasonMinAggregateOutputType | null
    _max: TeamSeasonMaxAggregateOutputType | null
  }

  type GetTeamSeasonGroupByPayload<T extends TeamSeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamSeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamSeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamSeasonGroupByOutputType[P]>
            : GetScalarType<T[P], TeamSeasonGroupByOutputType[P]>
        }
      >
    >


  export type TeamSeasonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    teamId?: boolean
    seasonId?: boolean
    teamLeaderId?: boolean
    nuGroupId?: boolean
    nuTeamId?: boolean
    leagueName?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    teamLeader?: boolean | TeamSeason$teamLeaderArgs<ExtArgs>
  }, ExtArgs["result"]["teamSeason"]>


  export type TeamSeasonSelectScalar = {
    teamId?: boolean
    seasonId?: boolean
    teamLeaderId?: boolean
    nuGroupId?: boolean
    nuTeamId?: boolean
    leagueName?: boolean
  }

  export type TeamSeasonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
    teamLeader?: boolean | TeamSeason$teamLeaderArgs<ExtArgs>
  }

  export type $TeamSeasonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamSeason"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs>
      teamLeader: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      teamId: number
      seasonId: number
      teamLeaderId: string | null
      nuGroupId: string
      nuTeamId: string
      leagueName: string
    }, ExtArgs["result"]["teamSeason"]>
    composites: {}
  }

  type TeamSeasonGetPayload<S extends boolean | null | undefined | TeamSeasonDefaultArgs> = $Result.GetResult<Prisma.$TeamSeasonPayload, S>

  type TeamSeasonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamSeasonFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamSeasonCountAggregateInputType | true
    }

  export interface TeamSeasonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamSeason'], meta: { name: 'TeamSeason' } }
    /**
     * Find zero or one TeamSeason that matches the filter.
     * @param {TeamSeasonFindUniqueArgs} args - Arguments to find a TeamSeason
     * @example
     * // Get one TeamSeason
     * const teamSeason = await prisma.teamSeason.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamSeasonFindUniqueArgs>(args: SelectSubset<T, TeamSeasonFindUniqueArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamSeason that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamSeasonFindUniqueOrThrowArgs} args - Arguments to find a TeamSeason
     * @example
     * // Get one TeamSeason
     * const teamSeason = await prisma.teamSeason.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamSeasonFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamSeasonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamSeason that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonFindFirstArgs} args - Arguments to find a TeamSeason
     * @example
     * // Get one TeamSeason
     * const teamSeason = await prisma.teamSeason.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamSeasonFindFirstArgs>(args?: SelectSubset<T, TeamSeasonFindFirstArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamSeason that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonFindFirstOrThrowArgs} args - Arguments to find a TeamSeason
     * @example
     * // Get one TeamSeason
     * const teamSeason = await prisma.teamSeason.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamSeasonFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamSeasonFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamSeasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamSeasons
     * const teamSeasons = await prisma.teamSeason.findMany()
     * 
     * // Get first 10 TeamSeasons
     * const teamSeasons = await prisma.teamSeason.findMany({ take: 10 })
     * 
     * // Only select the `teamId`
     * const teamSeasonWithTeamIdOnly = await prisma.teamSeason.findMany({ select: { teamId: true } })
     * 
     */
    findMany<T extends TeamSeasonFindManyArgs>(args?: SelectSubset<T, TeamSeasonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamSeason.
     * @param {TeamSeasonCreateArgs} args - Arguments to create a TeamSeason.
     * @example
     * // Create one TeamSeason
     * const TeamSeason = await prisma.teamSeason.create({
     *   data: {
     *     // ... data to create a TeamSeason
     *   }
     * })
     * 
     */
    create<T extends TeamSeasonCreateArgs>(args: SelectSubset<T, TeamSeasonCreateArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamSeasons.
     * @param {TeamSeasonCreateManyArgs} args - Arguments to create many TeamSeasons.
     * @example
     * // Create many TeamSeasons
     * const teamSeason = await prisma.teamSeason.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamSeasonCreateManyArgs>(args?: SelectSubset<T, TeamSeasonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamSeason.
     * @param {TeamSeasonDeleteArgs} args - Arguments to delete one TeamSeason.
     * @example
     * // Delete one TeamSeason
     * const TeamSeason = await prisma.teamSeason.delete({
     *   where: {
     *     // ... filter to delete one TeamSeason
     *   }
     * })
     * 
     */
    delete<T extends TeamSeasonDeleteArgs>(args: SelectSubset<T, TeamSeasonDeleteArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamSeason.
     * @param {TeamSeasonUpdateArgs} args - Arguments to update one TeamSeason.
     * @example
     * // Update one TeamSeason
     * const teamSeason = await prisma.teamSeason.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamSeasonUpdateArgs>(args: SelectSubset<T, TeamSeasonUpdateArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamSeasons.
     * @param {TeamSeasonDeleteManyArgs} args - Arguments to filter TeamSeasons to delete.
     * @example
     * // Delete a few TeamSeasons
     * const { count } = await prisma.teamSeason.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamSeasonDeleteManyArgs>(args?: SelectSubset<T, TeamSeasonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamSeasons
     * const teamSeason = await prisma.teamSeason.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamSeasonUpdateManyArgs>(args: SelectSubset<T, TeamSeasonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamSeason.
     * @param {TeamSeasonUpsertArgs} args - Arguments to update or create a TeamSeason.
     * @example
     * // Update or create a TeamSeason
     * const teamSeason = await prisma.teamSeason.upsert({
     *   create: {
     *     // ... data to create a TeamSeason
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamSeason we want to update
     *   }
     * })
     */
    upsert<T extends TeamSeasonUpsertArgs>(args: SelectSubset<T, TeamSeasonUpsertArgs<ExtArgs>>): Prisma__TeamSeasonClient<$Result.GetResult<Prisma.$TeamSeasonPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamSeasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonCountArgs} args - Arguments to filter TeamSeasons to count.
     * @example
     * // Count the number of TeamSeasons
     * const count = await prisma.teamSeason.count({
     *   where: {
     *     // ... the filter for the TeamSeasons we want to count
     *   }
     * })
    **/
    count<T extends TeamSeasonCountArgs>(
      args?: Subset<T, TeamSeasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamSeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamSeasonAggregateArgs>(args: Subset<T, TeamSeasonAggregateArgs>): Prisma.PrismaPromise<GetTeamSeasonAggregateType<T>>

    /**
     * Group by TeamSeason.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamSeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamSeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamSeasonGroupByArgs['orderBy'] }
        : { orderBy?: TeamSeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamSeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamSeason model
   */
  readonly fields: TeamSeasonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamSeason.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamSeasonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    teamLeader<T extends TeamSeason$teamLeaderArgs<ExtArgs> = {}>(args?: Subset<T, TeamSeason$teamLeaderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamSeason model
   */ 
  interface TeamSeasonFieldRefs {
    readonly teamId: FieldRef<"TeamSeason", 'Int'>
    readonly seasonId: FieldRef<"TeamSeason", 'Int'>
    readonly teamLeaderId: FieldRef<"TeamSeason", 'String'>
    readonly nuGroupId: FieldRef<"TeamSeason", 'String'>
    readonly nuTeamId: FieldRef<"TeamSeason", 'String'>
    readonly leagueName: FieldRef<"TeamSeason", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeamSeason findUnique
   */
  export type TeamSeasonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter, which TeamSeason to fetch.
     */
    where: TeamSeasonWhereUniqueInput
  }

  /**
   * TeamSeason findUniqueOrThrow
   */
  export type TeamSeasonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter, which TeamSeason to fetch.
     */
    where: TeamSeasonWhereUniqueInput
  }

  /**
   * TeamSeason findFirst
   */
  export type TeamSeasonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter, which TeamSeason to fetch.
     */
    where?: TeamSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamSeasons to fetch.
     */
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamSeasons.
     */
    cursor?: TeamSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamSeasons.
     */
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * TeamSeason findFirstOrThrow
   */
  export type TeamSeasonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter, which TeamSeason to fetch.
     */
    where?: TeamSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamSeasons to fetch.
     */
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamSeasons.
     */
    cursor?: TeamSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamSeasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamSeasons.
     */
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * TeamSeason findMany
   */
  export type TeamSeasonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter, which TeamSeasons to fetch.
     */
    where?: TeamSeasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamSeasons to fetch.
     */
    orderBy?: TeamSeasonOrderByWithRelationInput | TeamSeasonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamSeasons.
     */
    cursor?: TeamSeasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamSeasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamSeasons.
     */
    skip?: number
    distinct?: TeamSeasonScalarFieldEnum | TeamSeasonScalarFieldEnum[]
  }

  /**
   * TeamSeason create
   */
  export type TeamSeasonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamSeason.
     */
    data: XOR<TeamSeasonCreateInput, TeamSeasonUncheckedCreateInput>
  }

  /**
   * TeamSeason createMany
   */
  export type TeamSeasonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamSeasons.
     */
    data: TeamSeasonCreateManyInput | TeamSeasonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamSeason update
   */
  export type TeamSeasonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamSeason.
     */
    data: XOR<TeamSeasonUpdateInput, TeamSeasonUncheckedUpdateInput>
    /**
     * Choose, which TeamSeason to update.
     */
    where: TeamSeasonWhereUniqueInput
  }

  /**
   * TeamSeason updateMany
   */
  export type TeamSeasonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamSeasons.
     */
    data: XOR<TeamSeasonUpdateManyMutationInput, TeamSeasonUncheckedUpdateManyInput>
    /**
     * Filter which TeamSeasons to update
     */
    where?: TeamSeasonWhereInput
  }

  /**
   * TeamSeason upsert
   */
  export type TeamSeasonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamSeason to update in case it exists.
     */
    where: TeamSeasonWhereUniqueInput
    /**
     * In case the TeamSeason found by the `where` argument doesn't exist, create a new TeamSeason with this data.
     */
    create: XOR<TeamSeasonCreateInput, TeamSeasonUncheckedCreateInput>
    /**
     * In case the TeamSeason was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamSeasonUpdateInput, TeamSeasonUncheckedUpdateInput>
  }

  /**
   * TeamSeason delete
   */
  export type TeamSeasonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
    /**
     * Filter which TeamSeason to delete.
     */
    where: TeamSeasonWhereUniqueInput
  }

  /**
   * TeamSeason deleteMany
   */
  export type TeamSeasonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamSeasons to delete
     */
    where?: TeamSeasonWhereInput
  }

  /**
   * TeamSeason.teamLeader
   */
  export type TeamSeason$teamLeaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TeamSeason without action
   */
  export type TeamSeasonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamSeason
     */
    select?: TeamSeasonSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamSeasonInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberAvgAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
  }

  export type TeamMemberSumAggregateOutputType = {
    teamId: number | null
    seasonId: number | null
  }

  export type TeamMemberMinAggregateOutputType = {
    userId: string | null
    teamId: number | null
    seasonId: number | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    userId: string | null
    teamId: number | null
    seasonId: number | null
  }

  export type TeamMemberCountAggregateOutputType = {
    userId: number
    teamId: number
    seasonId: number
    _all: number
  }


  export type TeamMemberAvgAggregateInputType = {
    teamId?: true
    seasonId?: true
  }

  export type TeamMemberSumAggregateInputType = {
    teamId?: true
    seasonId?: true
  }

  export type TeamMemberMinAggregateInputType = {
    userId?: true
    teamId?: true
    seasonId?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    userId?: true
    teamId?: true
    seasonId?: true
  }

  export type TeamMemberCountAggregateInputType = {
    userId?: true
    teamId?: true
    seasonId?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TeamMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TeamMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _avg?: TeamMemberAvgAggregateInputType
    _sum?: TeamMemberSumAggregateInputType
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    userId: string
    teamId: number
    seasonId: number
    _count: TeamMemberCountAggregateOutputType | null
    _avg: TeamMemberAvgAggregateOutputType | null
    _sum: TeamMemberSumAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    userId?: boolean
    teamId?: boolean
    seasonId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>


  export type TeamMemberSelectScalar = {
    userId?: boolean
    teamId?: boolean
    seasonId?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | TeamDefaultArgs<ExtArgs>
    season?: boolean | SeasonDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs>
      season: Prisma.$SeasonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      userId: string
      teamId: number
      seasonId: number
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `userId`
     * const teamMemberWithUserIdOnly = await prisma.teamMember.findMany({ select: { userId: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    season<T extends SeasonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SeasonDefaultArgs<ExtArgs>>): Prisma__SeasonClient<$Result.GetResult<Prisma.$SeasonPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'Int'>
    readonly seasonId: FieldRef<"TeamMember", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    severity: $Enums.NotificationSeverity | null
    showFrom: Date | null
    showTo: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    message: string | null
    severity: $Enums.NotificationSeverity | null
    showFrom: Date | null
    showTo: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    message: number
    severity: number
    showFrom: number
    showTo: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    message?: true
    severity?: true
    showFrom?: true
    showTo?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    message?: true
    severity?: true
    showFrom?: true
    showTo?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    message?: true
    severity?: true
    showFrom?: true
    showTo?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    message: string | null
    severity: $Enums.NotificationSeverity
    showFrom: Date
    showTo: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    showFrom?: boolean
    showTo?: boolean
  }, ExtArgs["result"]["notification"]>


  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    message?: boolean
    severity?: boolean
    showFrom?: boolean
    showTo?: boolean
  }


  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      message: string | null
      severity: $Enums.NotificationSeverity
      showFrom: Date
      showTo: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly severity: FieldRef<"Notification", 'NotificationSeverity'>
    readonly showFrom: FieldRef<"Notification", 'DateTime'>
    readonly showTo: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
  }


  /**
   * Model Benefit
   */

  export type AggregateBenefit = {
    _count: BenefitCountAggregateOutputType | null
    _min: BenefitMinAggregateOutputType | null
    _max: BenefitMaxAggregateOutputType | null
  }

  export type BenefitMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    cover: boolean | null
    link: string | null
    activeFrom: Date | null
    activeTo: Date | null
  }

  export type BenefitMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    cover: boolean | null
    link: string | null
    activeFrom: Date | null
    activeTo: Date | null
  }

  export type BenefitCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    cover: number
    link: number
    activeFrom: number
    activeTo: number
    _all: number
  }


  export type BenefitMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    cover?: true
    link?: true
    activeFrom?: true
    activeTo?: true
  }

  export type BenefitMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    cover?: true
    link?: true
    activeFrom?: true
    activeTo?: true
  }

  export type BenefitCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    cover?: true
    link?: true
    activeFrom?: true
    activeTo?: true
    _all?: true
  }

  export type BenefitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benefit to aggregate.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Benefits
    **/
    _count?: true | BenefitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BenefitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BenefitMaxAggregateInputType
  }

  export type GetBenefitAggregateType<T extends BenefitAggregateArgs> = {
        [P in keyof T & keyof AggregateBenefit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBenefit[P]>
      : GetScalarType<T[P], AggregateBenefit[P]>
  }




  export type BenefitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BenefitWhereInput
    orderBy?: BenefitOrderByWithAggregationInput | BenefitOrderByWithAggregationInput[]
    by: BenefitScalarFieldEnum[] | BenefitScalarFieldEnum
    having?: BenefitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BenefitCountAggregateInputType | true
    _min?: BenefitMinAggregateInputType
    _max?: BenefitMaxAggregateInputType
  }

  export type BenefitGroupByOutputType = {
    id: string
    title: string
    description: string | null
    image: string | null
    cover: boolean
    link: string | null
    activeFrom: Date | null
    activeTo: Date | null
    _count: BenefitCountAggregateOutputType | null
    _min: BenefitMinAggregateOutputType | null
    _max: BenefitMaxAggregateOutputType | null
  }

  type GetBenefitGroupByPayload<T extends BenefitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BenefitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BenefitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BenefitGroupByOutputType[P]>
            : GetScalarType<T[P], BenefitGroupByOutputType[P]>
        }
      >
    >


  export type BenefitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    cover?: boolean
    link?: boolean
    activeFrom?: boolean
    activeTo?: boolean
  }, ExtArgs["result"]["benefit"]>


  export type BenefitSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    cover?: boolean
    link?: boolean
    activeFrom?: boolean
    activeTo?: boolean
  }


  export type $BenefitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Benefit"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      image: string | null
      cover: boolean
      link: string | null
      activeFrom: Date | null
      activeTo: Date | null
    }, ExtArgs["result"]["benefit"]>
    composites: {}
  }

  type BenefitGetPayload<S extends boolean | null | undefined | BenefitDefaultArgs> = $Result.GetResult<Prisma.$BenefitPayload, S>

  type BenefitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BenefitFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BenefitCountAggregateInputType | true
    }

  export interface BenefitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Benefit'], meta: { name: 'Benefit' } }
    /**
     * Find zero or one Benefit that matches the filter.
     * @param {BenefitFindUniqueArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BenefitFindUniqueArgs>(args: SelectSubset<T, BenefitFindUniqueArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Benefit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BenefitFindUniqueOrThrowArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BenefitFindUniqueOrThrowArgs>(args: SelectSubset<T, BenefitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Benefit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindFirstArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BenefitFindFirstArgs>(args?: SelectSubset<T, BenefitFindFirstArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Benefit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindFirstOrThrowArgs} args - Arguments to find a Benefit
     * @example
     * // Get one Benefit
     * const benefit = await prisma.benefit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BenefitFindFirstOrThrowArgs>(args?: SelectSubset<T, BenefitFindFirstOrThrowArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Benefits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Benefits
     * const benefits = await prisma.benefit.findMany()
     * 
     * // Get first 10 Benefits
     * const benefits = await prisma.benefit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const benefitWithIdOnly = await prisma.benefit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BenefitFindManyArgs>(args?: SelectSubset<T, BenefitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Benefit.
     * @param {BenefitCreateArgs} args - Arguments to create a Benefit.
     * @example
     * // Create one Benefit
     * const Benefit = await prisma.benefit.create({
     *   data: {
     *     // ... data to create a Benefit
     *   }
     * })
     * 
     */
    create<T extends BenefitCreateArgs>(args: SelectSubset<T, BenefitCreateArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Benefits.
     * @param {BenefitCreateManyArgs} args - Arguments to create many Benefits.
     * @example
     * // Create many Benefits
     * const benefit = await prisma.benefit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BenefitCreateManyArgs>(args?: SelectSubset<T, BenefitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Benefit.
     * @param {BenefitDeleteArgs} args - Arguments to delete one Benefit.
     * @example
     * // Delete one Benefit
     * const Benefit = await prisma.benefit.delete({
     *   where: {
     *     // ... filter to delete one Benefit
     *   }
     * })
     * 
     */
    delete<T extends BenefitDeleteArgs>(args: SelectSubset<T, BenefitDeleteArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Benefit.
     * @param {BenefitUpdateArgs} args - Arguments to update one Benefit.
     * @example
     * // Update one Benefit
     * const benefit = await prisma.benefit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BenefitUpdateArgs>(args: SelectSubset<T, BenefitUpdateArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Benefits.
     * @param {BenefitDeleteManyArgs} args - Arguments to filter Benefits to delete.
     * @example
     * // Delete a few Benefits
     * const { count } = await prisma.benefit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BenefitDeleteManyArgs>(args?: SelectSubset<T, BenefitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Benefits
     * const benefit = await prisma.benefit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BenefitUpdateManyArgs>(args: SelectSubset<T, BenefitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Benefit.
     * @param {BenefitUpsertArgs} args - Arguments to update or create a Benefit.
     * @example
     * // Update or create a Benefit
     * const benefit = await prisma.benefit.upsert({
     *   create: {
     *     // ... data to create a Benefit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Benefit we want to update
     *   }
     * })
     */
    upsert<T extends BenefitUpsertArgs>(args: SelectSubset<T, BenefitUpsertArgs<ExtArgs>>): Prisma__BenefitClient<$Result.GetResult<Prisma.$BenefitPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Benefits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitCountArgs} args - Arguments to filter Benefits to count.
     * @example
     * // Count the number of Benefits
     * const count = await prisma.benefit.count({
     *   where: {
     *     // ... the filter for the Benefits we want to count
     *   }
     * })
    **/
    count<T extends BenefitCountArgs>(
      args?: Subset<T, BenefitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BenefitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BenefitAggregateArgs>(args: Subset<T, BenefitAggregateArgs>): Prisma.PrismaPromise<GetBenefitAggregateType<T>>

    /**
     * Group by Benefit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BenefitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BenefitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BenefitGroupByArgs['orderBy'] }
        : { orderBy?: BenefitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BenefitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBenefitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Benefit model
   */
  readonly fields: BenefitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Benefit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BenefitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Benefit model
   */ 
  interface BenefitFieldRefs {
    readonly id: FieldRef<"Benefit", 'String'>
    readonly title: FieldRef<"Benefit", 'String'>
    readonly description: FieldRef<"Benefit", 'String'>
    readonly image: FieldRef<"Benefit", 'String'>
    readonly cover: FieldRef<"Benefit", 'Boolean'>
    readonly link: FieldRef<"Benefit", 'String'>
    readonly activeFrom: FieldRef<"Benefit", 'DateTime'>
    readonly activeTo: FieldRef<"Benefit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Benefit findUnique
   */
  export type BenefitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit findUniqueOrThrow
   */
  export type BenefitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit findFirst
   */
  export type BenefitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benefits.
     */
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit findFirstOrThrow
   */
  export type BenefitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter, which Benefit to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Benefits.
     */
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit findMany
   */
  export type BenefitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter, which Benefits to fetch.
     */
    where?: BenefitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Benefits to fetch.
     */
    orderBy?: BenefitOrderByWithRelationInput | BenefitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Benefits.
     */
    cursor?: BenefitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Benefits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Benefits.
     */
    skip?: number
    distinct?: BenefitScalarFieldEnum | BenefitScalarFieldEnum[]
  }

  /**
   * Benefit create
   */
  export type BenefitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * The data needed to create a Benefit.
     */
    data: XOR<BenefitCreateInput, BenefitUncheckedCreateInput>
  }

  /**
   * Benefit createMany
   */
  export type BenefitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Benefits.
     */
    data: BenefitCreateManyInput | BenefitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Benefit update
   */
  export type BenefitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * The data needed to update a Benefit.
     */
    data: XOR<BenefitUpdateInput, BenefitUncheckedUpdateInput>
    /**
     * Choose, which Benefit to update.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit updateMany
   */
  export type BenefitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Benefits.
     */
    data: XOR<BenefitUpdateManyMutationInput, BenefitUncheckedUpdateManyInput>
    /**
     * Filter which Benefits to update
     */
    where?: BenefitWhereInput
  }

  /**
   * Benefit upsert
   */
  export type BenefitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * The filter to search for the Benefit to update in case it exists.
     */
    where: BenefitWhereUniqueInput
    /**
     * In case the Benefit found by the `where` argument doesn't exist, create a new Benefit with this data.
     */
    create: XOR<BenefitCreateInput, BenefitUncheckedCreateInput>
    /**
     * In case the Benefit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BenefitUpdateInput, BenefitUncheckedUpdateInput>
  }

  /**
   * Benefit delete
   */
  export type BenefitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
    /**
     * Filter which Benefit to delete.
     */
    where: BenefitWhereUniqueInput
  }

  /**
   * Benefit deleteMany
   */
  export type BenefitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Benefits to delete
     */
    where?: BenefitWhereInput
  }

  /**
   * Benefit without action
   */
  export type BenefitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Benefit
     */
    select?: BenefitSelect<ExtArgs> | null
  }


  /**
   * Model ControlInterface
   */

  export type AggregateControlInterface = {
    _count: ControlInterfaceCountAggregateOutputType | null
    _avg: ControlInterfaceAvgAggregateOutputType | null
    _sum: ControlInterfaceSumAggregateOutputType | null
    _min: ControlInterfaceMinAggregateOutputType | null
    _max: ControlInterfaceMaxAggregateOutputType | null
  }

  export type ControlInterfaceAvgAggregateOutputType = {
    preBooking: number | null
    postBooking: number | null
  }

  export type ControlInterfaceSumAggregateOutputType = {
    preBooking: number | null
    postBooking: number | null
  }

  export type ControlInterfaceMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    preBooking: number | null
    postBooking: number | null
    connectByAnd: boolean | null
    connectByOr: boolean | null
  }

  export type ControlInterfaceMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    preBooking: number | null
    postBooking: number | null
    connectByAnd: boolean | null
    connectByOr: boolean | null
  }

  export type ControlInterfaceCountAggregateOutputType = {
    id: number
    title: number
    description: number
    preBooking: number
    postBooking: number
    connectByAnd: number
    connectByOr: number
    _all: number
  }


  export type ControlInterfaceAvgAggregateInputType = {
    preBooking?: true
    postBooking?: true
  }

  export type ControlInterfaceSumAggregateInputType = {
    preBooking?: true
    postBooking?: true
  }

  export type ControlInterfaceMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preBooking?: true
    postBooking?: true
    connectByAnd?: true
    connectByOr?: true
  }

  export type ControlInterfaceMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preBooking?: true
    postBooking?: true
    connectByAnd?: true
    connectByOr?: true
  }

  export type ControlInterfaceCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    preBooking?: true
    postBooking?: true
    connectByAnd?: true
    connectByOr?: true
    _all?: true
  }

  export type ControlInterfaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlInterface to aggregate.
     */
    where?: ControlInterfaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlInterfaces to fetch.
     */
    orderBy?: ControlInterfaceOrderByWithRelationInput | ControlInterfaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ControlInterfaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlInterfaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlInterfaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ControlInterfaces
    **/
    _count?: true | ControlInterfaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ControlInterfaceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ControlInterfaceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ControlInterfaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ControlInterfaceMaxAggregateInputType
  }

  export type GetControlInterfaceAggregateType<T extends ControlInterfaceAggregateArgs> = {
        [P in keyof T & keyof AggregateControlInterface]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateControlInterface[P]>
      : GetScalarType<T[P], AggregateControlInterface[P]>
  }




  export type ControlInterfaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ControlInterfaceWhereInput
    orderBy?: ControlInterfaceOrderByWithAggregationInput | ControlInterfaceOrderByWithAggregationInput[]
    by: ControlInterfaceScalarFieldEnum[] | ControlInterfaceScalarFieldEnum
    having?: ControlInterfaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ControlInterfaceCountAggregateInputType | true
    _avg?: ControlInterfaceAvgAggregateInputType
    _sum?: ControlInterfaceSumAggregateInputType
    _min?: ControlInterfaceMinAggregateInputType
    _max?: ControlInterfaceMaxAggregateInputType
  }

  export type ControlInterfaceGroupByOutputType = {
    id: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd: boolean
    connectByOr: boolean
    _count: ControlInterfaceCountAggregateOutputType | null
    _avg: ControlInterfaceAvgAggregateOutputType | null
    _sum: ControlInterfaceSumAggregateOutputType | null
    _min: ControlInterfaceMinAggregateOutputType | null
    _max: ControlInterfaceMaxAggregateOutputType | null
  }

  type GetControlInterfaceGroupByPayload<T extends ControlInterfaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ControlInterfaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ControlInterfaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ControlInterfaceGroupByOutputType[P]>
            : GetScalarType<T[P], ControlInterfaceGroupByOutputType[P]>
        }
      >
    >


  export type ControlInterfaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    preBooking?: boolean
    postBooking?: boolean
    connectByAnd?: boolean
    connectByOr?: boolean
    affectedCourts?: boolean | ControlInterface$affectedCourtsArgs<ExtArgs>
    _count?: boolean | ControlInterfaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["controlInterface"]>


  export type ControlInterfaceSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    preBooking?: boolean
    postBooking?: boolean
    connectByAnd?: boolean
    connectByOr?: boolean
  }

  export type ControlInterfaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectedCourts?: boolean | ControlInterface$affectedCourtsArgs<ExtArgs>
    _count?: boolean | ControlInterfaceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ControlInterfacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ControlInterface"
    objects: {
      affectedCourts: Prisma.$CourtPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      preBooking: number
      postBooking: number
      connectByAnd: boolean
      connectByOr: boolean
    }, ExtArgs["result"]["controlInterface"]>
    composites: {}
  }

  type ControlInterfaceGetPayload<S extends boolean | null | undefined | ControlInterfaceDefaultArgs> = $Result.GetResult<Prisma.$ControlInterfacePayload, S>

  type ControlInterfaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ControlInterfaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ControlInterfaceCountAggregateInputType | true
    }

  export interface ControlInterfaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ControlInterface'], meta: { name: 'ControlInterface' } }
    /**
     * Find zero or one ControlInterface that matches the filter.
     * @param {ControlInterfaceFindUniqueArgs} args - Arguments to find a ControlInterface
     * @example
     * // Get one ControlInterface
     * const controlInterface = await prisma.controlInterface.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ControlInterfaceFindUniqueArgs>(args: SelectSubset<T, ControlInterfaceFindUniqueArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ControlInterface that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ControlInterfaceFindUniqueOrThrowArgs} args - Arguments to find a ControlInterface
     * @example
     * // Get one ControlInterface
     * const controlInterface = await prisma.controlInterface.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ControlInterfaceFindUniqueOrThrowArgs>(args: SelectSubset<T, ControlInterfaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ControlInterface that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceFindFirstArgs} args - Arguments to find a ControlInterface
     * @example
     * // Get one ControlInterface
     * const controlInterface = await prisma.controlInterface.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ControlInterfaceFindFirstArgs>(args?: SelectSubset<T, ControlInterfaceFindFirstArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ControlInterface that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceFindFirstOrThrowArgs} args - Arguments to find a ControlInterface
     * @example
     * // Get one ControlInterface
     * const controlInterface = await prisma.controlInterface.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ControlInterfaceFindFirstOrThrowArgs>(args?: SelectSubset<T, ControlInterfaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ControlInterfaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ControlInterfaces
     * const controlInterfaces = await prisma.controlInterface.findMany()
     * 
     * // Get first 10 ControlInterfaces
     * const controlInterfaces = await prisma.controlInterface.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const controlInterfaceWithIdOnly = await prisma.controlInterface.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ControlInterfaceFindManyArgs>(args?: SelectSubset<T, ControlInterfaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ControlInterface.
     * @param {ControlInterfaceCreateArgs} args - Arguments to create a ControlInterface.
     * @example
     * // Create one ControlInterface
     * const ControlInterface = await prisma.controlInterface.create({
     *   data: {
     *     // ... data to create a ControlInterface
     *   }
     * })
     * 
     */
    create<T extends ControlInterfaceCreateArgs>(args: SelectSubset<T, ControlInterfaceCreateArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ControlInterfaces.
     * @param {ControlInterfaceCreateManyArgs} args - Arguments to create many ControlInterfaces.
     * @example
     * // Create many ControlInterfaces
     * const controlInterface = await prisma.controlInterface.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ControlInterfaceCreateManyArgs>(args?: SelectSubset<T, ControlInterfaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ControlInterface.
     * @param {ControlInterfaceDeleteArgs} args - Arguments to delete one ControlInterface.
     * @example
     * // Delete one ControlInterface
     * const ControlInterface = await prisma.controlInterface.delete({
     *   where: {
     *     // ... filter to delete one ControlInterface
     *   }
     * })
     * 
     */
    delete<T extends ControlInterfaceDeleteArgs>(args: SelectSubset<T, ControlInterfaceDeleteArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ControlInterface.
     * @param {ControlInterfaceUpdateArgs} args - Arguments to update one ControlInterface.
     * @example
     * // Update one ControlInterface
     * const controlInterface = await prisma.controlInterface.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ControlInterfaceUpdateArgs>(args: SelectSubset<T, ControlInterfaceUpdateArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ControlInterfaces.
     * @param {ControlInterfaceDeleteManyArgs} args - Arguments to filter ControlInterfaces to delete.
     * @example
     * // Delete a few ControlInterfaces
     * const { count } = await prisma.controlInterface.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ControlInterfaceDeleteManyArgs>(args?: SelectSubset<T, ControlInterfaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ControlInterfaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ControlInterfaces
     * const controlInterface = await prisma.controlInterface.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ControlInterfaceUpdateManyArgs>(args: SelectSubset<T, ControlInterfaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ControlInterface.
     * @param {ControlInterfaceUpsertArgs} args - Arguments to update or create a ControlInterface.
     * @example
     * // Update or create a ControlInterface
     * const controlInterface = await prisma.controlInterface.upsert({
     *   create: {
     *     // ... data to create a ControlInterface
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ControlInterface we want to update
     *   }
     * })
     */
    upsert<T extends ControlInterfaceUpsertArgs>(args: SelectSubset<T, ControlInterfaceUpsertArgs<ExtArgs>>): Prisma__ControlInterfaceClient<$Result.GetResult<Prisma.$ControlInterfacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ControlInterfaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceCountArgs} args - Arguments to filter ControlInterfaces to count.
     * @example
     * // Count the number of ControlInterfaces
     * const count = await prisma.controlInterface.count({
     *   where: {
     *     // ... the filter for the ControlInterfaces we want to count
     *   }
     * })
    **/
    count<T extends ControlInterfaceCountArgs>(
      args?: Subset<T, ControlInterfaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ControlInterfaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ControlInterface.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ControlInterfaceAggregateArgs>(args: Subset<T, ControlInterfaceAggregateArgs>): Prisma.PrismaPromise<GetControlInterfaceAggregateType<T>>

    /**
     * Group by ControlInterface.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ControlInterfaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ControlInterfaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ControlInterfaceGroupByArgs['orderBy'] }
        : { orderBy?: ControlInterfaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ControlInterfaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetControlInterfaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ControlInterface model
   */
  readonly fields: ControlInterfaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ControlInterface.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ControlInterfaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affectedCourts<T extends ControlInterface$affectedCourtsArgs<ExtArgs> = {}>(args?: Subset<T, ControlInterface$affectedCourtsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourtPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ControlInterface model
   */ 
  interface ControlInterfaceFieldRefs {
    readonly id: FieldRef<"ControlInterface", 'String'>
    readonly title: FieldRef<"ControlInterface", 'String'>
    readonly description: FieldRef<"ControlInterface", 'String'>
    readonly preBooking: FieldRef<"ControlInterface", 'Int'>
    readonly postBooking: FieldRef<"ControlInterface", 'Int'>
    readonly connectByAnd: FieldRef<"ControlInterface", 'Boolean'>
    readonly connectByOr: FieldRef<"ControlInterface", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ControlInterface findUnique
   */
  export type ControlInterfaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter, which ControlInterface to fetch.
     */
    where: ControlInterfaceWhereUniqueInput
  }

  /**
   * ControlInterface findUniqueOrThrow
   */
  export type ControlInterfaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter, which ControlInterface to fetch.
     */
    where: ControlInterfaceWhereUniqueInput
  }

  /**
   * ControlInterface findFirst
   */
  export type ControlInterfaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter, which ControlInterface to fetch.
     */
    where?: ControlInterfaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlInterfaces to fetch.
     */
    orderBy?: ControlInterfaceOrderByWithRelationInput | ControlInterfaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlInterfaces.
     */
    cursor?: ControlInterfaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlInterfaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlInterfaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlInterfaces.
     */
    distinct?: ControlInterfaceScalarFieldEnum | ControlInterfaceScalarFieldEnum[]
  }

  /**
   * ControlInterface findFirstOrThrow
   */
  export type ControlInterfaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter, which ControlInterface to fetch.
     */
    where?: ControlInterfaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlInterfaces to fetch.
     */
    orderBy?: ControlInterfaceOrderByWithRelationInput | ControlInterfaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ControlInterfaces.
     */
    cursor?: ControlInterfaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlInterfaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlInterfaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ControlInterfaces.
     */
    distinct?: ControlInterfaceScalarFieldEnum | ControlInterfaceScalarFieldEnum[]
  }

  /**
   * ControlInterface findMany
   */
  export type ControlInterfaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter, which ControlInterfaces to fetch.
     */
    where?: ControlInterfaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ControlInterfaces to fetch.
     */
    orderBy?: ControlInterfaceOrderByWithRelationInput | ControlInterfaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ControlInterfaces.
     */
    cursor?: ControlInterfaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ControlInterfaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ControlInterfaces.
     */
    skip?: number
    distinct?: ControlInterfaceScalarFieldEnum | ControlInterfaceScalarFieldEnum[]
  }

  /**
   * ControlInterface create
   */
  export type ControlInterfaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * The data needed to create a ControlInterface.
     */
    data: XOR<ControlInterfaceCreateInput, ControlInterfaceUncheckedCreateInput>
  }

  /**
   * ControlInterface createMany
   */
  export type ControlInterfaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ControlInterfaces.
     */
    data: ControlInterfaceCreateManyInput | ControlInterfaceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ControlInterface update
   */
  export type ControlInterfaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * The data needed to update a ControlInterface.
     */
    data: XOR<ControlInterfaceUpdateInput, ControlInterfaceUncheckedUpdateInput>
    /**
     * Choose, which ControlInterface to update.
     */
    where: ControlInterfaceWhereUniqueInput
  }

  /**
   * ControlInterface updateMany
   */
  export type ControlInterfaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ControlInterfaces.
     */
    data: XOR<ControlInterfaceUpdateManyMutationInput, ControlInterfaceUncheckedUpdateManyInput>
    /**
     * Filter which ControlInterfaces to update
     */
    where?: ControlInterfaceWhereInput
  }

  /**
   * ControlInterface upsert
   */
  export type ControlInterfaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * The filter to search for the ControlInterface to update in case it exists.
     */
    where: ControlInterfaceWhereUniqueInput
    /**
     * In case the ControlInterface found by the `where` argument doesn't exist, create a new ControlInterface with this data.
     */
    create: XOR<ControlInterfaceCreateInput, ControlInterfaceUncheckedCreateInput>
    /**
     * In case the ControlInterface was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ControlInterfaceUpdateInput, ControlInterfaceUncheckedUpdateInput>
  }

  /**
   * ControlInterface delete
   */
  export type ControlInterfaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
    /**
     * Filter which ControlInterface to delete.
     */
    where: ControlInterfaceWhereUniqueInput
  }

  /**
   * ControlInterface deleteMany
   */
  export type ControlInterfaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ControlInterfaces to delete
     */
    where?: ControlInterfaceWhereInput
  }

  /**
   * ControlInterface.affectedCourts
   */
  export type ControlInterface$affectedCourtsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Court
     */
    select?: CourtSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourtInclude<ExtArgs> | null
    where?: CourtWhereInput
    orderBy?: CourtOrderByWithRelationInput | CourtOrderByWithRelationInput[]
    cursor?: CourtWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourtScalarFieldEnum | CourtScalarFieldEnum[]
  }

  /**
   * ControlInterface without action
   */
  export type ControlInterfaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ControlInterface
     */
    select?: ControlInterfaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ControlInterfaceInclude<ExtArgs> | null
  }


  /**
   * Model Organisation
   */

  export type AggregateOrganisation = {
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  export type OrganisationMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
  }

  export type OrganisationMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
  }

  export type OrganisationCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    _all: number
  }


  export type OrganisationMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
  }

  export type OrganisationMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
  }

  export type OrganisationCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    _all?: true
  }

  export type OrganisationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisation to aggregate.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Organisations
    **/
    _count?: true | OrganisationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMaxAggregateInputType
  }

  export type GetOrganisationAggregateType<T extends OrganisationAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisation[P]>
      : GetScalarType<T[P], AggregateOrganisation[P]>
  }




  export type OrganisationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationWhereInput
    orderBy?: OrganisationOrderByWithAggregationInput | OrganisationOrderByWithAggregationInput[]
    by: OrganisationScalarFieldEnum[] | OrganisationScalarFieldEnum
    having?: OrganisationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationCountAggregateInputType | true
    _min?: OrganisationMinAggregateInputType
    _max?: OrganisationMaxAggregateInputType
  }

  export type OrganisationGroupByOutputType = {
    id: string
    slug: string
    title: string
    _count: OrganisationCountAggregateOutputType | null
    _min: OrganisationMinAggregateOutputType | null
    _max: OrganisationMaxAggregateOutputType | null
  }

  type GetOrganisationGroupByPayload<T extends OrganisationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    members?: boolean | Organisation$membersArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisation"]>


  export type OrganisationSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
  }

  export type OrganisationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | Organisation$membersArgs<ExtArgs>
    _count?: boolean | OrganisationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Organisation"
    objects: {
      members: Prisma.$OrganisationMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
    }, ExtArgs["result"]["organisation"]>
    composites: {}
  }

  type OrganisationGetPayload<S extends boolean | null | undefined | OrganisationDefaultArgs> = $Result.GetResult<Prisma.$OrganisationPayload, S>

  type OrganisationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationCountAggregateInputType | true
    }

  export interface OrganisationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Organisation'], meta: { name: 'Organisation' } }
    /**
     * Find zero or one Organisation that matches the filter.
     * @param {OrganisationFindUniqueArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationFindUniqueArgs>(args: SelectSubset<T, OrganisationFindUniqueArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Organisation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationFindUniqueOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Organisation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationFindFirstArgs>(args?: SelectSubset<T, OrganisationFindFirstArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Organisation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindFirstOrThrowArgs} args - Arguments to find a Organisation
     * @example
     * // Get one Organisation
     * const organisation = await prisma.organisation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Organisations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisations
     * const organisations = await prisma.organisation.findMany()
     * 
     * // Get first 10 Organisations
     * const organisations = await prisma.organisation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationWithIdOnly = await prisma.organisation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationFindManyArgs>(args?: SelectSubset<T, OrganisationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Organisation.
     * @param {OrganisationCreateArgs} args - Arguments to create a Organisation.
     * @example
     * // Create one Organisation
     * const Organisation = await prisma.organisation.create({
     *   data: {
     *     // ... data to create a Organisation
     *   }
     * })
     * 
     */
    create<T extends OrganisationCreateArgs>(args: SelectSubset<T, OrganisationCreateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Organisations.
     * @param {OrganisationCreateManyArgs} args - Arguments to create many Organisations.
     * @example
     * // Create many Organisations
     * const organisation = await prisma.organisation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationCreateManyArgs>(args?: SelectSubset<T, OrganisationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Organisation.
     * @param {OrganisationDeleteArgs} args - Arguments to delete one Organisation.
     * @example
     * // Delete one Organisation
     * const Organisation = await prisma.organisation.delete({
     *   where: {
     *     // ... filter to delete one Organisation
     *   }
     * })
     * 
     */
    delete<T extends OrganisationDeleteArgs>(args: SelectSubset<T, OrganisationDeleteArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Organisation.
     * @param {OrganisationUpdateArgs} args - Arguments to update one Organisation.
     * @example
     * // Update one Organisation
     * const organisation = await prisma.organisation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationUpdateArgs>(args: SelectSubset<T, OrganisationUpdateArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Organisations.
     * @param {OrganisationDeleteManyArgs} args - Arguments to filter Organisations to delete.
     * @example
     * // Delete a few Organisations
     * const { count } = await prisma.organisation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationDeleteManyArgs>(args?: SelectSubset<T, OrganisationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisations
     * const organisation = await prisma.organisation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationUpdateManyArgs>(args: SelectSubset<T, OrganisationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisation.
     * @param {OrganisationUpsertArgs} args - Arguments to update or create a Organisation.
     * @example
     * // Update or create a Organisation
     * const organisation = await prisma.organisation.upsert({
     *   create: {
     *     // ... data to create a Organisation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisation we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationUpsertArgs>(args: SelectSubset<T, OrganisationUpsertArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Organisations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationCountArgs} args - Arguments to filter Organisations to count.
     * @example
     * // Count the number of Organisations
     * const count = await prisma.organisation.count({
     *   where: {
     *     // ... the filter for the Organisations we want to count
     *   }
     * })
    **/
    count<T extends OrganisationCountArgs>(
      args?: Subset<T, OrganisationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationAggregateArgs>(args: Subset<T, OrganisationAggregateArgs>): Prisma.PrismaPromise<GetOrganisationAggregateType<T>>

    /**
     * Group by Organisation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Organisation model
   */
  readonly fields: OrganisationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Organisation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    members<T extends Organisation$membersArgs<ExtArgs> = {}>(args?: Subset<T, Organisation$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Organisation model
   */ 
  interface OrganisationFieldRefs {
    readonly id: FieldRef<"Organisation", 'String'>
    readonly slug: FieldRef<"Organisation", 'String'>
    readonly title: FieldRef<"Organisation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Organisation findUnique
   */
  export type OrganisationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findUniqueOrThrow
   */
  export type OrganisationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation findFirst
   */
  export type OrganisationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findFirstOrThrow
   */
  export type OrganisationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisation to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Organisations.
     */
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation findMany
   */
  export type OrganisationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter, which Organisations to fetch.
     */
    where?: OrganisationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Organisations to fetch.
     */
    orderBy?: OrganisationOrderByWithRelationInput | OrganisationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Organisations.
     */
    cursor?: OrganisationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Organisations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Organisations.
     */
    skip?: number
    distinct?: OrganisationScalarFieldEnum | OrganisationScalarFieldEnum[]
  }

  /**
   * Organisation create
   */
  export type OrganisationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to create a Organisation.
     */
    data: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
  }

  /**
   * Organisation createMany
   */
  export type OrganisationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Organisations.
     */
    data: OrganisationCreateManyInput | OrganisationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Organisation update
   */
  export type OrganisationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The data needed to update a Organisation.
     */
    data: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
    /**
     * Choose, which Organisation to update.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation updateMany
   */
  export type OrganisationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Organisations.
     */
    data: XOR<OrganisationUpdateManyMutationInput, OrganisationUncheckedUpdateManyInput>
    /**
     * Filter which Organisations to update
     */
    where?: OrganisationWhereInput
  }

  /**
   * Organisation upsert
   */
  export type OrganisationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * The filter to search for the Organisation to update in case it exists.
     */
    where: OrganisationWhereUniqueInput
    /**
     * In case the Organisation found by the `where` argument doesn't exist, create a new Organisation with this data.
     */
    create: XOR<OrganisationCreateInput, OrganisationUncheckedCreateInput>
    /**
     * In case the Organisation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationUpdateInput, OrganisationUncheckedUpdateInput>
  }

  /**
   * Organisation delete
   */
  export type OrganisationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
    /**
     * Filter which Organisation to delete.
     */
    where: OrganisationWhereUniqueInput
  }

  /**
   * Organisation deleteMany
   */
  export type OrganisationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Organisations to delete
     */
    where?: OrganisationWhereInput
  }

  /**
   * Organisation.members
   */
  export type Organisation$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    where?: OrganisationMemberWhereInput
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    cursor?: OrganisationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationMemberScalarFieldEnum | OrganisationMemberScalarFieldEnum[]
  }

  /**
   * Organisation without action
   */
  export type OrganisationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Organisation
     */
    select?: OrganisationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationInclude<ExtArgs> | null
  }


  /**
   * Model OrganisationMember
   */

  export type AggregateOrganisationMember = {
    _count: OrganisationMemberCountAggregateOutputType | null
    _avg: OrganisationMemberAvgAggregateOutputType | null
    _sum: OrganisationMemberSumAggregateOutputType | null
    _min: OrganisationMemberMinAggregateOutputType | null
    _max: OrganisationMemberMaxAggregateOutputType | null
  }

  export type OrganisationMemberAvgAggregateOutputType = {
    orderID: number | null
  }

  export type OrganisationMemberSumAggregateOutputType = {
    orderID: number | null
  }

  export type OrganisationMemberMinAggregateOutputType = {
    id: string | null
    fullName: string | null
    function: string | null
    image: string | null
    email: string | null
    phone: string | null
    orderID: number | null
    organisationId: string | null
    parentMemberId: string | null
  }

  export type OrganisationMemberMaxAggregateOutputType = {
    id: string | null
    fullName: string | null
    function: string | null
    image: string | null
    email: string | null
    phone: string | null
    orderID: number | null
    organisationId: string | null
    parentMemberId: string | null
  }

  export type OrganisationMemberCountAggregateOutputType = {
    id: number
    fullName: number
    function: number
    image: number
    email: number
    phone: number
    orderID: number
    organisationId: number
    parentMemberId: number
    _all: number
  }


  export type OrganisationMemberAvgAggregateInputType = {
    orderID?: true
  }

  export type OrganisationMemberSumAggregateInputType = {
    orderID?: true
  }

  export type OrganisationMemberMinAggregateInputType = {
    id?: true
    fullName?: true
    function?: true
    image?: true
    email?: true
    phone?: true
    orderID?: true
    organisationId?: true
    parentMemberId?: true
  }

  export type OrganisationMemberMaxAggregateInputType = {
    id?: true
    fullName?: true
    function?: true
    image?: true
    email?: true
    phone?: true
    orderID?: true
    organisationId?: true
    parentMemberId?: true
  }

  export type OrganisationMemberCountAggregateInputType = {
    id?: true
    fullName?: true
    function?: true
    image?: true
    email?: true
    phone?: true
    orderID?: true
    organisationId?: true
    parentMemberId?: true
    _all?: true
  }

  export type OrganisationMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationMember to aggregate.
     */
    where?: OrganisationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationMembers to fetch.
     */
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrganisationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrganisationMembers
    **/
    _count?: true | OrganisationMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganisationMemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganisationMemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganisationMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganisationMemberMaxAggregateInputType
  }

  export type GetOrganisationMemberAggregateType<T extends OrganisationMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisationMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisationMember[P]>
      : GetScalarType<T[P], AggregateOrganisationMember[P]>
  }




  export type OrganisationMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrganisationMemberWhereInput
    orderBy?: OrganisationMemberOrderByWithAggregationInput | OrganisationMemberOrderByWithAggregationInput[]
    by: OrganisationMemberScalarFieldEnum[] | OrganisationMemberScalarFieldEnum
    having?: OrganisationMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganisationMemberCountAggregateInputType | true
    _avg?: OrganisationMemberAvgAggregateInputType
    _sum?: OrganisationMemberSumAggregateInputType
    _min?: OrganisationMemberMinAggregateInputType
    _max?: OrganisationMemberMaxAggregateInputType
  }

  export type OrganisationMemberGroupByOutputType = {
    id: string
    fullName: string
    function: string | null
    image: string | null
    email: string | null
    phone: string | null
    orderID: number | null
    organisationId: string
    parentMemberId: string | null
    _count: OrganisationMemberCountAggregateOutputType | null
    _avg: OrganisationMemberAvgAggregateOutputType | null
    _sum: OrganisationMemberSumAggregateOutputType | null
    _min: OrganisationMemberMinAggregateOutputType | null
    _max: OrganisationMemberMaxAggregateOutputType | null
  }

  type GetOrganisationMemberGroupByPayload<T extends OrganisationMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrganisationMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganisationMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganisationMemberGroupByOutputType[P]>
            : GetScalarType<T[P], OrganisationMemberGroupByOutputType[P]>
        }
      >
    >


  export type OrganisationMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    function?: boolean
    image?: boolean
    email?: boolean
    phone?: boolean
    orderID?: boolean
    organisationId?: boolean
    parentMemberId?: boolean
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    parentMember?: boolean | OrganisationMember$parentMemberArgs<ExtArgs>
    childMembers?: boolean | OrganisationMember$childMembersArgs<ExtArgs>
    _count?: boolean | OrganisationMemberCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["organisationMember"]>


  export type OrganisationMemberSelectScalar = {
    id?: boolean
    fullName?: boolean
    function?: boolean
    image?: boolean
    email?: boolean
    phone?: boolean
    orderID?: boolean
    organisationId?: boolean
    parentMemberId?: boolean
  }

  export type OrganisationMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    organisation?: boolean | OrganisationDefaultArgs<ExtArgs>
    parentMember?: boolean | OrganisationMember$parentMemberArgs<ExtArgs>
    childMembers?: boolean | OrganisationMember$childMembersArgs<ExtArgs>
    _count?: boolean | OrganisationMemberCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $OrganisationMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrganisationMember"
    objects: {
      organisation: Prisma.$OrganisationPayload<ExtArgs>
      parentMember: Prisma.$OrganisationMemberPayload<ExtArgs> | null
      childMembers: Prisma.$OrganisationMemberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fullName: string
      function: string | null
      image: string | null
      email: string | null
      phone: string | null
      orderID: number | null
      organisationId: string
      parentMemberId: string | null
    }, ExtArgs["result"]["organisationMember"]>
    composites: {}
  }

  type OrganisationMemberGetPayload<S extends boolean | null | undefined | OrganisationMemberDefaultArgs> = $Result.GetResult<Prisma.$OrganisationMemberPayload, S>

  type OrganisationMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrganisationMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrganisationMemberCountAggregateInputType | true
    }

  export interface OrganisationMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrganisationMember'], meta: { name: 'OrganisationMember' } }
    /**
     * Find zero or one OrganisationMember that matches the filter.
     * @param {OrganisationMemberFindUniqueArgs} args - Arguments to find a OrganisationMember
     * @example
     * // Get one OrganisationMember
     * const organisationMember = await prisma.organisationMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrganisationMemberFindUniqueArgs>(args: SelectSubset<T, OrganisationMemberFindUniqueArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrganisationMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrganisationMemberFindUniqueOrThrowArgs} args - Arguments to find a OrganisationMember
     * @example
     * // Get one OrganisationMember
     * const organisationMember = await prisma.organisationMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrganisationMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, OrganisationMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrganisationMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberFindFirstArgs} args - Arguments to find a OrganisationMember
     * @example
     * // Get one OrganisationMember
     * const organisationMember = await prisma.organisationMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrganisationMemberFindFirstArgs>(args?: SelectSubset<T, OrganisationMemberFindFirstArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrganisationMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberFindFirstOrThrowArgs} args - Arguments to find a OrganisationMember
     * @example
     * // Get one OrganisationMember
     * const organisationMember = await prisma.organisationMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrganisationMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, OrganisationMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrganisationMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrganisationMembers
     * const organisationMembers = await prisma.organisationMember.findMany()
     * 
     * // Get first 10 OrganisationMembers
     * const organisationMembers = await prisma.organisationMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organisationMemberWithIdOnly = await prisma.organisationMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrganisationMemberFindManyArgs>(args?: SelectSubset<T, OrganisationMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrganisationMember.
     * @param {OrganisationMemberCreateArgs} args - Arguments to create a OrganisationMember.
     * @example
     * // Create one OrganisationMember
     * const OrganisationMember = await prisma.organisationMember.create({
     *   data: {
     *     // ... data to create a OrganisationMember
     *   }
     * })
     * 
     */
    create<T extends OrganisationMemberCreateArgs>(args: SelectSubset<T, OrganisationMemberCreateArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrganisationMembers.
     * @param {OrganisationMemberCreateManyArgs} args - Arguments to create many OrganisationMembers.
     * @example
     * // Create many OrganisationMembers
     * const organisationMember = await prisma.organisationMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrganisationMemberCreateManyArgs>(args?: SelectSubset<T, OrganisationMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrganisationMember.
     * @param {OrganisationMemberDeleteArgs} args - Arguments to delete one OrganisationMember.
     * @example
     * // Delete one OrganisationMember
     * const OrganisationMember = await prisma.organisationMember.delete({
     *   where: {
     *     // ... filter to delete one OrganisationMember
     *   }
     * })
     * 
     */
    delete<T extends OrganisationMemberDeleteArgs>(args: SelectSubset<T, OrganisationMemberDeleteArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrganisationMember.
     * @param {OrganisationMemberUpdateArgs} args - Arguments to update one OrganisationMember.
     * @example
     * // Update one OrganisationMember
     * const organisationMember = await prisma.organisationMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrganisationMemberUpdateArgs>(args: SelectSubset<T, OrganisationMemberUpdateArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrganisationMembers.
     * @param {OrganisationMemberDeleteManyArgs} args - Arguments to filter OrganisationMembers to delete.
     * @example
     * // Delete a few OrganisationMembers
     * const { count } = await prisma.organisationMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrganisationMemberDeleteManyArgs>(args?: SelectSubset<T, OrganisationMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrganisationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrganisationMembers
     * const organisationMember = await prisma.organisationMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrganisationMemberUpdateManyArgs>(args: SelectSubset<T, OrganisationMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrganisationMember.
     * @param {OrganisationMemberUpsertArgs} args - Arguments to update or create a OrganisationMember.
     * @example
     * // Update or create a OrganisationMember
     * const organisationMember = await prisma.organisationMember.upsert({
     *   create: {
     *     // ... data to create a OrganisationMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrganisationMember we want to update
     *   }
     * })
     */
    upsert<T extends OrganisationMemberUpsertArgs>(args: SelectSubset<T, OrganisationMemberUpsertArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrganisationMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberCountArgs} args - Arguments to filter OrganisationMembers to count.
     * @example
     * // Count the number of OrganisationMembers
     * const count = await prisma.organisationMember.count({
     *   where: {
     *     // ... the filter for the OrganisationMembers we want to count
     *   }
     * })
    **/
    count<T extends OrganisationMemberCountArgs>(
      args?: Subset<T, OrganisationMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganisationMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrganisationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganisationMemberAggregateArgs>(args: Subset<T, OrganisationMemberAggregateArgs>): Prisma.PrismaPromise<GetOrganisationMemberAggregateType<T>>

    /**
     * Group by OrganisationMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganisationMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganisationMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganisationMemberGroupByArgs['orderBy'] }
        : { orderBy?: OrganisationMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganisationMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganisationMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrganisationMember model
   */
  readonly fields: OrganisationMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrganisationMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrganisationMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    organisation<T extends OrganisationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationDefaultArgs<ExtArgs>>): Prisma__OrganisationClient<$Result.GetResult<Prisma.$OrganisationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentMember<T extends OrganisationMember$parentMemberArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationMember$parentMemberArgs<ExtArgs>>): Prisma__OrganisationMemberClient<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    childMembers<T extends OrganisationMember$childMembersArgs<ExtArgs> = {}>(args?: Subset<T, OrganisationMember$childMembersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrganisationMemberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrganisationMember model
   */ 
  interface OrganisationMemberFieldRefs {
    readonly id: FieldRef<"OrganisationMember", 'String'>
    readonly fullName: FieldRef<"OrganisationMember", 'String'>
    readonly function: FieldRef<"OrganisationMember", 'String'>
    readonly image: FieldRef<"OrganisationMember", 'String'>
    readonly email: FieldRef<"OrganisationMember", 'String'>
    readonly phone: FieldRef<"OrganisationMember", 'String'>
    readonly orderID: FieldRef<"OrganisationMember", 'Int'>
    readonly organisationId: FieldRef<"OrganisationMember", 'String'>
    readonly parentMemberId: FieldRef<"OrganisationMember", 'String'>
  }
    

  // Custom InputTypes
  /**
   * OrganisationMember findUnique
   */
  export type OrganisationMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationMember to fetch.
     */
    where: OrganisationMemberWhereUniqueInput
  }

  /**
   * OrganisationMember findUniqueOrThrow
   */
  export type OrganisationMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationMember to fetch.
     */
    where: OrganisationMemberWhereUniqueInput
  }

  /**
   * OrganisationMember findFirst
   */
  export type OrganisationMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationMember to fetch.
     */
    where?: OrganisationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationMembers to fetch.
     */
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationMembers.
     */
    cursor?: OrganisationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationMembers.
     */
    distinct?: OrganisationMemberScalarFieldEnum | OrganisationMemberScalarFieldEnum[]
  }

  /**
   * OrganisationMember findFirstOrThrow
   */
  export type OrganisationMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationMember to fetch.
     */
    where?: OrganisationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationMembers to fetch.
     */
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrganisationMembers.
     */
    cursor?: OrganisationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrganisationMembers.
     */
    distinct?: OrganisationMemberScalarFieldEnum | OrganisationMemberScalarFieldEnum[]
  }

  /**
   * OrganisationMember findMany
   */
  export type OrganisationMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter, which OrganisationMembers to fetch.
     */
    where?: OrganisationMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrganisationMembers to fetch.
     */
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrganisationMembers.
     */
    cursor?: OrganisationMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrganisationMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrganisationMembers.
     */
    skip?: number
    distinct?: OrganisationMemberScalarFieldEnum | OrganisationMemberScalarFieldEnum[]
  }

  /**
   * OrganisationMember create
   */
  export type OrganisationMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a OrganisationMember.
     */
    data: XOR<OrganisationMemberCreateInput, OrganisationMemberUncheckedCreateInput>
  }

  /**
   * OrganisationMember createMany
   */
  export type OrganisationMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrganisationMembers.
     */
    data: OrganisationMemberCreateManyInput | OrganisationMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrganisationMember update
   */
  export type OrganisationMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a OrganisationMember.
     */
    data: XOR<OrganisationMemberUpdateInput, OrganisationMemberUncheckedUpdateInput>
    /**
     * Choose, which OrganisationMember to update.
     */
    where: OrganisationMemberWhereUniqueInput
  }

  /**
   * OrganisationMember updateMany
   */
  export type OrganisationMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrganisationMembers.
     */
    data: XOR<OrganisationMemberUpdateManyMutationInput, OrganisationMemberUncheckedUpdateManyInput>
    /**
     * Filter which OrganisationMembers to update
     */
    where?: OrganisationMemberWhereInput
  }

  /**
   * OrganisationMember upsert
   */
  export type OrganisationMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the OrganisationMember to update in case it exists.
     */
    where: OrganisationMemberWhereUniqueInput
    /**
     * In case the OrganisationMember found by the `where` argument doesn't exist, create a new OrganisationMember with this data.
     */
    create: XOR<OrganisationMemberCreateInput, OrganisationMemberUncheckedCreateInput>
    /**
     * In case the OrganisationMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrganisationMemberUpdateInput, OrganisationMemberUncheckedUpdateInput>
  }

  /**
   * OrganisationMember delete
   */
  export type OrganisationMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    /**
     * Filter which OrganisationMember to delete.
     */
    where: OrganisationMemberWhereUniqueInput
  }

  /**
   * OrganisationMember deleteMany
   */
  export type OrganisationMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrganisationMembers to delete
     */
    where?: OrganisationMemberWhereInput
  }

  /**
   * OrganisationMember.parentMember
   */
  export type OrganisationMember$parentMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    where?: OrganisationMemberWhereInput
  }

  /**
   * OrganisationMember.childMembers
   */
  export type OrganisationMember$childMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
    where?: OrganisationMemberWhereInput
    orderBy?: OrganisationMemberOrderByWithRelationInput | OrganisationMemberOrderByWithRelationInput[]
    cursor?: OrganisationMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrganisationMemberScalarFieldEnum | OrganisationMemberScalarFieldEnum[]
  }

  /**
   * OrganisationMember without action
   */
  export type OrganisationMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrganisationMember
     */
    select?: OrganisationMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrganisationMemberInclude<ExtArgs> | null
  }


  /**
   * Model EventCategory
   */

  export type AggregateEventCategory = {
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  export type EventCategoryMinAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
  }

  export type EventCategoryMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    title: string | null
  }

  export type EventCategoryCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    _all: number
  }


  export type EventCategoryMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
  }

  export type EventCategoryMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
  }

  export type EventCategoryCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    _all?: true
  }

  export type EventCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategory to aggregate.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCategories
    **/
    _count?: true | EventCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCategoryMaxAggregateInputType
  }

  export type GetEventCategoryAggregateType<T extends EventCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCategory[P]>
      : GetScalarType<T[P], AggregateEventCategory[P]>
  }




  export type EventCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoryWhereInput
    orderBy?: EventCategoryOrderByWithAggregationInput | EventCategoryOrderByWithAggregationInput[]
    by: EventCategoryScalarFieldEnum[] | EventCategoryScalarFieldEnum
    having?: EventCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCategoryCountAggregateInputType | true
    _min?: EventCategoryMinAggregateInputType
    _max?: EventCategoryMaxAggregateInputType
  }

  export type EventCategoryGroupByOutputType = {
    id: string
    slug: string
    title: string
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  type GetEventCategoryGroupByPayload<T extends EventCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
        }
      >
    >


  export type EventCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    events?: boolean | EventCategory$eventsArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategory"]>


  export type EventCategorySelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
  }

  export type EventCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    events?: boolean | EventCategory$eventsArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCategory"
    objects: {
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      title: string
    }, ExtArgs["result"]["eventCategory"]>
    composites: {}
  }

  type EventCategoryGetPayload<S extends boolean | null | undefined | EventCategoryDefaultArgs> = $Result.GetResult<Prisma.$EventCategoryPayload, S>

  type EventCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCategoryCountAggregateInputType | true
    }

  export interface EventCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCategory'], meta: { name: 'EventCategory' } }
    /**
     * Find zero or one EventCategory that matches the filter.
     * @param {EventCategoryFindUniqueArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCategoryFindUniqueArgs>(args: SelectSubset<T, EventCategoryFindUniqueArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventCategoryFindUniqueOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCategoryFindFirstArgs>(args?: SelectSubset<T, EventCategoryFindFirstArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCategories
     * const eventCategories = await prisma.eventCategory.findMany()
     * 
     * // Get first 10 EventCategories
     * const eventCategories = await prisma.eventCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCategoryWithIdOnly = await prisma.eventCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCategoryFindManyArgs>(args?: SelectSubset<T, EventCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventCategory.
     * @param {EventCategoryCreateArgs} args - Arguments to create a EventCategory.
     * @example
     * // Create one EventCategory
     * const EventCategory = await prisma.eventCategory.create({
     *   data: {
     *     // ... data to create a EventCategory
     *   }
     * })
     * 
     */
    create<T extends EventCategoryCreateArgs>(args: SelectSubset<T, EventCategoryCreateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventCategories.
     * @param {EventCategoryCreateManyArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategory = await prisma.eventCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCategoryCreateManyArgs>(args?: SelectSubset<T, EventCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventCategory.
     * @param {EventCategoryDeleteArgs} args - Arguments to delete one EventCategory.
     * @example
     * // Delete one EventCategory
     * const EventCategory = await prisma.eventCategory.delete({
     *   where: {
     *     // ... filter to delete one EventCategory
     *   }
     * })
     * 
     */
    delete<T extends EventCategoryDeleteArgs>(args: SelectSubset<T, EventCategoryDeleteArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventCategory.
     * @param {EventCategoryUpdateArgs} args - Arguments to update one EventCategory.
     * @example
     * // Update one EventCategory
     * const eventCategory = await prisma.eventCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCategoryUpdateArgs>(args: SelectSubset<T, EventCategoryUpdateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventCategories.
     * @param {EventCategoryDeleteManyArgs} args - Arguments to filter EventCategories to delete.
     * @example
     * // Delete a few EventCategories
     * const { count } = await prisma.eventCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCategoryDeleteManyArgs>(args?: SelectSubset<T, EventCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCategories
     * const eventCategory = await prisma.eventCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCategoryUpdateManyArgs>(args: SelectSubset<T, EventCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventCategory.
     * @param {EventCategoryUpsertArgs} args - Arguments to update or create a EventCategory.
     * @example
     * // Update or create a EventCategory
     * const eventCategory = await prisma.eventCategory.upsert({
     *   create: {
     *     // ... data to create a EventCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCategory we want to update
     *   }
     * })
     */
    upsert<T extends EventCategoryUpsertArgs>(args: SelectSubset<T, EventCategoryUpsertArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryCountArgs} args - Arguments to filter EventCategories to count.
     * @example
     * // Count the number of EventCategories
     * const count = await prisma.eventCategory.count({
     *   where: {
     *     // ... the filter for the EventCategories we want to count
     *   }
     * })
    **/
    count<T extends EventCategoryCountArgs>(
      args?: Subset<T, EventCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCategoryAggregateArgs>(args: Subset<T, EventCategoryAggregateArgs>): Prisma.PrismaPromise<GetEventCategoryAggregateType<T>>

    /**
     * Group by EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCategoryGroupByArgs['orderBy'] }
        : { orderBy?: EventCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCategory model
   */
  readonly fields: EventCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    events<T extends EventCategory$eventsArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCategory model
   */ 
  interface EventCategoryFieldRefs {
    readonly id: FieldRef<"EventCategory", 'String'>
    readonly slug: FieldRef<"EventCategory", 'String'>
    readonly title: FieldRef<"EventCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventCategory findUnique
   */
  export type EventCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findUniqueOrThrow
   */
  export type EventCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findFirst
   */
  export type EventCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findFirstOrThrow
   */
  export type EventCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findMany
   */
  export type EventCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory create
   */
  export type EventCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCategory.
     */
    data: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
  }

  /**
   * EventCategory createMany
   */
  export type EventCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoryCreateManyInput | EventCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCategory update
   */
  export type EventCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCategory.
     */
    data: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
    /**
     * Choose, which EventCategory to update.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory updateMany
   */
  export type EventCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCategories.
     */
    data: XOR<EventCategoryUpdateManyMutationInput, EventCategoryUncheckedUpdateManyInput>
    /**
     * Filter which EventCategories to update
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory upsert
   */
  export type EventCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCategory to update in case it exists.
     */
    where: EventCategoryWhereUniqueInput
    /**
     * In case the EventCategory found by the `where` argument doesn't exist, create a new EventCategory with this data.
     */
    create: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
    /**
     * In case the EventCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
  }

  /**
   * EventCategory delete
   */
  export type EventCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter which EventCategory to delete.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory deleteMany
   */
  export type EventCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategories to delete
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory.events
   */
  export type EventCategory$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * EventCategory without action
   */
  export type EventCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    start: Date | null
    end: Date | null
    canceled: boolean | null
    revised: boolean | null
    link: string | null
    location: string | null
    categoryId: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    image: string | null
    start: Date | null
    end: Date | null
    canceled: boolean | null
    revised: boolean | null
    link: string | null
    location: string | null
    categoryId: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    image: number
    start: number
    end: number
    canceled: number
    revised: number
    link: number
    location: number
    categoryId: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    start?: true
    end?: true
    canceled?: true
    revised?: true
    link?: true
    location?: true
    categoryId?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    start?: true
    end?: true
    canceled?: true
    revised?: true
    link?: true
    location?: true
    categoryId?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    image?: true
    start?: true
    end?: true
    canceled?: true
    revised?: true
    link?: true
    location?: true
    categoryId?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    image: string | null
    start: Date
    end: Date | null
    canceled: boolean
    revised: boolean
    link: string | null
    location: string | null
    categoryId: string
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    start?: boolean
    end?: boolean
    canceled?: boolean
    revised?: boolean
    link?: boolean
    location?: boolean
    categoryId?: boolean
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
    likedByUsers?: boolean | Event$likedByUsersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    image?: boolean
    start?: boolean
    end?: boolean
    canceled?: boolean
    revised?: boolean
    link?: boolean
    location?: boolean
    categoryId?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
    likedByUsers?: boolean | Event$likedByUsersArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      category: Prisma.$EventCategoryPayload<ExtArgs>
      likedByUsers: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      image: string | null
      start: Date
      end: Date | null
      canceled: boolean
      revised: boolean
      link: string | null
      location: string | null
      categoryId: string
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends EventCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventCategoryDefaultArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    likedByUsers<T extends Event$likedByUsersArgs<ExtArgs> = {}>(args?: Subset<T, Event$likedByUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly image: FieldRef<"Event", 'String'>
    readonly start: FieldRef<"Event", 'DateTime'>
    readonly end: FieldRef<"Event", 'DateTime'>
    readonly canceled: FieldRef<"Event", 'Boolean'>
    readonly revised: FieldRef<"Event", 'Boolean'>
    readonly link: FieldRef<"Event", 'String'>
    readonly location: FieldRef<"Event", 'String'>
    readonly categoryId: FieldRef<"Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.likedByUsers
   */
  export type Event$likedByUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    image: 'image',
    auth0Id: 'auth0Id',
    address: 'address',
    cityCode: 'cityCode',
    cityName: 'cityName',
    countryCode: 'countryCode',
    needsSetup: 'needsSetup',
    publicName: 'publicName',
    phoneNumber: 'phoneNumber'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const AreaScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    activeFrom: 'activeFrom',
    activeTo: 'activeTo',
    bookableFrom: 'bookableFrom',
    order: 'order'
  };

  export type AreaScalarFieldEnum = (typeof AreaScalarFieldEnum)[keyof typeof AreaScalarFieldEnum]


  export const CourtScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    description: 'description',
    order: 'order',
    active: 'active',
    activeFrom: 'activeFrom',
    activeTo: 'activeTo',
    areaId: 'areaId'
  };

  export type CourtScalarFieldEnum = (typeof CourtScalarFieldEnum)[keyof typeof CourtScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    start: 'start',
    end: 'end',
    courtId: 'courtId',
    status: 'status',
    type: 'type',
    paypalTransactionId: 'paypalTransactionId',
    price: 'price',
    taxRate: 'taxRate',
    light: 'light',
    radiator: 'radiator',
    abonnementId: 'abonnementId',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    deletedAt: 'deletedAt'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const ReservationRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    errorDescription: 'errorDescription',
    checkOn: 'checkOn',
    ruleCheckPluginName: 'ruleCheckPluginName',
    value: 'value'
  };

  export type ReservationRuleScalarFieldEnum = (typeof ReservationRuleScalarFieldEnum)[keyof typeof ReservationRuleScalarFieldEnum]


  export const AbonnementScalarFieldEnum: {
    id: 'id',
    name: 'name',
    weekday: 'weekday',
    start: 'start',
    duration: 'duration',
    status: 'status',
    courtId: 'courtId',
    ownerId: 'ownerId'
  };

  export type AbonnementScalarFieldEnum = (typeof AbonnementScalarFieldEnum)[keyof typeof AbonnementScalarFieldEnum]


  export const UserRoleScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    isDefault: 'isDefault',
    priority: 'priority'
  };

  export type UserRoleScalarFieldEnum = (typeof UserRoleScalarFieldEnum)[keyof typeof UserRoleScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    router: 'router',
    action: 'action',
    userRoleId: 'userRoleId',
    allowed: 'allowed'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const HallencardScalarFieldEnum: {
    code: 'code',
    pin: 'pin',
    value: 'value',
    printed: 'printed',
    transactionId: 'transactionId'
  };

  export type HallencardScalarFieldEnum = (typeof HallencardScalarFieldEnum)[keyof typeof HallencardScalarFieldEnum]


  export const PriceScalarFieldEnum: {
    id: 'id',
    validFrom: 'validFrom',
    validTo: 'validTo',
    isDefault: 'isDefault',
    mon: 'mon',
    tue: 'tue',
    wed: 'wed',
    thu: 'thu',
    fri: 'fri',
    sat: 'sat',
    sun: 'sun',
    from: 'from',
    to: 'to',
    value: 'value',
    currency: 'currency',
    taxes: 'taxes'
  };

  export type PriceScalarFieldEnum = (typeof PriceScalarFieldEnum)[keyof typeof PriceScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    value: 'value',
    currency: 'currency',
    reason: 'reason',
    paymentInformation: 'paymentInformation',
    reservationId: 'reservationId',
    abonnementId: 'abonnementId',
    createdAt: 'createdAt',
    deleted: 'deleted'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    starting: 'starting',
    ending: 'ending',
    current: 'current'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name',
    shortName: 'shortName',
    category: 'category',
    orderNumber: 'orderNumber'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamSeasonScalarFieldEnum: {
    teamId: 'teamId',
    seasonId: 'seasonId',
    teamLeaderId: 'teamLeaderId',
    nuGroupId: 'nuGroupId',
    nuTeamId: 'nuTeamId',
    leagueName: 'leagueName'
  };

  export type TeamSeasonScalarFieldEnum = (typeof TeamSeasonScalarFieldEnum)[keyof typeof TeamSeasonScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    userId: 'userId',
    teamId: 'teamId',
    seasonId: 'seasonId'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    message: 'message',
    severity: 'severity',
    showFrom: 'showFrom',
    showTo: 'showTo'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const BenefitScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    cover: 'cover',
    link: 'link',
    activeFrom: 'activeFrom',
    activeTo: 'activeTo'
  };

  export type BenefitScalarFieldEnum = (typeof BenefitScalarFieldEnum)[keyof typeof BenefitScalarFieldEnum]


  export const ControlInterfaceScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    preBooking: 'preBooking',
    postBooking: 'postBooking',
    connectByAnd: 'connectByAnd',
    connectByOr: 'connectByOr'
  };

  export type ControlInterfaceScalarFieldEnum = (typeof ControlInterfaceScalarFieldEnum)[keyof typeof ControlInterfaceScalarFieldEnum]


  export const OrganisationScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title'
  };

  export type OrganisationScalarFieldEnum = (typeof OrganisationScalarFieldEnum)[keyof typeof OrganisationScalarFieldEnum]


  export const OrganisationMemberScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    function: 'function',
    image: 'image',
    email: 'email',
    phone: 'phone',
    orderID: 'orderID',
    organisationId: 'organisationId',
    parentMemberId: 'parentMemberId'
  };

  export type OrganisationMemberScalarFieldEnum = (typeof OrganisationMemberScalarFieldEnum)[keyof typeof OrganisationMemberScalarFieldEnum]


  export const EventCategoryScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title'
  };

  export type EventCategoryScalarFieldEnum = (typeof EventCategoryScalarFieldEnum)[keyof typeof EventCategoryScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    image: 'image',
    start: 'start',
    end: 'end',
    canceled: 'canceled',
    revised: 'revised',
    link: 'link',
    location: 'location',
    categoryId: 'categoryId'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'ReservationStatus'
   */
  export type EnumReservationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationStatus'>
    


  /**
   * Reference to a field of type 'ReservationType'
   */
  export type EnumReservationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationType'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'ReservationRuleCheckOn'
   */
  export type EnumReservationRuleCheckOnFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReservationRuleCheckOn'>
    


  /**
   * Reference to a field of type 'AbonnementStatus'
   */
  export type EnumAbonnementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AbonnementStatus'>
    


  /**
   * Reference to a field of type 'PermissionState'
   */
  export type EnumPermissionStateFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionState'>
    


  /**
   * Reference to a field of type 'TransactionReason'
   */
  export type EnumTransactionReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionReason'>
    


  /**
   * Reference to a field of type 'TeamCategory'
   */
  export type EnumTeamCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TeamCategory'>
    


  /**
   * Reference to a field of type 'NotificationSeverity'
   */
  export type EnumNotificationSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationSeverity'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    auth0Id?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    cityCode?: StringNullableFilter<"User"> | string | null
    cityName?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    needsSetup?: BoolFilter<"User"> | boolean
    publicName?: BoolFilter<"User"> | boolean
    phoneNumber?: StringNullableFilter<"User"> | string | null
    abonnements?: AbonnementListRelationFilter
    ownedReservations?: ReservationListRelationFilter
    fellowedReservations?: ReservationListRelationFilter
    transactions?: TransactionListRelationFilter
    teams?: TeamMemberListRelationFilter
    leadTeams?: TeamSeasonListRelationFilter
    roles?: UserRoleListRelationFilter
    likedEvents?: EventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    auth0Id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityCode?: SortOrderInput | SortOrder
    cityName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    needsSetup?: SortOrder
    publicName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    abonnements?: AbonnementOrderByRelationAggregateInput
    ownedReservations?: ReservationOrderByRelationAggregateInput
    fellowedReservations?: ReservationOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    teams?: TeamMemberOrderByRelationAggregateInput
    leadTeams?: TeamSeasonOrderByRelationAggregateInput
    roles?: UserRoleOrderByRelationAggregateInput
    likedEvents?: EventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    auth0Id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    cityCode?: StringNullableFilter<"User"> | string | null
    cityName?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    needsSetup?: BoolFilter<"User"> | boolean
    publicName?: BoolFilter<"User"> | boolean
    phoneNumber?: StringNullableFilter<"User"> | string | null
    abonnements?: AbonnementListRelationFilter
    ownedReservations?: ReservationListRelationFilter
    fellowedReservations?: ReservationListRelationFilter
    transactions?: TransactionListRelationFilter
    teams?: TeamMemberListRelationFilter
    leadTeams?: TeamSeasonListRelationFilter
    roles?: UserRoleListRelationFilter
    likedEvents?: EventListRelationFilter
  }, "id" | "email" | "auth0Id">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    auth0Id?: SortOrder
    address?: SortOrderInput | SortOrder
    cityCode?: SortOrderInput | SortOrder
    cityName?: SortOrderInput | SortOrder
    countryCode?: SortOrderInput | SortOrder
    needsSetup?: SortOrder
    publicName?: SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    auth0Id?: StringWithAggregatesFilter<"User"> | string
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    cityName?: StringNullableWithAggregatesFilter<"User"> | string | null
    countryCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    needsSetup?: BoolWithAggregatesFilter<"User"> | boolean
    publicName?: BoolWithAggregatesFilter<"User"> | boolean
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type AreaWhereInput = {
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    id?: IntFilter<"Area"> | number
    name?: StringFilter<"Area"> | string
    shortName?: StringFilter<"Area"> | string
    activeFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Area"> | Date | string | null
    bookableFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    order?: IntNullableFilter<"Area"> | number | null
    courts?: CourtListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
    prices?: PriceListRelationFilter
  }

  export type AreaOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
    bookableFrom?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    courts?: CourtOrderByRelationAggregateInput
    reservationRules?: ReservationRuleOrderByRelationAggregateInput
    prices?: PriceOrderByRelationAggregateInput
  }

  export type AreaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreaWhereInput | AreaWhereInput[]
    OR?: AreaWhereInput[]
    NOT?: AreaWhereInput | AreaWhereInput[]
    name?: StringFilter<"Area"> | string
    shortName?: StringFilter<"Area"> | string
    activeFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Area"> | Date | string | null
    bookableFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    order?: IntNullableFilter<"Area"> | number | null
    courts?: CourtListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
    prices?: PriceListRelationFilter
  }, "id">

  export type AreaOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
    bookableFrom?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    _count?: AreaCountOrderByAggregateInput
    _avg?: AreaAvgOrderByAggregateInput
    _max?: AreaMaxOrderByAggregateInput
    _min?: AreaMinOrderByAggregateInput
    _sum?: AreaSumOrderByAggregateInput
  }

  export type AreaScalarWhereWithAggregatesInput = {
    AND?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    OR?: AreaScalarWhereWithAggregatesInput[]
    NOT?: AreaScalarWhereWithAggregatesInput | AreaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Area"> | number
    name?: StringWithAggregatesFilter<"Area"> | string
    shortName?: StringWithAggregatesFilter<"Area"> | string
    activeFrom?: DateTimeNullableWithAggregatesFilter<"Area"> | Date | string | null
    activeTo?: DateTimeNullableWithAggregatesFilter<"Area"> | Date | string | null
    bookableFrom?: DateTimeNullableWithAggregatesFilter<"Area"> | Date | string | null
    order?: IntNullableWithAggregatesFilter<"Area"> | number | null
  }

  export type CourtWhereInput = {
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    id?: StringFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    shortName?: StringNullableFilter<"Court"> | string | null
    description?: StringNullableFilter<"Court"> | string | null
    order?: IntNullableFilter<"Court"> | number | null
    active?: BoolFilter<"Court"> | boolean
    activeFrom?: DateTimeNullableFilter<"Court"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Court"> | Date | string | null
    areaId?: IntFilter<"Court"> | number
    area?: XOR<AreaRelationFilter, AreaWhereInput>
    abonnements?: AbonnementListRelationFilter
    reservations?: ReservationListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
    controlInterfaces?: ControlInterfaceListRelationFilter
  }

  export type CourtOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    active?: SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
    areaId?: SortOrder
    area?: AreaOrderByWithRelationInput
    abonnements?: AbonnementOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
    reservationRules?: ReservationRuleOrderByRelationAggregateInput
    controlInterfaces?: ControlInterfaceOrderByRelationAggregateInput
  }

  export type CourtWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourtWhereInput | CourtWhereInput[]
    OR?: CourtWhereInput[]
    NOT?: CourtWhereInput | CourtWhereInput[]
    name?: StringFilter<"Court"> | string
    shortName?: StringNullableFilter<"Court"> | string | null
    description?: StringNullableFilter<"Court"> | string | null
    order?: IntNullableFilter<"Court"> | number | null
    active?: BoolFilter<"Court"> | boolean
    activeFrom?: DateTimeNullableFilter<"Court"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Court"> | Date | string | null
    areaId?: IntFilter<"Court"> | number
    area?: XOR<AreaRelationFilter, AreaWhereInput>
    abonnements?: AbonnementListRelationFilter
    reservations?: ReservationListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
    controlInterfaces?: ControlInterfaceListRelationFilter
  }, "id">

  export type CourtOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrderInput | SortOrder
    active?: SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
    areaId?: SortOrder
    _count?: CourtCountOrderByAggregateInput
    _avg?: CourtAvgOrderByAggregateInput
    _max?: CourtMaxOrderByAggregateInput
    _min?: CourtMinOrderByAggregateInput
    _sum?: CourtSumOrderByAggregateInput
  }

  export type CourtScalarWhereWithAggregatesInput = {
    AND?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    OR?: CourtScalarWhereWithAggregatesInput[]
    NOT?: CourtScalarWhereWithAggregatesInput | CourtScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Court"> | string
    name?: StringWithAggregatesFilter<"Court"> | string
    shortName?: StringNullableWithAggregatesFilter<"Court"> | string | null
    description?: StringNullableWithAggregatesFilter<"Court"> | string | null
    order?: IntNullableWithAggregatesFilter<"Court"> | number | null
    active?: BoolWithAggregatesFilter<"Court"> | boolean
    activeFrom?: DateTimeNullableWithAggregatesFilter<"Court"> | Date | string | null
    activeTo?: DateTimeNullableWithAggregatesFilter<"Court"> | Date | string | null
    areaId?: IntWithAggregatesFilter<"Court"> | number
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: StringFilter<"Reservation"> | string
    title?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    courtId?: StringNullableFilter<"Reservation"> | string | null
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    type?: EnumReservationTypeNullableFilter<"Reservation"> | $Enums.ReservationType | null
    paypalTransactionId?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatNullableFilter<"Reservation"> | number | null
    taxRate?: FloatNullableFilter<"Reservation"> | number | null
    light?: BoolFilter<"Reservation"> | boolean
    radiator?: BoolFilter<"Reservation"> | boolean
    abonnementId?: StringNullableFilter<"Reservation"> | string | null
    ownerId?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    court?: XOR<CourtNullableRelationFilter, CourtWhereInput> | null
    abo?: XOR<AbonnementNullableRelationFilter, AbonnementWhereInput> | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    fellows?: UserListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    courtId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrderInput | SortOrder
    paypalTransactionId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    light?: SortOrder
    radiator?: SortOrder
    abonnementId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    court?: CourtOrderByWithRelationInput
    abo?: AbonnementOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    fellows?: UserOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    title?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    courtId?: StringNullableFilter<"Reservation"> | string | null
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    type?: EnumReservationTypeNullableFilter<"Reservation"> | $Enums.ReservationType | null
    paypalTransactionId?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatNullableFilter<"Reservation"> | number | null
    taxRate?: FloatNullableFilter<"Reservation"> | number | null
    light?: BoolFilter<"Reservation"> | boolean
    radiator?: BoolFilter<"Reservation"> | boolean
    abonnementId?: StringNullableFilter<"Reservation"> | string | null
    ownerId?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
    court?: XOR<CourtNullableRelationFilter, CourtWhereInput> | null
    abo?: XOR<AbonnementNullableRelationFilter, AbonnementWhereInput> | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    fellows?: UserListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    courtId?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrderInput | SortOrder
    paypalTransactionId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    light?: SortOrder
    radiator?: SortOrder
    abonnementId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reservation"> | string
    title?: StringWithAggregatesFilter<"Reservation"> | string
    start?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    end?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    courtId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    status?: EnumReservationStatusWithAggregatesFilter<"Reservation"> | $Enums.ReservationStatus
    type?: EnumReservationTypeNullableWithAggregatesFilter<"Reservation"> | $Enums.ReservationType | null
    paypalTransactionId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    taxRate?: FloatNullableWithAggregatesFilter<"Reservation"> | number | null
    light?: BoolWithAggregatesFilter<"Reservation"> | boolean
    radiator?: BoolWithAggregatesFilter<"Reservation"> | boolean
    abonnementId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Reservation"> | Date | string | null
  }

  export type ReservationRuleWhereInput = {
    AND?: ReservationRuleWhereInput | ReservationRuleWhereInput[]
    OR?: ReservationRuleWhereInput[]
    NOT?: ReservationRuleWhereInput | ReservationRuleWhereInput[]
    id?: StringFilter<"ReservationRule"> | string
    name?: StringFilter<"ReservationRule"> | string
    errorDescription?: StringNullableFilter<"ReservationRule"> | string | null
    checkOn?: EnumReservationRuleCheckOnFilter<"ReservationRule"> | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: StringNullableFilter<"ReservationRule"> | string | null
    value?: StringFilter<"ReservationRule"> | string
    validFor?: UserRoleListRelationFilter
    affectedAreas?: AreaListRelationFilter
    affectedCourts?: CourtListRelationFilter
  }

  export type ReservationRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    errorDescription?: SortOrderInput | SortOrder
    checkOn?: SortOrder
    ruleCheckPluginName?: SortOrderInput | SortOrder
    value?: SortOrder
    validFor?: UserRoleOrderByRelationAggregateInput
    affectedAreas?: AreaOrderByRelationAggregateInput
    affectedCourts?: CourtOrderByRelationAggregateInput
  }

  export type ReservationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReservationRuleWhereInput | ReservationRuleWhereInput[]
    OR?: ReservationRuleWhereInput[]
    NOT?: ReservationRuleWhereInput | ReservationRuleWhereInput[]
    name?: StringFilter<"ReservationRule"> | string
    errorDescription?: StringNullableFilter<"ReservationRule"> | string | null
    checkOn?: EnumReservationRuleCheckOnFilter<"ReservationRule"> | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: StringNullableFilter<"ReservationRule"> | string | null
    value?: StringFilter<"ReservationRule"> | string
    validFor?: UserRoleListRelationFilter
    affectedAreas?: AreaListRelationFilter
    affectedCourts?: CourtListRelationFilter
  }, "id">

  export type ReservationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    errorDescription?: SortOrderInput | SortOrder
    checkOn?: SortOrder
    ruleCheckPluginName?: SortOrderInput | SortOrder
    value?: SortOrder
    _count?: ReservationRuleCountOrderByAggregateInput
    _max?: ReservationRuleMaxOrderByAggregateInput
    _min?: ReservationRuleMinOrderByAggregateInput
  }

  export type ReservationRuleScalarWhereWithAggregatesInput = {
    AND?: ReservationRuleScalarWhereWithAggregatesInput | ReservationRuleScalarWhereWithAggregatesInput[]
    OR?: ReservationRuleScalarWhereWithAggregatesInput[]
    NOT?: ReservationRuleScalarWhereWithAggregatesInput | ReservationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReservationRule"> | string
    name?: StringWithAggregatesFilter<"ReservationRule"> | string
    errorDescription?: StringNullableWithAggregatesFilter<"ReservationRule"> | string | null
    checkOn?: EnumReservationRuleCheckOnWithAggregatesFilter<"ReservationRule"> | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: StringNullableWithAggregatesFilter<"ReservationRule"> | string | null
    value?: StringWithAggregatesFilter<"ReservationRule"> | string
  }

  export type AbonnementWhereInput = {
    AND?: AbonnementWhereInput | AbonnementWhereInput[]
    OR?: AbonnementWhereInput[]
    NOT?: AbonnementWhereInput | AbonnementWhereInput[]
    id?: StringFilter<"Abonnement"> | string
    name?: StringFilter<"Abonnement"> | string
    weekday?: IntFilter<"Abonnement"> | number
    start?: DateTimeFilter<"Abonnement"> | Date | string
    duration?: FloatFilter<"Abonnement"> | number
    status?: EnumAbonnementStatusFilter<"Abonnement"> | $Enums.AbonnementStatus
    courtId?: StringNullableFilter<"Abonnement"> | string | null
    ownerId?: StringNullableFilter<"Abonnement"> | string | null
    court?: XOR<CourtNullableRelationFilter, CourtWhereInput> | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    transactions?: TransactionListRelationFilter
    reservations?: ReservationListRelationFilter
  }

  export type AbonnementOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    weekday?: SortOrder
    start?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    courtId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    court?: CourtOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    transactions?: TransactionOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type AbonnementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AbonnementWhereInput | AbonnementWhereInput[]
    OR?: AbonnementWhereInput[]
    NOT?: AbonnementWhereInput | AbonnementWhereInput[]
    name?: StringFilter<"Abonnement"> | string
    weekday?: IntFilter<"Abonnement"> | number
    start?: DateTimeFilter<"Abonnement"> | Date | string
    duration?: FloatFilter<"Abonnement"> | number
    status?: EnumAbonnementStatusFilter<"Abonnement"> | $Enums.AbonnementStatus
    courtId?: StringNullableFilter<"Abonnement"> | string | null
    ownerId?: StringNullableFilter<"Abonnement"> | string | null
    court?: XOR<CourtNullableRelationFilter, CourtWhereInput> | null
    owner?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    transactions?: TransactionListRelationFilter
    reservations?: ReservationListRelationFilter
  }, "id">

  export type AbonnementOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    weekday?: SortOrder
    start?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    courtId?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    _count?: AbonnementCountOrderByAggregateInput
    _avg?: AbonnementAvgOrderByAggregateInput
    _max?: AbonnementMaxOrderByAggregateInput
    _min?: AbonnementMinOrderByAggregateInput
    _sum?: AbonnementSumOrderByAggregateInput
  }

  export type AbonnementScalarWhereWithAggregatesInput = {
    AND?: AbonnementScalarWhereWithAggregatesInput | AbonnementScalarWhereWithAggregatesInput[]
    OR?: AbonnementScalarWhereWithAggregatesInput[]
    NOT?: AbonnementScalarWhereWithAggregatesInput | AbonnementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Abonnement"> | string
    name?: StringWithAggregatesFilter<"Abonnement"> | string
    weekday?: IntWithAggregatesFilter<"Abonnement"> | number
    start?: DateTimeWithAggregatesFilter<"Abonnement"> | Date | string
    duration?: FloatWithAggregatesFilter<"Abonnement"> | number
    status?: EnumAbonnementStatusWithAggregatesFilter<"Abonnement"> | $Enums.AbonnementStatus
    courtId?: StringNullableWithAggregatesFilter<"Abonnement"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Abonnement"> | string | null
  }

  export type UserRoleWhereInput = {
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    id?: IntFilter<"UserRole"> | number
    title?: StringFilter<"UserRole"> | string
    description?: StringNullableFilter<"UserRole"> | string | null
    isDefault?: BoolFilter<"UserRole"> | boolean
    priority?: IntFilter<"UserRole"> | number
    permissions?: PermissionListRelationFilter
    users?: UserListRelationFilter
    prices?: PriceListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
  }

  export type UserRoleOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    priority?: SortOrder
    permissions?: PermissionOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    prices?: PriceOrderByRelationAggregateInput
    reservationRules?: ReservationRuleOrderByRelationAggregateInput
  }

  export type UserRoleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UserRoleWhereInput | UserRoleWhereInput[]
    OR?: UserRoleWhereInput[]
    NOT?: UserRoleWhereInput | UserRoleWhereInput[]
    title?: StringFilter<"UserRole"> | string
    description?: StringNullableFilter<"UserRole"> | string | null
    isDefault?: BoolFilter<"UserRole"> | boolean
    priority?: IntFilter<"UserRole"> | number
    permissions?: PermissionListRelationFilter
    users?: UserListRelationFilter
    prices?: PriceListRelationFilter
    reservationRules?: ReservationRuleListRelationFilter
  }, "id">

  export type UserRoleOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    priority?: SortOrder
    _count?: UserRoleCountOrderByAggregateInput
    _avg?: UserRoleAvgOrderByAggregateInput
    _max?: UserRoleMaxOrderByAggregateInput
    _min?: UserRoleMinOrderByAggregateInput
    _sum?: UserRoleSumOrderByAggregateInput
  }

  export type UserRoleScalarWhereWithAggregatesInput = {
    AND?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    OR?: UserRoleScalarWhereWithAggregatesInput[]
    NOT?: UserRoleScalarWhereWithAggregatesInput | UserRoleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UserRole"> | number
    title?: StringWithAggregatesFilter<"UserRole"> | string
    description?: StringNullableWithAggregatesFilter<"UserRole"> | string | null
    isDefault?: BoolWithAggregatesFilter<"UserRole"> | boolean
    priority?: IntWithAggregatesFilter<"UserRole"> | number
  }

  export type PermissionWhereInput = {
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    router?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    userRoleId?: IntFilter<"Permission"> | number
    allowed?: EnumPermissionStateFilter<"Permission"> | $Enums.PermissionState
    userRole?: XOR<UserRoleRelationFilter, UserRoleWhereInput>
  }

  export type PermissionOrderByWithRelationInput = {
    router?: SortOrder
    action?: SortOrder
    userRoleId?: SortOrder
    allowed?: SortOrder
    userRole?: UserRoleOrderByWithRelationInput
  }

  export type PermissionWhereUniqueInput = Prisma.AtLeast<{
    router_action_userRoleId?: PermissionRouterActionUserRoleIdCompoundUniqueInput
    AND?: PermissionWhereInput | PermissionWhereInput[]
    OR?: PermissionWhereInput[]
    NOT?: PermissionWhereInput | PermissionWhereInput[]
    router?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    userRoleId?: IntFilter<"Permission"> | number
    allowed?: EnumPermissionStateFilter<"Permission"> | $Enums.PermissionState
    userRole?: XOR<UserRoleRelationFilter, UserRoleWhereInput>
  }, "router_action_userRoleId">

  export type PermissionOrderByWithAggregationInput = {
    router?: SortOrder
    action?: SortOrder
    userRoleId?: SortOrder
    allowed?: SortOrder
    _count?: PermissionCountOrderByAggregateInput
    _avg?: PermissionAvgOrderByAggregateInput
    _max?: PermissionMaxOrderByAggregateInput
    _min?: PermissionMinOrderByAggregateInput
    _sum?: PermissionSumOrderByAggregateInput
  }

  export type PermissionScalarWhereWithAggregatesInput = {
    AND?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    OR?: PermissionScalarWhereWithAggregatesInput[]
    NOT?: PermissionScalarWhereWithAggregatesInput | PermissionScalarWhereWithAggregatesInput[]
    router?: StringWithAggregatesFilter<"Permission"> | string
    action?: StringWithAggregatesFilter<"Permission"> | string
    userRoleId?: IntWithAggregatesFilter<"Permission"> | number
    allowed?: EnumPermissionStateWithAggregatesFilter<"Permission"> | $Enums.PermissionState
  }

  export type HallencardWhereInput = {
    AND?: HallencardWhereInput | HallencardWhereInput[]
    OR?: HallencardWhereInput[]
    NOT?: HallencardWhereInput | HallencardWhereInput[]
    code?: StringFilter<"Hallencard"> | string
    pin?: StringFilter<"Hallencard"> | string
    value?: FloatFilter<"Hallencard"> | number
    printed?: BoolFilter<"Hallencard"> | boolean
    transactionId?: StringNullableFilter<"Hallencard"> | string | null
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }

  export type HallencardOrderByWithRelationInput = {
    code?: SortOrder
    pin?: SortOrder
    value?: SortOrder
    printed?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    transaction?: TransactionOrderByWithRelationInput
  }

  export type HallencardWhereUniqueInput = Prisma.AtLeast<{
    code?: string
    transactionId?: string
    AND?: HallencardWhereInput | HallencardWhereInput[]
    OR?: HallencardWhereInput[]
    NOT?: HallencardWhereInput | HallencardWhereInput[]
    pin?: StringFilter<"Hallencard"> | string
    value?: FloatFilter<"Hallencard"> | number
    printed?: BoolFilter<"Hallencard"> | boolean
    transaction?: XOR<TransactionNullableRelationFilter, TransactionWhereInput> | null
  }, "code" | "transactionId">

  export type HallencardOrderByWithAggregationInput = {
    code?: SortOrder
    pin?: SortOrder
    value?: SortOrder
    printed?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    _count?: HallencardCountOrderByAggregateInput
    _avg?: HallencardAvgOrderByAggregateInput
    _max?: HallencardMaxOrderByAggregateInput
    _min?: HallencardMinOrderByAggregateInput
    _sum?: HallencardSumOrderByAggregateInput
  }

  export type HallencardScalarWhereWithAggregatesInput = {
    AND?: HallencardScalarWhereWithAggregatesInput | HallencardScalarWhereWithAggregatesInput[]
    OR?: HallencardScalarWhereWithAggregatesInput[]
    NOT?: HallencardScalarWhereWithAggregatesInput | HallencardScalarWhereWithAggregatesInput[]
    code?: StringWithAggregatesFilter<"Hallencard"> | string
    pin?: StringWithAggregatesFilter<"Hallencard"> | string
    value?: FloatWithAggregatesFilter<"Hallencard"> | number
    printed?: BoolWithAggregatesFilter<"Hallencard"> | boolean
    transactionId?: StringNullableWithAggregatesFilter<"Hallencard"> | string | null
  }

  export type PriceWhereInput = {
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    id?: StringFilter<"Price"> | string
    validFrom?: DateTimeNullableFilter<"Price"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Price"> | Date | string | null
    isDefault?: BoolFilter<"Price"> | boolean
    mon?: BoolFilter<"Price"> | boolean
    tue?: BoolFilter<"Price"> | boolean
    wed?: BoolFilter<"Price"> | boolean
    thu?: BoolFilter<"Price"> | boolean
    fri?: BoolFilter<"Price"> | boolean
    sat?: BoolFilter<"Price"> | boolean
    sun?: BoolFilter<"Price"> | boolean
    from?: IntFilter<"Price"> | number
    to?: IntFilter<"Price"> | number
    value?: FloatFilter<"Price"> | number
    currency?: StringFilter<"Price"> | string
    taxes?: FloatFilter<"Price"> | number
    roles?: UserRoleListRelationFilter
    areas?: AreaListRelationFilter
  }

  export type PriceOrderByWithRelationInput = {
    id?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    mon?: SortOrder
    tue?: SortOrder
    wed?: SortOrder
    thu?: SortOrder
    fri?: SortOrder
    sat?: SortOrder
    sun?: SortOrder
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    taxes?: SortOrder
    roles?: UserRoleOrderByRelationAggregateInput
    areas?: AreaOrderByRelationAggregateInput
  }

  export type PriceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PriceWhereInput | PriceWhereInput[]
    OR?: PriceWhereInput[]
    NOT?: PriceWhereInput | PriceWhereInput[]
    validFrom?: DateTimeNullableFilter<"Price"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Price"> | Date | string | null
    isDefault?: BoolFilter<"Price"> | boolean
    mon?: BoolFilter<"Price"> | boolean
    tue?: BoolFilter<"Price"> | boolean
    wed?: BoolFilter<"Price"> | boolean
    thu?: BoolFilter<"Price"> | boolean
    fri?: BoolFilter<"Price"> | boolean
    sat?: BoolFilter<"Price"> | boolean
    sun?: BoolFilter<"Price"> | boolean
    from?: IntFilter<"Price"> | number
    to?: IntFilter<"Price"> | number
    value?: FloatFilter<"Price"> | number
    currency?: StringFilter<"Price"> | string
    taxes?: FloatFilter<"Price"> | number
    roles?: UserRoleListRelationFilter
    areas?: AreaListRelationFilter
  }, "id">

  export type PriceOrderByWithAggregationInput = {
    id?: SortOrder
    validFrom?: SortOrderInput | SortOrder
    validTo?: SortOrderInput | SortOrder
    isDefault?: SortOrder
    mon?: SortOrder
    tue?: SortOrder
    wed?: SortOrder
    thu?: SortOrder
    fri?: SortOrder
    sat?: SortOrder
    sun?: SortOrder
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    taxes?: SortOrder
    _count?: PriceCountOrderByAggregateInput
    _avg?: PriceAvgOrderByAggregateInput
    _max?: PriceMaxOrderByAggregateInput
    _min?: PriceMinOrderByAggregateInput
    _sum?: PriceSumOrderByAggregateInput
  }

  export type PriceScalarWhereWithAggregatesInput = {
    AND?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    OR?: PriceScalarWhereWithAggregatesInput[]
    NOT?: PriceScalarWhereWithAggregatesInput | PriceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Price"> | string
    validFrom?: DateTimeNullableWithAggregatesFilter<"Price"> | Date | string | null
    validTo?: DateTimeNullableWithAggregatesFilter<"Price"> | Date | string | null
    isDefault?: BoolWithAggregatesFilter<"Price"> | boolean
    mon?: BoolWithAggregatesFilter<"Price"> | boolean
    tue?: BoolWithAggregatesFilter<"Price"> | boolean
    wed?: BoolWithAggregatesFilter<"Price"> | boolean
    thu?: BoolWithAggregatesFilter<"Price"> | boolean
    fri?: BoolWithAggregatesFilter<"Price"> | boolean
    sat?: BoolWithAggregatesFilter<"Price"> | boolean
    sun?: BoolWithAggregatesFilter<"Price"> | boolean
    from?: IntWithAggregatesFilter<"Price"> | number
    to?: IntWithAggregatesFilter<"Price"> | number
    value?: FloatWithAggregatesFilter<"Price"> | number
    currency?: StringWithAggregatesFilter<"Price"> | string
    taxes?: FloatWithAggregatesFilter<"Price"> | number
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringNullableFilter<"Transaction"> | string | null
    value?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    reason?: EnumTransactionReasonFilter<"Transaction"> | $Enums.TransactionReason
    paymentInformation?: StringNullableFilter<"Transaction"> | string | null
    reservationId?: StringNullableFilter<"Transaction"> | string | null
    abonnementId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    deleted?: BoolFilter<"Transaction"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    hallencard?: XOR<HallencardNullableRelationFilter, HallencardWhereInput> | null
    reservation?: XOR<ReservationNullableRelationFilter, ReservationWhereInput> | null
    abonnement?: XOR<AbonnementNullableRelationFilter, AbonnementWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    value?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    paymentInformation?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    abonnementId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    user?: UserOrderByWithRelationInput
    hallencard?: HallencardOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    abonnement?: AbonnementOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    userId?: StringNullableFilter<"Transaction"> | string | null
    value?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    reason?: EnumTransactionReasonFilter<"Transaction"> | $Enums.TransactionReason
    paymentInformation?: StringNullableFilter<"Transaction"> | string | null
    reservationId?: StringNullableFilter<"Transaction"> | string | null
    abonnementId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    deleted?: BoolFilter<"Transaction"> | boolean
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    hallencard?: XOR<HallencardNullableRelationFilter, HallencardWhereInput> | null
    reservation?: XOR<ReservationNullableRelationFilter, ReservationWhereInput> | null
    abonnement?: XOR<AbonnementNullableRelationFilter, AbonnementWhereInput> | null
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    value?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    paymentInformation?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    abonnementId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    userId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    value?: FloatWithAggregatesFilter<"Transaction"> | number
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    reason?: EnumTransactionReasonWithAggregatesFilter<"Transaction"> | $Enums.TransactionReason
    paymentInformation?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    reservationId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    abonnementId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    deleted?: BoolWithAggregatesFilter<"Transaction"> | boolean
  }

  export type SeasonWhereInput = {
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    id?: IntFilter<"Season"> | number
    name?: StringFilter<"Season"> | string
    shortName?: StringFilter<"Season"> | string
    starting?: DateTimeFilter<"Season"> | Date | string
    ending?: DateTimeFilter<"Season"> | Date | string
    current?: BoolFilter<"Season"> | boolean
    teams?: TeamSeasonListRelationFilter
    players?: TeamMemberListRelationFilter
  }

  export type SeasonOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    starting?: SortOrder
    ending?: SortOrder
    current?: SortOrder
    teams?: TeamSeasonOrderByRelationAggregateInput
    players?: TeamMemberOrderByRelationAggregateInput
  }

  export type SeasonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SeasonWhereInput | SeasonWhereInput[]
    OR?: SeasonWhereInput[]
    NOT?: SeasonWhereInput | SeasonWhereInput[]
    name?: StringFilter<"Season"> | string
    shortName?: StringFilter<"Season"> | string
    starting?: DateTimeFilter<"Season"> | Date | string
    ending?: DateTimeFilter<"Season"> | Date | string
    current?: BoolFilter<"Season"> | boolean
    teams?: TeamSeasonListRelationFilter
    players?: TeamMemberListRelationFilter
  }, "id">

  export type SeasonOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    starting?: SortOrder
    ending?: SortOrder
    current?: SortOrder
    _count?: SeasonCountOrderByAggregateInput
    _avg?: SeasonAvgOrderByAggregateInput
    _max?: SeasonMaxOrderByAggregateInput
    _min?: SeasonMinOrderByAggregateInput
    _sum?: SeasonSumOrderByAggregateInput
  }

  export type SeasonScalarWhereWithAggregatesInput = {
    AND?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    OR?: SeasonScalarWhereWithAggregatesInput[]
    NOT?: SeasonScalarWhereWithAggregatesInput | SeasonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Season"> | number
    name?: StringWithAggregatesFilter<"Season"> | string
    shortName?: StringWithAggregatesFilter<"Season"> | string
    starting?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    ending?: DateTimeWithAggregatesFilter<"Season"> | Date | string
    current?: BoolWithAggregatesFilter<"Season"> | boolean
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: IntFilter<"Team"> | number
    name?: StringFilter<"Team"> | string
    shortName?: StringFilter<"Team"> | string
    category?: EnumTeamCategoryFilter<"Team"> | $Enums.TeamCategory
    orderNumber?: IntFilter<"Team"> | number
    teamSeasons?: TeamSeasonListRelationFilter
    members?: TeamMemberListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    orderNumber?: SortOrder
    teamSeasons?: TeamSeasonOrderByRelationAggregateInput
    members?: TeamMemberOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    shortName?: StringFilter<"Team"> | string
    category?: EnumTeamCategoryFilter<"Team"> | $Enums.TeamCategory
    orderNumber?: IntFilter<"Team"> | number
    teamSeasons?: TeamSeasonListRelationFilter
    members?: TeamMemberListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    orderNumber?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _avg?: TeamAvgOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
    _sum?: TeamSumOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Team"> | number
    name?: StringWithAggregatesFilter<"Team"> | string
    shortName?: StringWithAggregatesFilter<"Team"> | string
    category?: EnumTeamCategoryWithAggregatesFilter<"Team"> | $Enums.TeamCategory
    orderNumber?: IntWithAggregatesFilter<"Team"> | number
  }

  export type TeamSeasonWhereInput = {
    AND?: TeamSeasonWhereInput | TeamSeasonWhereInput[]
    OR?: TeamSeasonWhereInput[]
    NOT?: TeamSeasonWhereInput | TeamSeasonWhereInput[]
    teamId?: IntFilter<"TeamSeason"> | number
    seasonId?: IntFilter<"TeamSeason"> | number
    teamLeaderId?: StringNullableFilter<"TeamSeason"> | string | null
    nuGroupId?: StringFilter<"TeamSeason"> | string
    nuTeamId?: StringFilter<"TeamSeason"> | string
    leagueName?: StringFilter<"TeamSeason"> | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    season?: XOR<SeasonRelationFilter, SeasonWhereInput>
    teamLeader?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type TeamSeasonOrderByWithRelationInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
    teamLeaderId?: SortOrderInput | SortOrder
    nuGroupId?: SortOrder
    nuTeamId?: SortOrder
    leagueName?: SortOrder
    team?: TeamOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
    teamLeader?: UserOrderByWithRelationInput
  }

  export type TeamSeasonWhereUniqueInput = Prisma.AtLeast<{
    teamId_seasonId?: TeamSeasonTeamIdSeasonIdCompoundUniqueInput
    AND?: TeamSeasonWhereInput | TeamSeasonWhereInput[]
    OR?: TeamSeasonWhereInput[]
    NOT?: TeamSeasonWhereInput | TeamSeasonWhereInput[]
    teamId?: IntFilter<"TeamSeason"> | number
    seasonId?: IntFilter<"TeamSeason"> | number
    teamLeaderId?: StringNullableFilter<"TeamSeason"> | string | null
    nuGroupId?: StringFilter<"TeamSeason"> | string
    nuTeamId?: StringFilter<"TeamSeason"> | string
    leagueName?: StringFilter<"TeamSeason"> | string
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    season?: XOR<SeasonRelationFilter, SeasonWhereInput>
    teamLeader?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "teamId_seasonId">

  export type TeamSeasonOrderByWithAggregationInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
    teamLeaderId?: SortOrderInput | SortOrder
    nuGroupId?: SortOrder
    nuTeamId?: SortOrder
    leagueName?: SortOrder
    _count?: TeamSeasonCountOrderByAggregateInput
    _avg?: TeamSeasonAvgOrderByAggregateInput
    _max?: TeamSeasonMaxOrderByAggregateInput
    _min?: TeamSeasonMinOrderByAggregateInput
    _sum?: TeamSeasonSumOrderByAggregateInput
  }

  export type TeamSeasonScalarWhereWithAggregatesInput = {
    AND?: TeamSeasonScalarWhereWithAggregatesInput | TeamSeasonScalarWhereWithAggregatesInput[]
    OR?: TeamSeasonScalarWhereWithAggregatesInput[]
    NOT?: TeamSeasonScalarWhereWithAggregatesInput | TeamSeasonScalarWhereWithAggregatesInput[]
    teamId?: IntWithAggregatesFilter<"TeamSeason"> | number
    seasonId?: IntWithAggregatesFilter<"TeamSeason"> | number
    teamLeaderId?: StringNullableWithAggregatesFilter<"TeamSeason"> | string | null
    nuGroupId?: StringWithAggregatesFilter<"TeamSeason"> | string
    nuTeamId?: StringWithAggregatesFilter<"TeamSeason"> | string
    leagueName?: StringWithAggregatesFilter<"TeamSeason"> | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    userId?: StringFilter<"TeamMember"> | string
    teamId?: IntFilter<"TeamMember"> | number
    seasonId?: IntFilter<"TeamMember"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    season?: XOR<SeasonRelationFilter, SeasonWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    userId?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    season?: SeasonOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    userId_teamId_seasonId?: TeamMemberUserIdTeamIdSeasonIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    userId?: StringFilter<"TeamMember"> | string
    teamId?: IntFilter<"TeamMember"> | number
    seasonId?: IntFilter<"TeamMember"> | number
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    season?: XOR<SeasonRelationFilter, SeasonWhereInput>
  }, "userId_teamId_seasonId">

  export type TeamMemberOrderByWithAggregationInput = {
    userId?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _avg?: TeamMemberAvgOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
    _sum?: TeamMemberSumOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: IntWithAggregatesFilter<"TeamMember"> | number
    seasonId?: IntWithAggregatesFilter<"TeamMember"> | number
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    severity?: EnumNotificationSeverityFilter<"Notification"> | $Enums.NotificationSeverity
    showFrom?: DateTimeFilter<"Notification"> | Date | string
    showTo?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    severity?: SortOrder
    showFrom?: SortOrder
    showTo?: SortOrder
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    message?: StringNullableFilter<"Notification"> | string | null
    severity?: EnumNotificationSeverityFilter<"Notification"> | $Enums.NotificationSeverity
    showFrom?: DateTimeFilter<"Notification"> | Date | string
    showTo?: DateTimeFilter<"Notification"> | Date | string
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrderInput | SortOrder
    severity?: SortOrder
    showFrom?: SortOrder
    showTo?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    severity?: EnumNotificationSeverityWithAggregatesFilter<"Notification"> | $Enums.NotificationSeverity
    showFrom?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    showTo?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type BenefitWhereInput = {
    AND?: BenefitWhereInput | BenefitWhereInput[]
    OR?: BenefitWhereInput[]
    NOT?: BenefitWhereInput | BenefitWhereInput[]
    id?: StringFilter<"Benefit"> | string
    title?: StringFilter<"Benefit"> | string
    description?: StringNullableFilter<"Benefit"> | string | null
    image?: StringNullableFilter<"Benefit"> | string | null
    cover?: BoolFilter<"Benefit"> | boolean
    link?: StringNullableFilter<"Benefit"> | string | null
    activeFrom?: DateTimeNullableFilter<"Benefit"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Benefit"> | Date | string | null
  }

  export type BenefitOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover?: SortOrder
    link?: SortOrderInput | SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
  }

  export type BenefitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BenefitWhereInput | BenefitWhereInput[]
    OR?: BenefitWhereInput[]
    NOT?: BenefitWhereInput | BenefitWhereInput[]
    title?: StringFilter<"Benefit"> | string
    description?: StringNullableFilter<"Benefit"> | string | null
    image?: StringNullableFilter<"Benefit"> | string | null
    cover?: BoolFilter<"Benefit"> | boolean
    link?: StringNullableFilter<"Benefit"> | string | null
    activeFrom?: DateTimeNullableFilter<"Benefit"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Benefit"> | Date | string | null
  }, "id">

  export type BenefitOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    cover?: SortOrder
    link?: SortOrderInput | SortOrder
    activeFrom?: SortOrderInput | SortOrder
    activeTo?: SortOrderInput | SortOrder
    _count?: BenefitCountOrderByAggregateInput
    _max?: BenefitMaxOrderByAggregateInput
    _min?: BenefitMinOrderByAggregateInput
  }

  export type BenefitScalarWhereWithAggregatesInput = {
    AND?: BenefitScalarWhereWithAggregatesInput | BenefitScalarWhereWithAggregatesInput[]
    OR?: BenefitScalarWhereWithAggregatesInput[]
    NOT?: BenefitScalarWhereWithAggregatesInput | BenefitScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Benefit"> | string
    title?: StringWithAggregatesFilter<"Benefit"> | string
    description?: StringNullableWithAggregatesFilter<"Benefit"> | string | null
    image?: StringNullableWithAggregatesFilter<"Benefit"> | string | null
    cover?: BoolWithAggregatesFilter<"Benefit"> | boolean
    link?: StringNullableWithAggregatesFilter<"Benefit"> | string | null
    activeFrom?: DateTimeNullableWithAggregatesFilter<"Benefit"> | Date | string | null
    activeTo?: DateTimeNullableWithAggregatesFilter<"Benefit"> | Date | string | null
  }

  export type ControlInterfaceWhereInput = {
    AND?: ControlInterfaceWhereInput | ControlInterfaceWhereInput[]
    OR?: ControlInterfaceWhereInput[]
    NOT?: ControlInterfaceWhereInput | ControlInterfaceWhereInput[]
    id?: StringFilter<"ControlInterface"> | string
    title?: StringFilter<"ControlInterface"> | string
    description?: StringFilter<"ControlInterface"> | string
    preBooking?: IntFilter<"ControlInterface"> | number
    postBooking?: IntFilter<"ControlInterface"> | number
    connectByAnd?: BoolFilter<"ControlInterface"> | boolean
    connectByOr?: BoolFilter<"ControlInterface"> | boolean
    affectedCourts?: CourtListRelationFilter
  }

  export type ControlInterfaceOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preBooking?: SortOrder
    postBooking?: SortOrder
    connectByAnd?: SortOrder
    connectByOr?: SortOrder
    affectedCourts?: CourtOrderByRelationAggregateInput
  }

  export type ControlInterfaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ControlInterfaceWhereInput | ControlInterfaceWhereInput[]
    OR?: ControlInterfaceWhereInput[]
    NOT?: ControlInterfaceWhereInput | ControlInterfaceWhereInput[]
    title?: StringFilter<"ControlInterface"> | string
    description?: StringFilter<"ControlInterface"> | string
    preBooking?: IntFilter<"ControlInterface"> | number
    postBooking?: IntFilter<"ControlInterface"> | number
    connectByAnd?: BoolFilter<"ControlInterface"> | boolean
    connectByOr?: BoolFilter<"ControlInterface"> | boolean
    affectedCourts?: CourtListRelationFilter
  }, "id">

  export type ControlInterfaceOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preBooking?: SortOrder
    postBooking?: SortOrder
    connectByAnd?: SortOrder
    connectByOr?: SortOrder
    _count?: ControlInterfaceCountOrderByAggregateInput
    _avg?: ControlInterfaceAvgOrderByAggregateInput
    _max?: ControlInterfaceMaxOrderByAggregateInput
    _min?: ControlInterfaceMinOrderByAggregateInput
    _sum?: ControlInterfaceSumOrderByAggregateInput
  }

  export type ControlInterfaceScalarWhereWithAggregatesInput = {
    AND?: ControlInterfaceScalarWhereWithAggregatesInput | ControlInterfaceScalarWhereWithAggregatesInput[]
    OR?: ControlInterfaceScalarWhereWithAggregatesInput[]
    NOT?: ControlInterfaceScalarWhereWithAggregatesInput | ControlInterfaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ControlInterface"> | string
    title?: StringWithAggregatesFilter<"ControlInterface"> | string
    description?: StringWithAggregatesFilter<"ControlInterface"> | string
    preBooking?: IntWithAggregatesFilter<"ControlInterface"> | number
    postBooking?: IntWithAggregatesFilter<"ControlInterface"> | number
    connectByAnd?: BoolWithAggregatesFilter<"ControlInterface"> | boolean
    connectByOr?: BoolWithAggregatesFilter<"ControlInterface"> | boolean
  }

  export type OrganisationWhereInput = {
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    id?: StringFilter<"Organisation"> | string
    slug?: StringFilter<"Organisation"> | string
    title?: StringFilter<"Organisation"> | string
    members?: OrganisationMemberListRelationFilter
  }

  export type OrganisationOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    members?: OrganisationMemberOrderByRelationAggregateInput
  }

  export type OrganisationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: OrganisationWhereInput | OrganisationWhereInput[]
    OR?: OrganisationWhereInput[]
    NOT?: OrganisationWhereInput | OrganisationWhereInput[]
    title?: StringFilter<"Organisation"> | string
    members?: OrganisationMemberListRelationFilter
  }, "id" | "slug">

  export type OrganisationOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    _count?: OrganisationCountOrderByAggregateInput
    _max?: OrganisationMaxOrderByAggregateInput
    _min?: OrganisationMinOrderByAggregateInput
  }

  export type OrganisationScalarWhereWithAggregatesInput = {
    AND?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    OR?: OrganisationScalarWhereWithAggregatesInput[]
    NOT?: OrganisationScalarWhereWithAggregatesInput | OrganisationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Organisation"> | string
    slug?: StringWithAggregatesFilter<"Organisation"> | string
    title?: StringWithAggregatesFilter<"Organisation"> | string
  }

  export type OrganisationMemberWhereInput = {
    AND?: OrganisationMemberWhereInput | OrganisationMemberWhereInput[]
    OR?: OrganisationMemberWhereInput[]
    NOT?: OrganisationMemberWhereInput | OrganisationMemberWhereInput[]
    id?: StringFilter<"OrganisationMember"> | string
    fullName?: StringFilter<"OrganisationMember"> | string
    function?: StringNullableFilter<"OrganisationMember"> | string | null
    image?: StringNullableFilter<"OrganisationMember"> | string | null
    email?: StringNullableFilter<"OrganisationMember"> | string | null
    phone?: StringNullableFilter<"OrganisationMember"> | string | null
    orderID?: IntNullableFilter<"OrganisationMember"> | number | null
    organisationId?: StringFilter<"OrganisationMember"> | string
    parentMemberId?: StringNullableFilter<"OrganisationMember"> | string | null
    organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    parentMember?: XOR<OrganisationMemberNullableRelationFilter, OrganisationMemberWhereInput> | null
    childMembers?: OrganisationMemberListRelationFilter
  }

  export type OrganisationMemberOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    function?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    orderID?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    parentMemberId?: SortOrderInput | SortOrder
    organisation?: OrganisationOrderByWithRelationInput
    parentMember?: OrganisationMemberOrderByWithRelationInput
    childMembers?: OrganisationMemberOrderByRelationAggregateInput
  }

  export type OrganisationMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrganisationMemberWhereInput | OrganisationMemberWhereInput[]
    OR?: OrganisationMemberWhereInput[]
    NOT?: OrganisationMemberWhereInput | OrganisationMemberWhereInput[]
    fullName?: StringFilter<"OrganisationMember"> | string
    function?: StringNullableFilter<"OrganisationMember"> | string | null
    image?: StringNullableFilter<"OrganisationMember"> | string | null
    email?: StringNullableFilter<"OrganisationMember"> | string | null
    phone?: StringNullableFilter<"OrganisationMember"> | string | null
    orderID?: IntNullableFilter<"OrganisationMember"> | number | null
    organisationId?: StringFilter<"OrganisationMember"> | string
    parentMemberId?: StringNullableFilter<"OrganisationMember"> | string | null
    organisation?: XOR<OrganisationRelationFilter, OrganisationWhereInput>
    parentMember?: XOR<OrganisationMemberNullableRelationFilter, OrganisationMemberWhereInput> | null
    childMembers?: OrganisationMemberListRelationFilter
  }, "id">

  export type OrganisationMemberOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    function?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    orderID?: SortOrderInput | SortOrder
    organisationId?: SortOrder
    parentMemberId?: SortOrderInput | SortOrder
    _count?: OrganisationMemberCountOrderByAggregateInput
    _avg?: OrganisationMemberAvgOrderByAggregateInput
    _max?: OrganisationMemberMaxOrderByAggregateInput
    _min?: OrganisationMemberMinOrderByAggregateInput
    _sum?: OrganisationMemberSumOrderByAggregateInput
  }

  export type OrganisationMemberScalarWhereWithAggregatesInput = {
    AND?: OrganisationMemberScalarWhereWithAggregatesInput | OrganisationMemberScalarWhereWithAggregatesInput[]
    OR?: OrganisationMemberScalarWhereWithAggregatesInput[]
    NOT?: OrganisationMemberScalarWhereWithAggregatesInput | OrganisationMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrganisationMember"> | string
    fullName?: StringWithAggregatesFilter<"OrganisationMember"> | string
    function?: StringNullableWithAggregatesFilter<"OrganisationMember"> | string | null
    image?: StringNullableWithAggregatesFilter<"OrganisationMember"> | string | null
    email?: StringNullableWithAggregatesFilter<"OrganisationMember"> | string | null
    phone?: StringNullableWithAggregatesFilter<"OrganisationMember"> | string | null
    orderID?: IntNullableWithAggregatesFilter<"OrganisationMember"> | number | null
    organisationId?: StringWithAggregatesFilter<"OrganisationMember"> | string
    parentMemberId?: StringNullableWithAggregatesFilter<"OrganisationMember"> | string | null
  }

  export type EventCategoryWhereInput = {
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    id?: StringFilter<"EventCategory"> | string
    slug?: StringFilter<"EventCategory"> | string
    title?: StringFilter<"EventCategory"> | string
    events?: EventListRelationFilter
  }

  export type EventCategoryOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    events?: EventOrderByRelationAggregateInput
  }

  export type EventCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    title?: StringFilter<"EventCategory"> | string
    events?: EventListRelationFilter
  }, "id" | "slug">

  export type EventCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    _count?: EventCategoryCountOrderByAggregateInput
    _max?: EventCategoryMaxOrderByAggregateInput
    _min?: EventCategoryMinOrderByAggregateInput
  }

  export type EventCategoryScalarWhereWithAggregatesInput = {
    AND?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    OR?: EventCategoryScalarWhereWithAggregatesInput[]
    NOT?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventCategory"> | string
    slug?: StringWithAggregatesFilter<"EventCategory"> | string
    title?: StringWithAggregatesFilter<"EventCategory"> | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    image?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeNullableFilter<"Event"> | Date | string | null
    canceled?: BoolFilter<"Event"> | boolean
    revised?: BoolFilter<"Event"> | boolean
    link?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    categoryId?: StringFilter<"Event"> | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    likedByUsers?: UserListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    canceled?: SortOrder
    revised?: SortOrder
    link?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    category?: EventCategoryOrderByWithRelationInput
    likedByUsers?: UserOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    image?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeNullableFilter<"Event"> | Date | string | null
    canceled?: BoolFilter<"Event"> | boolean
    revised?: BoolFilter<"Event"> | boolean
    link?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    categoryId?: StringFilter<"Event"> | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    likedByUsers?: UserListRelationFilter
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    start?: SortOrder
    end?: SortOrderInput | SortOrder
    canceled?: SortOrder
    revised?: SortOrder
    link?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    categoryId?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    image?: StringNullableWithAggregatesFilter<"Event"> | string | null
    start?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    end?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    canceled?: BoolWithAggregatesFilter<"Event"> | boolean
    revised?: BoolWithAggregatesFilter<"Event"> | boolean
    link?: StringNullableWithAggregatesFilter<"Event"> | string | null
    location?: StringNullableWithAggregatesFilter<"Event"> | string | null
    categoryId?: StringWithAggregatesFilter<"Event"> | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AreaCreateInput = {
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtCreateNestedManyWithoutAreaInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedAreasInput
    prices?: PriceCreateNestedManyWithoutAreasInput
  }

  export type AreaUncheckedCreateInput = {
    id?: number
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtUncheckedCreateNestedManyWithoutAreaInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedAreasInput
    prices?: PriceUncheckedCreateNestedManyWithoutAreasInput
  }

  export type AreaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUpdateManyWithoutAreaNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedAreasNestedInput
    prices?: PriceUpdateManyWithoutAreasNestedInput
  }

  export type AreaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUncheckedUpdateManyWithoutAreaNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedAreasNestedInput
    prices?: PriceUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type AreaCreateManyInput = {
    id?: number
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
  }

  export type AreaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type AreaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourtCreateInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    area: AreaCreateNestedOneWithoutCourtsInput
    abonnements?: AbonnementCreateNestedManyWithoutCourtInput
    reservations?: ReservationCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutCourtInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: AreaUpdateOneRequiredWithoutCourtsNestedInput
    abonnements?: AbonnementUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
    abonnements?: AbonnementUncheckedUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtCreateManyInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
  }

  export type CourtUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourtUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type ReservationCreateInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    court?: CourtCreateNestedOneWithoutReservationsInput
    abo?: AbonnementCreateNestedOneWithoutReservationsInput
    owner?: UserCreateNestedOneWithoutOwnedReservationsInput
    fellows?: UserCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    fellows?: UserUncheckedCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    court?: CourtUpdateOneWithoutReservationsNestedInput
    abo?: AbonnementUpdateOneWithoutReservationsNestedInput
    owner?: UserUpdateOneWithoutOwnedReservationsNestedInput
    fellows?: UserUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fellows?: UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ReservationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationRuleCreateInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleCreateNestedManyWithoutReservationRulesInput
    affectedAreas?: AreaCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleUncheckedCreateInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleUncheckedCreateNestedManyWithoutReservationRulesInput
    affectedAreas?: AreaUncheckedCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtUncheckedCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUpdateManyWithoutReservationRulesNestedInput
    affectedAreas?: AreaUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUncheckedUpdateManyWithoutReservationRulesNestedInput
    affectedAreas?: AreaUncheckedUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUncheckedUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleCreateManyInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
  }

  export type ReservationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ReservationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
  }

  export type AbonnementCreateInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    court?: CourtCreateNestedOneWithoutAbonnementsInput
    owner?: UserCreateNestedOneWithoutAbonnementsInput
    transactions?: TransactionCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationCreateNestedManyWithoutAboInput
  }

  export type AbonnementUncheckedCreateInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
    ownerId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutAboInput
  }

  export type AbonnementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    court?: CourtUpdateOneWithoutAbonnementsNestedInput
    owner?: UserUpdateOneWithoutAbonnementsNestedInput
    transactions?: TransactionUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutAboNestedInput
  }

  export type AbonnementCreateManyInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
    ownerId?: string | null
  }

  export type AbonnementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
  }

  export type AbonnementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserRoleCreateInput = {
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionCreateNestedManyWithoutUserRoleInput
    users?: UserCreateNestedManyWithoutRolesInput
    prices?: PriceCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutValidForInput
  }

  export type UserRoleUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    prices?: PriceUncheckedCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutValidForInput
  }

  export type UserRoleUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUpdateManyWithoutUserRoleNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    prices?: PriceUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUncheckedUpdateManyWithoutUserRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    prices?: PriceUncheckedUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
  }

  export type UserRoleUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type UserRoleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type PermissionCreateInput = {
    router: string
    action: string
    allowed?: $Enums.PermissionState
    userRole: UserRoleCreateNestedOneWithoutPermissionsInput
  }

  export type PermissionUncheckedCreateInput = {
    router: string
    action: string
    userRoleId: number
    allowed?: $Enums.PermissionState
  }

  export type PermissionUpdateInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
    userRole?: UserRoleUpdateOneRequiredWithoutPermissionsNestedInput
  }

  export type PermissionUncheckedUpdateInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userRoleId?: IntFieldUpdateOperationsInput | number
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type PermissionCreateManyInput = {
    router: string
    action: string
    userRoleId: number
    allowed?: $Enums.PermissionState
  }

  export type PermissionUpdateManyMutationInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type PermissionUncheckedUpdateManyInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    userRoleId?: IntFieldUpdateOperationsInput | number
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type HallencardCreateInput = {
    code: string
    pin: string
    value: number
    printed: boolean
    transaction?: TransactionCreateNestedOneWithoutHallencardInput
  }

  export type HallencardUncheckedCreateInput = {
    code: string
    pin: string
    value: number
    printed: boolean
    transactionId?: string | null
  }

  export type HallencardUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
    transaction?: TransactionUpdateOneWithoutHallencardNestedInput
  }

  export type HallencardUncheckedUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HallencardCreateManyInput = {
    code: string
    pin: string
    value: number
    printed: boolean
    transactionId?: string | null
  }

  export type HallencardUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HallencardUncheckedUpdateManyInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceCreateInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    roles?: UserRoleCreateNestedManyWithoutPricesInput
    areas?: AreaCreateNestedManyWithoutPricesInput
  }

  export type PriceUncheckedCreateInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    roles?: UserRoleUncheckedCreateNestedManyWithoutPricesInput
    areas?: AreaUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PriceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    roles?: UserRoleUpdateManyWithoutPricesNestedInput
    areas?: AreaUpdateManyWithoutPricesNestedInput
  }

  export type PriceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    roles?: UserRoleUncheckedUpdateManyWithoutPricesNestedInput
    areas?: AreaUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PriceCreateManyInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
  }

  export type PriceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
  }

  export type PriceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
  }

  export type TransactionCreateInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    createdAt?: Date | string
    deleted?: boolean
    user?: UserCreateNestedOneWithoutTransactionsInput
    hallencard?: HallencardCreateNestedOneWithoutTransactionInput
    reservation?: ReservationCreateNestedOneWithoutTransactionsInput
    abonnement?: AbonnementCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
    hallencard?: HallencardUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutTransactionsNestedInput
    hallencard?: HallencardUpdateOneWithoutTransactionNestedInput
    reservation?: ReservationUpdateOneWithoutTransactionsNestedInput
    abonnement?: AbonnementUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    hallencard?: HallencardUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonCreateInput = {
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    teams?: TeamSeasonCreateNestedManyWithoutSeasonInput
    players?: TeamMemberCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateInput = {
    id?: number
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    teams?: TeamSeasonUncheckedCreateNestedManyWithoutSeasonInput
    players?: TeamMemberUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    teams?: TeamSeasonUpdateManyWithoutSeasonNestedInput
    players?: TeamMemberUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    teams?: TeamSeasonUncheckedUpdateManyWithoutSeasonNestedInput
    players?: TeamMemberUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonCreateManyInput = {
    id?: number
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
  }

  export type SeasonUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SeasonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamCreateInput = {
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    teamSeasons?: TeamSeasonCreateNestedManyWithoutTeamInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: number
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    teamSeasons?: TeamSeasonUncheckedCreateNestedManyWithoutTeamInput
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    teamSeasons?: TeamSeasonUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    teamSeasons?: TeamSeasonUncheckedUpdateManyWithoutTeamNestedInput
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: number
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
  }

  export type TeamUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
  }

  export type TeamSeasonCreateInput = {
    nuGroupId: string
    nuTeamId: string
    leagueName: string
    team: TeamCreateNestedOneWithoutTeamSeasonsInput
    season: SeasonCreateNestedOneWithoutTeamsInput
    teamLeader?: UserCreateNestedOneWithoutLeadTeamsInput
  }

  export type TeamSeasonUncheckedCreateInput = {
    teamId: number
    seasonId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamSeasonUpdateInput = {
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutTeamSeasonsNestedInput
    season?: SeasonUpdateOneRequiredWithoutTeamsNestedInput
    teamLeader?: UserUpdateOneWithoutLeadTeamsNestedInput
  }

  export type TeamSeasonUncheckedUpdateInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamSeasonCreateManyInput = {
    teamId: number
    seasonId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamSeasonUpdateManyMutationInput = {
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamSeasonUncheckedUpdateManyInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberCreateInput = {
    user: UserCreateNestedOneWithoutTeamsInput
    team: TeamCreateNestedOneWithoutMembersInput
    season: SeasonCreateNestedOneWithoutPlayersInput
  }

  export type TeamMemberUncheckedCreateInput = {
    userId: string
    teamId: number
    seasonId: number
  }

  export type TeamMemberUpdateInput = {
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    season?: SeasonUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberCreateManyInput = {
    userId: string
    teamId: number
    seasonId: number
  }

  export type TeamMemberUpdateManyMutationInput = {

  }

  export type TeamMemberUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message?: string | null
    severity: $Enums.NotificationSeverity
    showFrom: Date | string
    showTo: Date | string
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    message?: string | null
    severity: $Enums.NotificationSeverity
    showFrom: Date | string
    showTo: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumNotificationSeverityFieldUpdateOperationsInput | $Enums.NotificationSeverity
    showFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    showTo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumNotificationSeverityFieldUpdateOperationsInput | $Enums.NotificationSeverity
    showFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    showTo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    message?: string | null
    severity: $Enums.NotificationSeverity
    showFrom: Date | string
    showTo: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumNotificationSeverityFieldUpdateOperationsInput | $Enums.NotificationSeverity
    showFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    showTo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    severity?: EnumNotificationSeverityFieldUpdateOperationsInput | $Enums.NotificationSeverity
    showFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    showTo?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BenefitCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    cover?: boolean
    link?: string | null
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
  }

  export type BenefitUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    cover?: boolean
    link?: string | null
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
  }

  export type BenefitUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    cover?: boolean
    link?: string | null
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
  }

  export type BenefitUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BenefitUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    cover?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ControlInterfaceCreateInput = {
    id?: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd?: boolean
    connectByOr?: boolean
    affectedCourts?: CourtCreateNestedManyWithoutControlInterfacesInput
  }

  export type ControlInterfaceUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd?: boolean
    connectByOr?: boolean
    affectedCourts?: CourtUncheckedCreateNestedManyWithoutControlInterfacesInput
  }

  export type ControlInterfaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
    affectedCourts?: CourtUpdateManyWithoutControlInterfacesNestedInput
  }

  export type ControlInterfaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
    affectedCourts?: CourtUncheckedUpdateManyWithoutControlInterfacesNestedInput
  }

  export type ControlInterfaceCreateManyInput = {
    id?: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd?: boolean
    connectByOr?: boolean
  }

  export type ControlInterfaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ControlInterfaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OrganisationCreateInput = {
    id?: string
    slug: string
    title: string
    members?: OrganisationMemberCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    members?: OrganisationMemberUncheckedCreateNestedManyWithoutOrganisationInput
  }

  export type OrganisationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    members?: OrganisationMemberUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    members?: OrganisationMemberUncheckedUpdateManyWithoutOrganisationNestedInput
  }

  export type OrganisationCreateManyInput = {
    id?: string
    slug: string
    title: string
  }

  export type OrganisationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganisationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganisationMemberCreateInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisation: OrganisationCreateNestedOneWithoutMembersInput
    parentMember?: OrganisationMemberCreateNestedOneWithoutChildMembersInput
    childMembers?: OrganisationMemberCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberUncheckedCreateInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisationId: string
    parentMemberId?: string | null
    childMembers?: OrganisationMemberUncheckedCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisation?: OrganisationUpdateOneRequiredWithoutMembersNestedInput
    parentMember?: OrganisationMemberUpdateOneWithoutChildMembersNestedInput
    childMembers?: OrganisationMemberUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: StringFieldUpdateOperationsInput | string
    parentMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    childMembers?: OrganisationMemberUncheckedUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberCreateManyInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisationId: string
    parentMemberId?: string | null
  }

  export type OrganisationMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrganisationMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: StringFieldUpdateOperationsInput | string
    parentMemberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventCategoryCreateInput = {
    id?: string
    slug: string
    title: string
    events?: EventCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateInput = {
    id?: string
    slug: string
    title: string
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    events?: EventUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryCreateManyInput = {
    id?: string
    slug: string
    title: string
  }

  export type EventCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type EventCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    category: EventCategoryCreateNestedOneWithoutEventsInput
    likedByUsers?: UserCreateNestedManyWithoutLikedEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    categoryId: string
    likedByUsers?: UserUncheckedCreateNestedManyWithoutLikedEventsInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    likedByUsers?: UserUpdateManyWithoutLikedEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
    likedByUsers?: UserUncheckedUpdateManyWithoutLikedEventsNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    categoryId: string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AbonnementListRelationFilter = {
    every?: AbonnementWhereInput
    some?: AbonnementWhereInput
    none?: AbonnementWhereInput
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamSeasonListRelationFilter = {
    every?: TeamSeasonWhereInput
    some?: TeamSeasonWhereInput
    none?: TeamSeasonWhereInput
  }

  export type UserRoleListRelationFilter = {
    every?: UserRoleWhereInput
    some?: UserRoleWhereInput
    none?: UserRoleWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AbonnementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamSeasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    auth0Id?: SortOrder
    address?: SortOrder
    cityCode?: SortOrder
    cityName?: SortOrder
    countryCode?: SortOrder
    needsSetup?: SortOrder
    publicName?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    auth0Id?: SortOrder
    address?: SortOrder
    cityCode?: SortOrder
    cityName?: SortOrder
    countryCode?: SortOrder
    needsSetup?: SortOrder
    publicName?: SortOrder
    phoneNumber?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    image?: SortOrder
    auth0Id?: SortOrder
    address?: SortOrder
    cityCode?: SortOrder
    cityName?: SortOrder
    countryCode?: SortOrder
    needsSetup?: SortOrder
    publicName?: SortOrder
    phoneNumber?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CourtListRelationFilter = {
    every?: CourtWhereInput
    some?: CourtWhereInput
    none?: CourtWhereInput
  }

  export type ReservationRuleListRelationFilter = {
    every?: ReservationRuleWhereInput
    some?: ReservationRuleWhereInput
    none?: ReservationRuleWhereInput
  }

  export type PriceListRelationFilter = {
    every?: PriceWhereInput
    some?: PriceWhereInput
    none?: PriceWhereInput
  }

  export type CourtOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PriceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreaCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    bookableFrom?: SortOrder
    order?: SortOrder
  }

  export type AreaAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type AreaMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    bookableFrom?: SortOrder
    order?: SortOrder
  }

  export type AreaMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    bookableFrom?: SortOrder
    order?: SortOrder
  }

  export type AreaSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AreaRelationFilter = {
    is?: AreaWhereInput
    isNot?: AreaWhereInput
  }

  export type ControlInterfaceListRelationFilter = {
    every?: ControlInterfaceWhereInput
    some?: ControlInterfaceWhereInput
    none?: ControlInterfaceWhereInput
  }

  export type ControlInterfaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourtCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    areaId?: SortOrder
  }

  export type CourtAvgOrderByAggregateInput = {
    order?: SortOrder
    areaId?: SortOrder
  }

  export type CourtMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    areaId?: SortOrder
  }

  export type CourtMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
    areaId?: SortOrder
  }

  export type CourtSumOrderByAggregateInput = {
    order?: SortOrder
    areaId?: SortOrder
  }

  export type EnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[]
    notIn?: $Enums.ReservationStatus[]
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type EnumReservationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationType | EnumReservationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReservationType[] | null
    notIn?: $Enums.ReservationType[] | null
    not?: NestedEnumReservationTypeNullableFilter<$PrismaModel> | $Enums.ReservationType | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CourtNullableRelationFilter = {
    is?: CourtWhereInput | null
    isNot?: CourtWhereInput | null
  }

  export type AbonnementNullableRelationFilter = {
    is?: AbonnementWhereInput | null
    isNot?: AbonnementWhereInput | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paypalTransactionId?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    light?: SortOrder
    radiator?: SortOrder
    abonnementId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    price?: SortOrder
    taxRate?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paypalTransactionId?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    light?: SortOrder
    radiator?: SortOrder
    abonnementId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    start?: SortOrder
    end?: SortOrder
    courtId?: SortOrder
    status?: SortOrder
    type?: SortOrder
    paypalTransactionId?: SortOrder
    price?: SortOrder
    taxRate?: SortOrder
    light?: SortOrder
    radiator?: SortOrder
    abonnementId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    price?: SortOrder
    taxRate?: SortOrder
  }

  export type EnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[]
    notIn?: $Enums.ReservationStatus[]
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type EnumReservationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationType | EnumReservationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReservationType[] | null
    notIn?: $Enums.ReservationType[] | null
    not?: NestedEnumReservationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReservationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReservationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReservationTypeNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumReservationRuleCheckOnFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationRuleCheckOn | EnumReservationRuleCheckOnFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationRuleCheckOn[]
    notIn?: $Enums.ReservationRuleCheckOn[]
    not?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel> | $Enums.ReservationRuleCheckOn
  }

  export type AreaListRelationFilter = {
    every?: AreaWhereInput
    some?: AreaWhereInput
    none?: AreaWhereInput
  }

  export type AreaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    errorDescription?: SortOrder
    checkOn?: SortOrder
    ruleCheckPluginName?: SortOrder
    value?: SortOrder
  }

  export type ReservationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    errorDescription?: SortOrder
    checkOn?: SortOrder
    ruleCheckPluginName?: SortOrder
    value?: SortOrder
  }

  export type ReservationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    errorDescription?: SortOrder
    checkOn?: SortOrder
    ruleCheckPluginName?: SortOrder
    value?: SortOrder
  }

  export type EnumReservationRuleCheckOnWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationRuleCheckOn | EnumReservationRuleCheckOnFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationRuleCheckOn[]
    notIn?: $Enums.ReservationRuleCheckOn[]
    not?: NestedEnumReservationRuleCheckOnWithAggregatesFilter<$PrismaModel> | $Enums.ReservationRuleCheckOn
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel>
    _max?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumAbonnementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AbonnementStatus | EnumAbonnementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbonnementStatus[]
    notIn?: $Enums.AbonnementStatus[]
    not?: NestedEnumAbonnementStatusFilter<$PrismaModel> | $Enums.AbonnementStatus
  }

  export type AbonnementCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekday?: SortOrder
    start?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    courtId?: SortOrder
    ownerId?: SortOrder
  }

  export type AbonnementAvgOrderByAggregateInput = {
    weekday?: SortOrder
    duration?: SortOrder
  }

  export type AbonnementMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekday?: SortOrder
    start?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    courtId?: SortOrder
    ownerId?: SortOrder
  }

  export type AbonnementMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    weekday?: SortOrder
    start?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    courtId?: SortOrder
    ownerId?: SortOrder
  }

  export type AbonnementSumOrderByAggregateInput = {
    weekday?: SortOrder
    duration?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumAbonnementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbonnementStatus | EnumAbonnementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbonnementStatus[]
    notIn?: $Enums.AbonnementStatus[]
    not?: NestedEnumAbonnementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AbonnementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbonnementStatusFilter<$PrismaModel>
    _max?: NestedEnumAbonnementStatusFilter<$PrismaModel>
  }

  export type PermissionListRelationFilter = {
    every?: PermissionWhereInput
    some?: PermissionWhereInput
    none?: PermissionWhereInput
  }

  export type PermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserRoleCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    priority?: SortOrder
  }

  export type UserRoleAvgOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type UserRoleMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    priority?: SortOrder
  }

  export type UserRoleMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    isDefault?: SortOrder
    priority?: SortOrder
  }

  export type UserRoleSumOrderByAggregateInput = {
    id?: SortOrder
    priority?: SortOrder
  }

  export type EnumPermissionStateFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionState | EnumPermissionStateFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionState[]
    notIn?: $Enums.PermissionState[]
    not?: NestedEnumPermissionStateFilter<$PrismaModel> | $Enums.PermissionState
  }

  export type UserRoleRelationFilter = {
    is?: UserRoleWhereInput
    isNot?: UserRoleWhereInput
  }

  export type PermissionRouterActionUserRoleIdCompoundUniqueInput = {
    router: string
    action: string
    userRoleId: number
  }

  export type PermissionCountOrderByAggregateInput = {
    router?: SortOrder
    action?: SortOrder
    userRoleId?: SortOrder
    allowed?: SortOrder
  }

  export type PermissionAvgOrderByAggregateInput = {
    userRoleId?: SortOrder
  }

  export type PermissionMaxOrderByAggregateInput = {
    router?: SortOrder
    action?: SortOrder
    userRoleId?: SortOrder
    allowed?: SortOrder
  }

  export type PermissionMinOrderByAggregateInput = {
    router?: SortOrder
    action?: SortOrder
    userRoleId?: SortOrder
    allowed?: SortOrder
  }

  export type PermissionSumOrderByAggregateInput = {
    userRoleId?: SortOrder
  }

  export type EnumPermissionStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionState | EnumPermissionStateFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionState[]
    notIn?: $Enums.PermissionState[]
    not?: NestedEnumPermissionStateWithAggregatesFilter<$PrismaModel> | $Enums.PermissionState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionStateFilter<$PrismaModel>
    _max?: NestedEnumPermissionStateFilter<$PrismaModel>
  }

  export type TransactionNullableRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type HallencardCountOrderByAggregateInput = {
    code?: SortOrder
    pin?: SortOrder
    value?: SortOrder
    printed?: SortOrder
    transactionId?: SortOrder
  }

  export type HallencardAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type HallencardMaxOrderByAggregateInput = {
    code?: SortOrder
    pin?: SortOrder
    value?: SortOrder
    printed?: SortOrder
    transactionId?: SortOrder
  }

  export type HallencardMinOrderByAggregateInput = {
    code?: SortOrder
    pin?: SortOrder
    value?: SortOrder
    printed?: SortOrder
    transactionId?: SortOrder
  }

  export type HallencardSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type PriceCountOrderByAggregateInput = {
    id?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isDefault?: SortOrder
    mon?: SortOrder
    tue?: SortOrder
    wed?: SortOrder
    thu?: SortOrder
    fri?: SortOrder
    sat?: SortOrder
    sun?: SortOrder
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    taxes?: SortOrder
  }

  export type PriceAvgOrderByAggregateInput = {
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    taxes?: SortOrder
  }

  export type PriceMaxOrderByAggregateInput = {
    id?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isDefault?: SortOrder
    mon?: SortOrder
    tue?: SortOrder
    wed?: SortOrder
    thu?: SortOrder
    fri?: SortOrder
    sat?: SortOrder
    sun?: SortOrder
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    taxes?: SortOrder
  }

  export type PriceMinOrderByAggregateInput = {
    id?: SortOrder
    validFrom?: SortOrder
    validTo?: SortOrder
    isDefault?: SortOrder
    mon?: SortOrder
    tue?: SortOrder
    wed?: SortOrder
    thu?: SortOrder
    fri?: SortOrder
    sat?: SortOrder
    sun?: SortOrder
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    taxes?: SortOrder
  }

  export type PriceSumOrderByAggregateInput = {
    from?: SortOrder
    to?: SortOrder
    value?: SortOrder
    taxes?: SortOrder
  }

  export type EnumTransactionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReason | EnumTransactionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReason[]
    notIn?: $Enums.TransactionReason[]
    not?: NestedEnumTransactionReasonFilter<$PrismaModel> | $Enums.TransactionReason
  }

  export type HallencardNullableRelationFilter = {
    is?: HallencardWhereInput | null
    isNot?: HallencardWhereInput | null
  }

  export type ReservationNullableRelationFilter = {
    is?: ReservationWhereInput | null
    isNot?: ReservationWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    paymentInformation?: SortOrder
    reservationId?: SortOrder
    abonnementId?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    paymentInformation?: SortOrder
    reservationId?: SortOrder
    abonnementId?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    value?: SortOrder
    currency?: SortOrder
    reason?: SortOrder
    paymentInformation?: SortOrder
    reservationId?: SortOrder
    abonnementId?: SortOrder
    createdAt?: SortOrder
    deleted?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumTransactionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReason | EnumTransactionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReason[]
    notIn?: $Enums.TransactionReason[]
    not?: NestedEnumTransactionReasonWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReasonFilter<$PrismaModel>
    _max?: NestedEnumTransactionReasonFilter<$PrismaModel>
  }

  export type SeasonCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    starting?: SortOrder
    ending?: SortOrder
    current?: SortOrder
  }

  export type SeasonAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeasonMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    starting?: SortOrder
    ending?: SortOrder
    current?: SortOrder
  }

  export type SeasonMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    starting?: SortOrder
    ending?: SortOrder
    current?: SortOrder
  }

  export type SeasonSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTeamCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamCategory | EnumTeamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeamCategory[]
    notIn?: $Enums.TeamCategory[]
    not?: NestedEnumTeamCategoryFilter<$PrismaModel> | $Enums.TeamCategory
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    orderNumber?: SortOrder
  }

  export type TeamAvgOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    orderNumber?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    shortName?: SortOrder
    category?: SortOrder
    orderNumber?: SortOrder
  }

  export type TeamSumOrderByAggregateInput = {
    id?: SortOrder
    orderNumber?: SortOrder
  }

  export type EnumTeamCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamCategory | EnumTeamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeamCategory[]
    notIn?: $Enums.TeamCategory[]
    not?: NestedEnumTeamCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TeamCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamCategoryFilter<$PrismaModel>
    _max?: NestedEnumTeamCategoryFilter<$PrismaModel>
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type SeasonRelationFilter = {
    is?: SeasonWhereInput
    isNot?: SeasonWhereInput
  }

  export type TeamSeasonTeamIdSeasonIdCompoundUniqueInput = {
    teamId: number
    seasonId: number
  }

  export type TeamSeasonCountOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
    teamLeaderId?: SortOrder
    nuGroupId?: SortOrder
    nuTeamId?: SortOrder
    leagueName?: SortOrder
  }

  export type TeamSeasonAvgOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamSeasonMaxOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
    teamLeaderId?: SortOrder
    nuGroupId?: SortOrder
    nuTeamId?: SortOrder
    leagueName?: SortOrder
  }

  export type TeamSeasonMinOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
    teamLeaderId?: SortOrder
    nuGroupId?: SortOrder
    nuTeamId?: SortOrder
    leagueName?: SortOrder
  }

  export type TeamSeasonSumOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamMemberUserIdTeamIdSeasonIdCompoundUniqueInput = {
    userId: string
    teamId: number
    seasonId: number
  }

  export type TeamMemberCountOrderByAggregateInput = {
    userId?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamMemberAvgOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    userId?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    userId?: SortOrder
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type TeamMemberSumOrderByAggregateInput = {
    teamId?: SortOrder
    seasonId?: SortOrder
  }

  export type EnumNotificationSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationSeverity | EnumNotificationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationSeverity[]
    notIn?: $Enums.NotificationSeverity[]
    not?: NestedEnumNotificationSeverityFilter<$PrismaModel> | $Enums.NotificationSeverity
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    showFrom?: SortOrder
    showTo?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    showFrom?: SortOrder
    showTo?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    severity?: SortOrder
    showFrom?: SortOrder
    showTo?: SortOrder
  }

  export type EnumNotificationSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationSeverity | EnumNotificationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationSeverity[]
    notIn?: $Enums.NotificationSeverity[]
    not?: NestedEnumNotificationSeverityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationSeverityFilter<$PrismaModel>
    _max?: NestedEnumNotificationSeverityFilter<$PrismaModel>
  }

  export type BenefitCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover?: SortOrder
    link?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
  }

  export type BenefitMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover?: SortOrder
    link?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
  }

  export type BenefitMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    cover?: SortOrder
    link?: SortOrder
    activeFrom?: SortOrder
    activeTo?: SortOrder
  }

  export type ControlInterfaceCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preBooking?: SortOrder
    postBooking?: SortOrder
    connectByAnd?: SortOrder
    connectByOr?: SortOrder
  }

  export type ControlInterfaceAvgOrderByAggregateInput = {
    preBooking?: SortOrder
    postBooking?: SortOrder
  }

  export type ControlInterfaceMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preBooking?: SortOrder
    postBooking?: SortOrder
    connectByAnd?: SortOrder
    connectByOr?: SortOrder
  }

  export type ControlInterfaceMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    preBooking?: SortOrder
    postBooking?: SortOrder
    connectByAnd?: SortOrder
    connectByOr?: SortOrder
  }

  export type ControlInterfaceSumOrderByAggregateInput = {
    preBooking?: SortOrder
    postBooking?: SortOrder
  }

  export type OrganisationMemberListRelationFilter = {
    every?: OrganisationMemberWhereInput
    some?: OrganisationMemberWhereInput
    none?: OrganisationMemberWhereInput
  }

  export type OrganisationMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrganisationCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type OrganisationMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type OrganisationMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type OrganisationRelationFilter = {
    is?: OrganisationWhereInput
    isNot?: OrganisationWhereInput
  }

  export type OrganisationMemberNullableRelationFilter = {
    is?: OrganisationMemberWhereInput | null
    isNot?: OrganisationMemberWhereInput | null
  }

  export type OrganisationMemberCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    function?: SortOrder
    image?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    orderID?: SortOrder
    organisationId?: SortOrder
    parentMemberId?: SortOrder
  }

  export type OrganisationMemberAvgOrderByAggregateInput = {
    orderID?: SortOrder
  }

  export type OrganisationMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    function?: SortOrder
    image?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    orderID?: SortOrder
    organisationId?: SortOrder
    parentMemberId?: SortOrder
  }

  export type OrganisationMemberMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    function?: SortOrder
    image?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    orderID?: SortOrder
    organisationId?: SortOrder
    parentMemberId?: SortOrder
  }

  export type OrganisationMemberSumOrderByAggregateInput = {
    orderID?: SortOrder
  }

  export type EventCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type EventCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type EventCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
  }

  export type EventCategoryRelationFilter = {
    is?: EventCategoryWhereInput
    isNot?: EventCategoryWhereInput
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    start?: SortOrder
    end?: SortOrder
    canceled?: SortOrder
    revised?: SortOrder
    link?: SortOrder
    location?: SortOrder
    categoryId?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    start?: SortOrder
    end?: SortOrder
    canceled?: SortOrder
    revised?: SortOrder
    link?: SortOrder
    location?: SortOrder
    categoryId?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    image?: SortOrder
    start?: SortOrder
    end?: SortOrder
    canceled?: SortOrder
    revised?: SortOrder
    link?: SortOrder
    location?: SortOrder
    categoryId?: SortOrder
  }

  export type AbonnementCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput> | AbonnementCreateWithoutOwnerInput[] | AbonnementUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutOwnerInput | AbonnementCreateOrConnectWithoutOwnerInput[]
    createMany?: AbonnementCreateManyOwnerInputEnvelope
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput> | ReservationCreateWithoutOwnerInput[] | ReservationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutOwnerInput | ReservationCreateOrConnectWithoutOwnerInput[]
    createMany?: ReservationCreateManyOwnerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutFellowsInput = {
    create?: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput> | ReservationCreateWithoutFellowsInput[] | ReservationUncheckedCreateWithoutFellowsInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFellowsInput | ReservationCreateOrConnectWithoutFellowsInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamSeasonCreateNestedManyWithoutTeamLeaderInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput> | TeamSeasonCreateWithoutTeamLeaderInput[] | TeamSeasonUncheckedCreateWithoutTeamLeaderInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamLeaderInput | TeamSeasonCreateOrConnectWithoutTeamLeaderInput[]
    createMany?: TeamSeasonCreateManyTeamLeaderInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type UserRoleCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput> | UserRoleCreateWithoutUsersInput[] | UserRoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput | UserRoleCreateOrConnectWithoutUsersInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutLikedByUsersInput = {
    create?: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput> | EventCreateWithoutLikedByUsersInput[] | EventUncheckedCreateWithoutLikedByUsersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLikedByUsersInput | EventCreateOrConnectWithoutLikedByUsersInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type AbonnementUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput> | AbonnementCreateWithoutOwnerInput[] | AbonnementUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutOwnerInput | AbonnementCreateOrConnectWithoutOwnerInput[]
    createMany?: AbonnementCreateManyOwnerInputEnvelope
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput> | ReservationCreateWithoutOwnerInput[] | ReservationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutOwnerInput | ReservationCreateOrConnectWithoutOwnerInput[]
    createMany?: ReservationCreateManyOwnerInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutFellowsInput = {
    create?: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput> | ReservationCreateWithoutFellowsInput[] | ReservationUncheckedCreateWithoutFellowsInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFellowsInput | ReservationCreateOrConnectWithoutFellowsInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput> | TeamSeasonCreateWithoutTeamLeaderInput[] | TeamSeasonUncheckedCreateWithoutTeamLeaderInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamLeaderInput | TeamSeasonCreateOrConnectWithoutTeamLeaderInput[]
    createMany?: TeamSeasonCreateManyTeamLeaderInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput> | UserRoleCreateWithoutUsersInput[] | UserRoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput | UserRoleCreateOrConnectWithoutUsersInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutLikedByUsersInput = {
    create?: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput> | EventCreateWithoutLikedByUsersInput[] | EventUncheckedCreateWithoutLikedByUsersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLikedByUsersInput | EventCreateOrConnectWithoutLikedByUsersInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AbonnementUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput> | AbonnementCreateWithoutOwnerInput[] | AbonnementUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutOwnerInput | AbonnementCreateOrConnectWithoutOwnerInput[]
    upsert?: AbonnementUpsertWithWhereUniqueWithoutOwnerInput | AbonnementUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AbonnementCreateManyOwnerInputEnvelope
    set?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    disconnect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    delete?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    update?: AbonnementUpdateWithWhereUniqueWithoutOwnerInput | AbonnementUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AbonnementUpdateManyWithWhereWithoutOwnerInput | AbonnementUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput> | ReservationCreateWithoutOwnerInput[] | ReservationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutOwnerInput | ReservationCreateOrConnectWithoutOwnerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutOwnerInput | ReservationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ReservationCreateManyOwnerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutOwnerInput | ReservationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutOwnerInput | ReservationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutFellowsNestedInput = {
    create?: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput> | ReservationCreateWithoutFellowsInput[] | ReservationUncheckedCreateWithoutFellowsInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFellowsInput | ReservationCreateOrConnectWithoutFellowsInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFellowsInput | ReservationUpsertWithWhereUniqueWithoutFellowsInput[]
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFellowsInput | ReservationUpdateWithWhereUniqueWithoutFellowsInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFellowsInput | ReservationUpdateManyWithWhereWithoutFellowsInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamSeasonUpdateManyWithoutTeamLeaderNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput> | TeamSeasonCreateWithoutTeamLeaderInput[] | TeamSeasonUncheckedCreateWithoutTeamLeaderInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamLeaderInput | TeamSeasonCreateOrConnectWithoutTeamLeaderInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutTeamLeaderInput | TeamSeasonUpsertWithWhereUniqueWithoutTeamLeaderInput[]
    createMany?: TeamSeasonCreateManyTeamLeaderInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutTeamLeaderInput | TeamSeasonUpdateWithWhereUniqueWithoutTeamLeaderInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutTeamLeaderInput | TeamSeasonUpdateManyWithWhereWithoutTeamLeaderInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type UserRoleUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput> | UserRoleCreateWithoutUsersInput[] | UserRoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput | UserRoleCreateOrConnectWithoutUsersInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUsersInput | UserRoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUsersInput | UserRoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUsersInput | UserRoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type EventUpdateManyWithoutLikedByUsersNestedInput = {
    create?: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput> | EventCreateWithoutLikedByUsersInput[] | EventUncheckedCreateWithoutLikedByUsersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLikedByUsersInput | EventCreateOrConnectWithoutLikedByUsersInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLikedByUsersInput | EventUpsertWithWhereUniqueWithoutLikedByUsersInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLikedByUsersInput | EventUpdateWithWhereUniqueWithoutLikedByUsersInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLikedByUsersInput | EventUpdateManyWithWhereWithoutLikedByUsersInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type AbonnementUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput> | AbonnementCreateWithoutOwnerInput[] | AbonnementUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutOwnerInput | AbonnementCreateOrConnectWithoutOwnerInput[]
    upsert?: AbonnementUpsertWithWhereUniqueWithoutOwnerInput | AbonnementUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AbonnementCreateManyOwnerInputEnvelope
    set?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    disconnect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    delete?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    update?: AbonnementUpdateWithWhereUniqueWithoutOwnerInput | AbonnementUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AbonnementUpdateManyWithWhereWithoutOwnerInput | AbonnementUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput> | ReservationCreateWithoutOwnerInput[] | ReservationUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutOwnerInput | ReservationCreateOrConnectWithoutOwnerInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutOwnerInput | ReservationUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ReservationCreateManyOwnerInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutOwnerInput | ReservationUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutOwnerInput | ReservationUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutFellowsNestedInput = {
    create?: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput> | ReservationCreateWithoutFellowsInput[] | ReservationUncheckedCreateWithoutFellowsInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutFellowsInput | ReservationCreateOrConnectWithoutFellowsInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutFellowsInput | ReservationUpsertWithWhereUniqueWithoutFellowsInput[]
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutFellowsInput | ReservationUpdateWithWhereUniqueWithoutFellowsInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutFellowsInput | ReservationUpdateManyWithWhereWithoutFellowsInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput> | TransactionCreateWithoutUserInput[] | TransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutUserInput | TransactionCreateOrConnectWithoutUserInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutUserInput | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TransactionCreateManyUserInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutUserInput | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutUserInput | TransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput> | TeamSeasonCreateWithoutTeamLeaderInput[] | TeamSeasonUncheckedCreateWithoutTeamLeaderInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamLeaderInput | TeamSeasonCreateOrConnectWithoutTeamLeaderInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutTeamLeaderInput | TeamSeasonUpsertWithWhereUniqueWithoutTeamLeaderInput[]
    createMany?: TeamSeasonCreateManyTeamLeaderInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutTeamLeaderInput | TeamSeasonUpdateWithWhereUniqueWithoutTeamLeaderInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutTeamLeaderInput | TeamSeasonUpdateManyWithWhereWithoutTeamLeaderInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput> | UserRoleCreateWithoutUsersInput[] | UserRoleUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutUsersInput | UserRoleCreateOrConnectWithoutUsersInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutUsersInput | UserRoleUpsertWithWhereUniqueWithoutUsersInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutUsersInput | UserRoleUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutUsersInput | UserRoleUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutLikedByUsersNestedInput = {
    create?: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput> | EventCreateWithoutLikedByUsersInput[] | EventUncheckedCreateWithoutLikedByUsersInput[]
    connectOrCreate?: EventCreateOrConnectWithoutLikedByUsersInput | EventCreateOrConnectWithoutLikedByUsersInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutLikedByUsersInput | EventUpsertWithWhereUniqueWithoutLikedByUsersInput[]
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutLikedByUsersInput | EventUpdateWithWhereUniqueWithoutLikedByUsersInput[]
    updateMany?: EventUpdateManyWithWhereWithoutLikedByUsersInput | EventUpdateManyWithWhereWithoutLikedByUsersInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CourtCreateNestedManyWithoutAreaInput = {
    create?: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput> | CourtCreateWithoutAreaInput[] | CourtUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutAreaInput | CourtCreateOrConnectWithoutAreaInput[]
    createMany?: CourtCreateManyAreaInputEnvelope
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type ReservationRuleCreateNestedManyWithoutAffectedAreasInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput> | ReservationRuleCreateWithoutAffectedAreasInput[] | ReservationRuleUncheckedCreateWithoutAffectedAreasInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedAreasInput | ReservationRuleCreateOrConnectWithoutAffectedAreasInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type PriceCreateNestedManyWithoutAreasInput = {
    create?: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput> | PriceCreateWithoutAreasInput[] | PriceUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutAreasInput | PriceCreateOrConnectWithoutAreasInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type CourtUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput> | CourtCreateWithoutAreaInput[] | CourtUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutAreaInput | CourtCreateOrConnectWithoutAreaInput[]
    createMany?: CourtCreateManyAreaInputEnvelope
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type ReservationRuleUncheckedCreateNestedManyWithoutAffectedAreasInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput> | ReservationRuleCreateWithoutAffectedAreasInput[] | ReservationRuleUncheckedCreateWithoutAffectedAreasInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedAreasInput | ReservationRuleCreateOrConnectWithoutAffectedAreasInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type PriceUncheckedCreateNestedManyWithoutAreasInput = {
    create?: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput> | PriceCreateWithoutAreasInput[] | PriceUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutAreasInput | PriceCreateOrConnectWithoutAreasInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourtUpdateManyWithoutAreaNestedInput = {
    create?: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput> | CourtCreateWithoutAreaInput[] | CourtUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutAreaInput | CourtCreateOrConnectWithoutAreaInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutAreaInput | CourtUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: CourtCreateManyAreaInputEnvelope
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutAreaInput | CourtUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutAreaInput | CourtUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type ReservationRuleUpdateManyWithoutAffectedAreasNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput> | ReservationRuleCreateWithoutAffectedAreasInput[] | ReservationRuleUncheckedCreateWithoutAffectedAreasInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedAreasInput | ReservationRuleCreateOrConnectWithoutAffectedAreasInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutAffectedAreasInput | ReservationRuleUpsertWithWhereUniqueWithoutAffectedAreasInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutAffectedAreasInput | ReservationRuleUpdateWithWhereUniqueWithoutAffectedAreasInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutAffectedAreasInput | ReservationRuleUpdateManyWithWhereWithoutAffectedAreasInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type PriceUpdateManyWithoutAreasNestedInput = {
    create?: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput> | PriceCreateWithoutAreasInput[] | PriceUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutAreasInput | PriceCreateOrConnectWithoutAreasInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutAreasInput | PriceUpsertWithWhereUniqueWithoutAreasInput[]
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutAreasInput | PriceUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutAreasInput | PriceUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourtUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput> | CourtCreateWithoutAreaInput[] | CourtUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutAreaInput | CourtCreateOrConnectWithoutAreaInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutAreaInput | CourtUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: CourtCreateManyAreaInputEnvelope
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutAreaInput | CourtUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutAreaInput | CourtUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type ReservationRuleUncheckedUpdateManyWithoutAffectedAreasNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput> | ReservationRuleCreateWithoutAffectedAreasInput[] | ReservationRuleUncheckedCreateWithoutAffectedAreasInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedAreasInput | ReservationRuleCreateOrConnectWithoutAffectedAreasInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutAffectedAreasInput | ReservationRuleUpsertWithWhereUniqueWithoutAffectedAreasInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutAffectedAreasInput | ReservationRuleUpdateWithWhereUniqueWithoutAffectedAreasInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutAffectedAreasInput | ReservationRuleUpdateManyWithWhereWithoutAffectedAreasInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type PriceUncheckedUpdateManyWithoutAreasNestedInput = {
    create?: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput> | PriceCreateWithoutAreasInput[] | PriceUncheckedCreateWithoutAreasInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutAreasInput | PriceCreateOrConnectWithoutAreasInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutAreasInput | PriceUpsertWithWhereUniqueWithoutAreasInput[]
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutAreasInput | PriceUpdateWithWhereUniqueWithoutAreasInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutAreasInput | PriceUpdateManyWithWhereWithoutAreasInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type AreaCreateNestedOneWithoutCourtsInput = {
    create?: XOR<AreaCreateWithoutCourtsInput, AreaUncheckedCreateWithoutCourtsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutCourtsInput
    connect?: AreaWhereUniqueInput
  }

  export type AbonnementCreateNestedManyWithoutCourtInput = {
    create?: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput> | AbonnementCreateWithoutCourtInput[] | AbonnementUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutCourtInput | AbonnementCreateOrConnectWithoutCourtInput[]
    createMany?: AbonnementCreateManyCourtInputEnvelope
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutCourtInput = {
    create?: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput> | ReservationCreateWithoutCourtInput[] | ReservationUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCourtInput | ReservationCreateOrConnectWithoutCourtInput[]
    createMany?: ReservationCreateManyCourtInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationRuleCreateNestedManyWithoutAffectedCourtsInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput> | ReservationRuleCreateWithoutAffectedCourtsInput[] | ReservationRuleUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedCourtsInput | ReservationRuleCreateOrConnectWithoutAffectedCourtsInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput = {
    create?: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput> | ControlInterfaceCreateWithoutAffectedCourtsInput[] | ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput | ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput[]
    connect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
  }

  export type AbonnementUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput> | AbonnementCreateWithoutCourtInput[] | AbonnementUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutCourtInput | AbonnementCreateOrConnectWithoutCourtInput[]
    createMany?: AbonnementCreateManyCourtInputEnvelope
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutCourtInput = {
    create?: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput> | ReservationCreateWithoutCourtInput[] | ReservationUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCourtInput | ReservationCreateOrConnectWithoutCourtInput[]
    createMany?: ReservationCreateManyCourtInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput> | ReservationRuleCreateWithoutAffectedCourtsInput[] | ReservationRuleUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedCourtsInput | ReservationRuleCreateOrConnectWithoutAffectedCourtsInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput = {
    create?: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput> | ControlInterfaceCreateWithoutAffectedCourtsInput[] | ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput | ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput[]
    connect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
  }

  export type AreaUpdateOneRequiredWithoutCourtsNestedInput = {
    create?: XOR<AreaCreateWithoutCourtsInput, AreaUncheckedCreateWithoutCourtsInput>
    connectOrCreate?: AreaCreateOrConnectWithoutCourtsInput
    upsert?: AreaUpsertWithoutCourtsInput
    connect?: AreaWhereUniqueInput
    update?: XOR<XOR<AreaUpdateToOneWithWhereWithoutCourtsInput, AreaUpdateWithoutCourtsInput>, AreaUncheckedUpdateWithoutCourtsInput>
  }

  export type AbonnementUpdateManyWithoutCourtNestedInput = {
    create?: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput> | AbonnementCreateWithoutCourtInput[] | AbonnementUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutCourtInput | AbonnementCreateOrConnectWithoutCourtInput[]
    upsert?: AbonnementUpsertWithWhereUniqueWithoutCourtInput | AbonnementUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: AbonnementCreateManyCourtInputEnvelope
    set?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    disconnect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    delete?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    update?: AbonnementUpdateWithWhereUniqueWithoutCourtInput | AbonnementUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: AbonnementUpdateManyWithWhereWithoutCourtInput | AbonnementUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutCourtNestedInput = {
    create?: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput> | ReservationCreateWithoutCourtInput[] | ReservationUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCourtInput | ReservationCreateOrConnectWithoutCourtInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutCourtInput | ReservationUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: ReservationCreateManyCourtInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutCourtInput | ReservationUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutCourtInput | ReservationUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput> | ReservationRuleCreateWithoutAffectedCourtsInput[] | ReservationRuleUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedCourtsInput | ReservationRuleCreateOrConnectWithoutAffectedCourtsInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutAffectedCourtsInput | ReservationRuleUpsertWithWhereUniqueWithoutAffectedCourtsInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutAffectedCourtsInput | ReservationRuleUpdateWithWhereUniqueWithoutAffectedCourtsInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutAffectedCourtsInput | ReservationRuleUpdateManyWithWhereWithoutAffectedCourtsInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput = {
    create?: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput> | ControlInterfaceCreateWithoutAffectedCourtsInput[] | ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput | ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput[]
    upsert?: ControlInterfaceUpsertWithWhereUniqueWithoutAffectedCourtsInput | ControlInterfaceUpsertWithWhereUniqueWithoutAffectedCourtsInput[]
    set?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    disconnect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    delete?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    connect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    update?: ControlInterfaceUpdateWithWhereUniqueWithoutAffectedCourtsInput | ControlInterfaceUpdateWithWhereUniqueWithoutAffectedCourtsInput[]
    updateMany?: ControlInterfaceUpdateManyWithWhereWithoutAffectedCourtsInput | ControlInterfaceUpdateManyWithWhereWithoutAffectedCourtsInput[]
    deleteMany?: ControlInterfaceScalarWhereInput | ControlInterfaceScalarWhereInput[]
  }

  export type AbonnementUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput> | AbonnementCreateWithoutCourtInput[] | AbonnementUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: AbonnementCreateOrConnectWithoutCourtInput | AbonnementCreateOrConnectWithoutCourtInput[]
    upsert?: AbonnementUpsertWithWhereUniqueWithoutCourtInput | AbonnementUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: AbonnementCreateManyCourtInputEnvelope
    set?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    disconnect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    delete?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    connect?: AbonnementWhereUniqueInput | AbonnementWhereUniqueInput[]
    update?: AbonnementUpdateWithWhereUniqueWithoutCourtInput | AbonnementUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: AbonnementUpdateManyWithWhereWithoutCourtInput | AbonnementUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutCourtNestedInput = {
    create?: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput> | ReservationCreateWithoutCourtInput[] | ReservationUncheckedCreateWithoutCourtInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutCourtInput | ReservationCreateOrConnectWithoutCourtInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutCourtInput | ReservationUpsertWithWhereUniqueWithoutCourtInput[]
    createMany?: ReservationCreateManyCourtInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutCourtInput | ReservationUpdateWithWhereUniqueWithoutCourtInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutCourtInput | ReservationUpdateManyWithWhereWithoutCourtInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput> | ReservationRuleCreateWithoutAffectedCourtsInput[] | ReservationRuleUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutAffectedCourtsInput | ReservationRuleCreateOrConnectWithoutAffectedCourtsInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutAffectedCourtsInput | ReservationRuleUpsertWithWhereUniqueWithoutAffectedCourtsInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutAffectedCourtsInput | ReservationRuleUpdateWithWhereUniqueWithoutAffectedCourtsInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutAffectedCourtsInput | ReservationRuleUpdateManyWithWhereWithoutAffectedCourtsInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput = {
    create?: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput> | ControlInterfaceCreateWithoutAffectedCourtsInput[] | ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput[]
    connectOrCreate?: ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput | ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput[]
    upsert?: ControlInterfaceUpsertWithWhereUniqueWithoutAffectedCourtsInput | ControlInterfaceUpsertWithWhereUniqueWithoutAffectedCourtsInput[]
    set?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    disconnect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    delete?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    connect?: ControlInterfaceWhereUniqueInput | ControlInterfaceWhereUniqueInput[]
    update?: ControlInterfaceUpdateWithWhereUniqueWithoutAffectedCourtsInput | ControlInterfaceUpdateWithWhereUniqueWithoutAffectedCourtsInput[]
    updateMany?: ControlInterfaceUpdateManyWithWhereWithoutAffectedCourtsInput | ControlInterfaceUpdateManyWithWhereWithoutAffectedCourtsInput[]
    deleteMany?: ControlInterfaceScalarWhereInput | ControlInterfaceScalarWhereInput[]
  }

  export type CourtCreateNestedOneWithoutReservationsInput = {
    create?: XOR<CourtCreateWithoutReservationsInput, CourtUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutReservationsInput
    connect?: CourtWhereUniqueInput
  }

  export type AbonnementCreateNestedOneWithoutReservationsInput = {
    create?: XOR<AbonnementCreateWithoutReservationsInput, AbonnementUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AbonnementCreateOrConnectWithoutReservationsInput
    connect?: AbonnementWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutOwnedReservationsInput = {
    create?: XOR<UserCreateWithoutOwnedReservationsInput, UserUncheckedCreateWithoutOwnedReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedReservationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutFellowedReservationsInput = {
    create?: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput> | UserCreateWithoutFellowedReservationsInput[] | UserUncheckedCreateWithoutFellowedReservationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFellowedReservationsInput | UserCreateOrConnectWithoutFellowedReservationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutReservationInput = {
    create?: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput> | TransactionCreateWithoutReservationInput[] | TransactionUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReservationInput | TransactionCreateOrConnectWithoutReservationInput[]
    createMany?: TransactionCreateManyReservationInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutFellowedReservationsInput = {
    create?: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput> | UserCreateWithoutFellowedReservationsInput[] | UserUncheckedCreateWithoutFellowedReservationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFellowedReservationsInput | UserCreateOrConnectWithoutFellowedReservationsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput> | TransactionCreateWithoutReservationInput[] | TransactionUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReservationInput | TransactionCreateOrConnectWithoutReservationInput[]
    createMany?: TransactionCreateManyReservationInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumReservationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ReservationStatus
  }

  export type NullableEnumReservationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReservationType | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CourtUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<CourtCreateWithoutReservationsInput, CourtUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutReservationsInput
    upsert?: CourtUpsertWithoutReservationsInput
    disconnect?: CourtWhereInput | boolean
    delete?: CourtWhereInput | boolean
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutReservationsInput, CourtUpdateWithoutReservationsInput>, CourtUncheckedUpdateWithoutReservationsInput>
  }

  export type AbonnementUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<AbonnementCreateWithoutReservationsInput, AbonnementUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AbonnementCreateOrConnectWithoutReservationsInput
    upsert?: AbonnementUpsertWithoutReservationsInput
    disconnect?: AbonnementWhereInput | boolean
    delete?: AbonnementWhereInput | boolean
    connect?: AbonnementWhereUniqueInput
    update?: XOR<XOR<AbonnementUpdateToOneWithWhereWithoutReservationsInput, AbonnementUpdateWithoutReservationsInput>, AbonnementUncheckedUpdateWithoutReservationsInput>
  }

  export type UserUpdateOneWithoutOwnedReservationsNestedInput = {
    create?: XOR<UserCreateWithoutOwnedReservationsInput, UserUncheckedCreateWithoutOwnedReservationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutOwnedReservationsInput
    upsert?: UserUpsertWithoutOwnedReservationsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutOwnedReservationsInput, UserUpdateWithoutOwnedReservationsInput>, UserUncheckedUpdateWithoutOwnedReservationsInput>
  }

  export type UserUpdateManyWithoutFellowedReservationsNestedInput = {
    create?: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput> | UserCreateWithoutFellowedReservationsInput[] | UserUncheckedCreateWithoutFellowedReservationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFellowedReservationsInput | UserCreateOrConnectWithoutFellowedReservationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFellowedReservationsInput | UserUpsertWithWhereUniqueWithoutFellowedReservationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFellowedReservationsInput | UserUpdateWithWhereUniqueWithoutFellowedReservationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFellowedReservationsInput | UserUpdateManyWithWhereWithoutFellowedReservationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutReservationNestedInput = {
    create?: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput> | TransactionCreateWithoutReservationInput[] | TransactionUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReservationInput | TransactionCreateOrConnectWithoutReservationInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutReservationInput | TransactionUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: TransactionCreateManyReservationInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutReservationInput | TransactionUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutReservationInput | TransactionUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput = {
    create?: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput> | UserCreateWithoutFellowedReservationsInput[] | UserUncheckedCreateWithoutFellowedReservationsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutFellowedReservationsInput | UserCreateOrConnectWithoutFellowedReservationsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutFellowedReservationsInput | UserUpsertWithWhereUniqueWithoutFellowedReservationsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutFellowedReservationsInput | UserUpdateWithWhereUniqueWithoutFellowedReservationsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutFellowedReservationsInput | UserUpdateManyWithWhereWithoutFellowedReservationsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput> | TransactionCreateWithoutReservationInput[] | TransactionUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutReservationInput | TransactionCreateOrConnectWithoutReservationInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutReservationInput | TransactionUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: TransactionCreateManyReservationInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutReservationInput | TransactionUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutReservationInput | TransactionUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type UserRoleCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput> | UserRoleCreateWithoutReservationRulesInput[] | UserRoleUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutReservationRulesInput | UserRoleCreateOrConnectWithoutReservationRulesInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AreaCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput> | AreaCreateWithoutReservationRulesInput[] | AreaUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutReservationRulesInput | AreaCreateOrConnectWithoutReservationRulesInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type CourtCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput> | CourtCreateWithoutReservationRulesInput[] | CourtUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutReservationRulesInput | CourtCreateOrConnectWithoutReservationRulesInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput> | UserRoleCreateWithoutReservationRulesInput[] | UserRoleUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutReservationRulesInput | UserRoleCreateOrConnectWithoutReservationRulesInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AreaUncheckedCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput> | AreaCreateWithoutReservationRulesInput[] | AreaUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutReservationRulesInput | AreaCreateOrConnectWithoutReservationRulesInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type CourtUncheckedCreateNestedManyWithoutReservationRulesInput = {
    create?: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput> | CourtCreateWithoutReservationRulesInput[] | CourtUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutReservationRulesInput | CourtCreateOrConnectWithoutReservationRulesInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type EnumReservationRuleCheckOnFieldUpdateOperationsInput = {
    set?: $Enums.ReservationRuleCheckOn
  }

  export type UserRoleUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput> | UserRoleCreateWithoutReservationRulesInput[] | UserRoleUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutReservationRulesInput | UserRoleCreateOrConnectWithoutReservationRulesInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutReservationRulesInput | UserRoleUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutReservationRulesInput | UserRoleUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutReservationRulesInput | UserRoleUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AreaUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput> | AreaCreateWithoutReservationRulesInput[] | AreaUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutReservationRulesInput | AreaCreateOrConnectWithoutReservationRulesInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutReservationRulesInput | AreaUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutReservationRulesInput | AreaUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutReservationRulesInput | AreaUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type CourtUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput> | CourtCreateWithoutReservationRulesInput[] | CourtUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutReservationRulesInput | CourtCreateOrConnectWithoutReservationRulesInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutReservationRulesInput | CourtUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutReservationRulesInput | CourtUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutReservationRulesInput | CourtUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput> | UserRoleCreateWithoutReservationRulesInput[] | UserRoleUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutReservationRulesInput | UserRoleCreateOrConnectWithoutReservationRulesInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutReservationRulesInput | UserRoleUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutReservationRulesInput | UserRoleUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutReservationRulesInput | UserRoleUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AreaUncheckedUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput> | AreaCreateWithoutReservationRulesInput[] | AreaUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutReservationRulesInput | AreaCreateOrConnectWithoutReservationRulesInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutReservationRulesInput | AreaUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutReservationRulesInput | AreaUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutReservationRulesInput | AreaUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type CourtUncheckedUpdateManyWithoutReservationRulesNestedInput = {
    create?: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput> | CourtCreateWithoutReservationRulesInput[] | CourtUncheckedCreateWithoutReservationRulesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutReservationRulesInput | CourtCreateOrConnectWithoutReservationRulesInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutReservationRulesInput | CourtUpsertWithWhereUniqueWithoutReservationRulesInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutReservationRulesInput | CourtUpdateWithWhereUniqueWithoutReservationRulesInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutReservationRulesInput | CourtUpdateManyWithWhereWithoutReservationRulesInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type CourtCreateNestedOneWithoutAbonnementsInput = {
    create?: XOR<CourtCreateWithoutAbonnementsInput, CourtUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutAbonnementsInput
    connect?: CourtWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAbonnementsInput = {
    create?: XOR<UserCreateWithoutAbonnementsInput, UserUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbonnementsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedManyWithoutAbonnementInput = {
    create?: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput> | TransactionCreateWithoutAbonnementInput[] | TransactionUncheckedCreateWithoutAbonnementInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAbonnementInput | TransactionCreateOrConnectWithoutAbonnementInput[]
    createMany?: TransactionCreateManyAbonnementInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutAboInput = {
    create?: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput> | ReservationCreateWithoutAboInput[] | ReservationUncheckedCreateWithoutAboInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAboInput | ReservationCreateOrConnectWithoutAboInput[]
    createMany?: ReservationCreateManyAboInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAbonnementInput = {
    create?: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput> | TransactionCreateWithoutAbonnementInput[] | TransactionUncheckedCreateWithoutAbonnementInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAbonnementInput | TransactionCreateOrConnectWithoutAbonnementInput[]
    createMany?: TransactionCreateManyAbonnementInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutAboInput = {
    create?: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput> | ReservationCreateWithoutAboInput[] | ReservationUncheckedCreateWithoutAboInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAboInput | ReservationCreateOrConnectWithoutAboInput[]
    createMany?: ReservationCreateManyAboInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumAbonnementStatusFieldUpdateOperationsInput = {
    set?: $Enums.AbonnementStatus
  }

  export type CourtUpdateOneWithoutAbonnementsNestedInput = {
    create?: XOR<CourtCreateWithoutAbonnementsInput, CourtUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: CourtCreateOrConnectWithoutAbonnementsInput
    upsert?: CourtUpsertWithoutAbonnementsInput
    disconnect?: CourtWhereInput | boolean
    delete?: CourtWhereInput | boolean
    connect?: CourtWhereUniqueInput
    update?: XOR<XOR<CourtUpdateToOneWithWhereWithoutAbonnementsInput, CourtUpdateWithoutAbonnementsInput>, CourtUncheckedUpdateWithoutAbonnementsInput>
  }

  export type UserUpdateOneWithoutAbonnementsNestedInput = {
    create?: XOR<UserCreateWithoutAbonnementsInput, UserUncheckedCreateWithoutAbonnementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAbonnementsInput
    upsert?: UserUpsertWithoutAbonnementsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAbonnementsInput, UserUpdateWithoutAbonnementsInput>, UserUncheckedUpdateWithoutAbonnementsInput>
  }

  export type TransactionUpdateManyWithoutAbonnementNestedInput = {
    create?: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput> | TransactionCreateWithoutAbonnementInput[] | TransactionUncheckedCreateWithoutAbonnementInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAbonnementInput | TransactionCreateOrConnectWithoutAbonnementInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAbonnementInput | TransactionUpsertWithWhereUniqueWithoutAbonnementInput[]
    createMany?: TransactionCreateManyAbonnementInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAbonnementInput | TransactionUpdateWithWhereUniqueWithoutAbonnementInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAbonnementInput | TransactionUpdateManyWithWhereWithoutAbonnementInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutAboNestedInput = {
    create?: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput> | ReservationCreateWithoutAboInput[] | ReservationUncheckedCreateWithoutAboInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAboInput | ReservationCreateOrConnectWithoutAboInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAboInput | ReservationUpsertWithWhereUniqueWithoutAboInput[]
    createMany?: ReservationCreateManyAboInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAboInput | ReservationUpdateWithWhereUniqueWithoutAboInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAboInput | ReservationUpdateManyWithWhereWithoutAboInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAbonnementNestedInput = {
    create?: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput> | TransactionCreateWithoutAbonnementInput[] | TransactionUncheckedCreateWithoutAbonnementInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAbonnementInput | TransactionCreateOrConnectWithoutAbonnementInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAbonnementInput | TransactionUpsertWithWhereUniqueWithoutAbonnementInput[]
    createMany?: TransactionCreateManyAbonnementInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAbonnementInput | TransactionUpdateWithWhereUniqueWithoutAbonnementInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAbonnementInput | TransactionUpdateManyWithWhereWithoutAbonnementInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutAboNestedInput = {
    create?: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput> | ReservationCreateWithoutAboInput[] | ReservationUncheckedCreateWithoutAboInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAboInput | ReservationCreateOrConnectWithoutAboInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAboInput | ReservationUpsertWithWhereUniqueWithoutAboInput[]
    createMany?: ReservationCreateManyAboInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAboInput | ReservationUpdateWithWhereUniqueWithoutAboInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAboInput | ReservationUpdateManyWithWhereWithoutAboInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PermissionCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput> | PermissionCreateWithoutUserRoleInput[] | PermissionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUserRoleInput | PermissionCreateOrConnectWithoutUserRoleInput[]
    createMany?: PermissionCreateManyUserRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PriceCreateNestedManyWithoutRolesInput = {
    create?: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput> | PriceCreateWithoutRolesInput[] | PriceUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutRolesInput | PriceCreateOrConnectWithoutRolesInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type ReservationRuleCreateNestedManyWithoutValidForInput = {
    create?: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput> | ReservationRuleCreateWithoutValidForInput[] | ReservationRuleUncheckedCreateWithoutValidForInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutValidForInput | ReservationRuleCreateOrConnectWithoutValidForInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type PermissionUncheckedCreateNestedManyWithoutUserRoleInput = {
    create?: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput> | PermissionCreateWithoutUserRoleInput[] | PermissionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUserRoleInput | PermissionCreateOrConnectWithoutUserRoleInput[]
    createMany?: PermissionCreateManyUserRoleInputEnvelope
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PriceUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput> | PriceCreateWithoutRolesInput[] | PriceUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutRolesInput | PriceCreateOrConnectWithoutRolesInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
  }

  export type ReservationRuleUncheckedCreateNestedManyWithoutValidForInput = {
    create?: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput> | ReservationRuleCreateWithoutValidForInput[] | ReservationRuleUncheckedCreateWithoutValidForInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutValidForInput | ReservationRuleCreateOrConnectWithoutValidForInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
  }

  export type PermissionUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput> | PermissionCreateWithoutUserRoleInput[] | PermissionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUserRoleInput | PermissionCreateOrConnectWithoutUserRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutUserRoleInput | PermissionUpsertWithWhereUniqueWithoutUserRoleInput[]
    createMany?: PermissionCreateManyUserRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutUserRoleInput | PermissionUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutUserRoleInput | PermissionUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PriceUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput> | PriceCreateWithoutRolesInput[] | PriceUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutRolesInput | PriceCreateOrConnectWithoutRolesInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutRolesInput | PriceUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutRolesInput | PriceUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutRolesInput | PriceUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type ReservationRuleUpdateManyWithoutValidForNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput> | ReservationRuleCreateWithoutValidForInput[] | ReservationRuleUncheckedCreateWithoutValidForInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutValidForInput | ReservationRuleCreateOrConnectWithoutValidForInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutValidForInput | ReservationRuleUpsertWithWhereUniqueWithoutValidForInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutValidForInput | ReservationRuleUpdateWithWhereUniqueWithoutValidForInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutValidForInput | ReservationRuleUpdateManyWithWhereWithoutValidForInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type PermissionUncheckedUpdateManyWithoutUserRoleNestedInput = {
    create?: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput> | PermissionCreateWithoutUserRoleInput[] | PermissionUncheckedCreateWithoutUserRoleInput[]
    connectOrCreate?: PermissionCreateOrConnectWithoutUserRoleInput | PermissionCreateOrConnectWithoutUserRoleInput[]
    upsert?: PermissionUpsertWithWhereUniqueWithoutUserRoleInput | PermissionUpsertWithWhereUniqueWithoutUserRoleInput[]
    createMany?: PermissionCreateManyUserRoleInputEnvelope
    set?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    disconnect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    delete?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    connect?: PermissionWhereUniqueInput | PermissionWhereUniqueInput[]
    update?: PermissionUpdateWithWhereUniqueWithoutUserRoleInput | PermissionUpdateWithWhereUniqueWithoutUserRoleInput[]
    updateMany?: PermissionUpdateManyWithWhereWithoutUserRoleInput | PermissionUpdateManyWithWhereWithoutUserRoleInput[]
    deleteMany?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput> | UserCreateWithoutRolesInput[] | UserUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRolesInput | UserCreateOrConnectWithoutRolesInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRolesInput | UserUpsertWithWhereUniqueWithoutRolesInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRolesInput | UserUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRolesInput | UserUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PriceUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput> | PriceCreateWithoutRolesInput[] | PriceUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: PriceCreateOrConnectWithoutRolesInput | PriceCreateOrConnectWithoutRolesInput[]
    upsert?: PriceUpsertWithWhereUniqueWithoutRolesInput | PriceUpsertWithWhereUniqueWithoutRolesInput[]
    set?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    disconnect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    delete?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    connect?: PriceWhereUniqueInput | PriceWhereUniqueInput[]
    update?: PriceUpdateWithWhereUniqueWithoutRolesInput | PriceUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: PriceUpdateManyWithWhereWithoutRolesInput | PriceUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: PriceScalarWhereInput | PriceScalarWhereInput[]
  }

  export type ReservationRuleUncheckedUpdateManyWithoutValidForNestedInput = {
    create?: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput> | ReservationRuleCreateWithoutValidForInput[] | ReservationRuleUncheckedCreateWithoutValidForInput[]
    connectOrCreate?: ReservationRuleCreateOrConnectWithoutValidForInput | ReservationRuleCreateOrConnectWithoutValidForInput[]
    upsert?: ReservationRuleUpsertWithWhereUniqueWithoutValidForInput | ReservationRuleUpsertWithWhereUniqueWithoutValidForInput[]
    set?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    disconnect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    delete?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    connect?: ReservationRuleWhereUniqueInput | ReservationRuleWhereUniqueInput[]
    update?: ReservationRuleUpdateWithWhereUniqueWithoutValidForInput | ReservationRuleUpdateWithWhereUniqueWithoutValidForInput[]
    updateMany?: ReservationRuleUpdateManyWithWhereWithoutValidForInput | ReservationRuleUpdateManyWithWhereWithoutValidForInput[]
    deleteMany?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
  }

  export type UserRoleCreateNestedOneWithoutPermissionsInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput
    connect?: UserRoleWhereUniqueInput
  }

  export type EnumPermissionStateFieldUpdateOperationsInput = {
    set?: $Enums.PermissionState
  }

  export type UserRoleUpdateOneRequiredWithoutPermissionsNestedInput = {
    create?: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
    connectOrCreate?: UserRoleCreateOrConnectWithoutPermissionsInput
    upsert?: UserRoleUpsertWithoutPermissionsInput
    connect?: UserRoleWhereUniqueInput
    update?: XOR<XOR<UserRoleUpdateToOneWithWhereWithoutPermissionsInput, UserRoleUpdateWithoutPermissionsInput>, UserRoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type TransactionCreateNestedOneWithoutHallencardInput = {
    create?: XOR<TransactionCreateWithoutHallencardInput, TransactionUncheckedCreateWithoutHallencardInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutHallencardInput
    connect?: TransactionWhereUniqueInput
  }

  export type TransactionUpdateOneWithoutHallencardNestedInput = {
    create?: XOR<TransactionCreateWithoutHallencardInput, TransactionUncheckedCreateWithoutHallencardInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutHallencardInput
    upsert?: TransactionUpsertWithoutHallencardInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutHallencardInput, TransactionUpdateWithoutHallencardInput>, TransactionUncheckedUpdateWithoutHallencardInput>
  }

  export type UserRoleCreateNestedManyWithoutPricesInput = {
    create?: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput> | UserRoleCreateWithoutPricesInput[] | UserRoleUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPricesInput | UserRoleCreateOrConnectWithoutPricesInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AreaCreateNestedManyWithoutPricesInput = {
    create?: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput> | AreaCreateWithoutPricesInput[] | AreaUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutPricesInput | AreaCreateOrConnectWithoutPricesInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type UserRoleUncheckedCreateNestedManyWithoutPricesInput = {
    create?: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput> | UserRoleCreateWithoutPricesInput[] | UserRoleUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPricesInput | UserRoleCreateOrConnectWithoutPricesInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
  }

  export type AreaUncheckedCreateNestedManyWithoutPricesInput = {
    create?: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput> | AreaCreateWithoutPricesInput[] | AreaUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutPricesInput | AreaCreateOrConnectWithoutPricesInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
  }

  export type UserRoleUpdateManyWithoutPricesNestedInput = {
    create?: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput> | UserRoleCreateWithoutPricesInput[] | UserRoleUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPricesInput | UserRoleCreateOrConnectWithoutPricesInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutPricesInput | UserRoleUpsertWithWhereUniqueWithoutPricesInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutPricesInput | UserRoleUpdateWithWhereUniqueWithoutPricesInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutPricesInput | UserRoleUpdateManyWithWhereWithoutPricesInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AreaUpdateManyWithoutPricesNestedInput = {
    create?: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput> | AreaCreateWithoutPricesInput[] | AreaUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutPricesInput | AreaCreateOrConnectWithoutPricesInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutPricesInput | AreaUpsertWithWhereUniqueWithoutPricesInput[]
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutPricesInput | AreaUpdateWithWhereUniqueWithoutPricesInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutPricesInput | AreaUpdateManyWithWhereWithoutPricesInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type UserRoleUncheckedUpdateManyWithoutPricesNestedInput = {
    create?: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput> | UserRoleCreateWithoutPricesInput[] | UserRoleUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: UserRoleCreateOrConnectWithoutPricesInput | UserRoleCreateOrConnectWithoutPricesInput[]
    upsert?: UserRoleUpsertWithWhereUniqueWithoutPricesInput | UserRoleUpsertWithWhereUniqueWithoutPricesInput[]
    set?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    disconnect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    delete?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    connect?: UserRoleWhereUniqueInput | UserRoleWhereUniqueInput[]
    update?: UserRoleUpdateWithWhereUniqueWithoutPricesInput | UserRoleUpdateWithWhereUniqueWithoutPricesInput[]
    updateMany?: UserRoleUpdateManyWithWhereWithoutPricesInput | UserRoleUpdateManyWithWhereWithoutPricesInput[]
    deleteMany?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
  }

  export type AreaUncheckedUpdateManyWithoutPricesNestedInput = {
    create?: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput> | AreaCreateWithoutPricesInput[] | AreaUncheckedCreateWithoutPricesInput[]
    connectOrCreate?: AreaCreateOrConnectWithoutPricesInput | AreaCreateOrConnectWithoutPricesInput[]
    upsert?: AreaUpsertWithWhereUniqueWithoutPricesInput | AreaUpsertWithWhereUniqueWithoutPricesInput[]
    set?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    disconnect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    delete?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    connect?: AreaWhereUniqueInput | AreaWhereUniqueInput[]
    update?: AreaUpdateWithWhereUniqueWithoutPricesInput | AreaUpdateWithWhereUniqueWithoutPricesInput[]
    updateMany?: AreaUpdateManyWithWhereWithoutPricesInput | AreaUpdateManyWithWhereWithoutPricesInput[]
    deleteMany?: AreaScalarWhereInput | AreaScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type HallencardCreateNestedOneWithoutTransactionInput = {
    create?: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: HallencardCreateOrConnectWithoutTransactionInput
    connect?: HallencardWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ReservationCreateWithoutTransactionsInput, ReservationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutTransactionsInput
    connect?: ReservationWhereUniqueInput
  }

  export type AbonnementCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<AbonnementCreateWithoutTransactionsInput, AbonnementUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AbonnementCreateOrConnectWithoutTransactionsInput
    connect?: AbonnementWhereUniqueInput
  }

  export type HallencardUncheckedCreateNestedOneWithoutTransactionInput = {
    create?: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: HallencardCreateOrConnectWithoutTransactionInput
    connect?: HallencardWhereUniqueInput
  }

  export type EnumTransactionReasonFieldUpdateOperationsInput = {
    set?: $Enums.TransactionReason
  }

  export type UserUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type HallencardUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: HallencardCreateOrConnectWithoutTransactionInput
    upsert?: HallencardUpsertWithoutTransactionInput
    disconnect?: HallencardWhereInput | boolean
    delete?: HallencardWhereInput | boolean
    connect?: HallencardWhereUniqueInput
    update?: XOR<XOR<HallencardUpdateToOneWithWhereWithoutTransactionInput, HallencardUpdateWithoutTransactionInput>, HallencardUncheckedUpdateWithoutTransactionInput>
  }

  export type ReservationUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<ReservationCreateWithoutTransactionsInput, ReservationUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutTransactionsInput
    upsert?: ReservationUpsertWithoutTransactionsInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutTransactionsInput, ReservationUpdateWithoutTransactionsInput>, ReservationUncheckedUpdateWithoutTransactionsInput>
  }

  export type AbonnementUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<AbonnementCreateWithoutTransactionsInput, AbonnementUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: AbonnementCreateOrConnectWithoutTransactionsInput
    upsert?: AbonnementUpsertWithoutTransactionsInput
    disconnect?: AbonnementWhereInput | boolean
    delete?: AbonnementWhereInput | boolean
    connect?: AbonnementWhereUniqueInput
    update?: XOR<XOR<AbonnementUpdateToOneWithWhereWithoutTransactionsInput, AbonnementUpdateWithoutTransactionsInput>, AbonnementUncheckedUpdateWithoutTransactionsInput>
  }

  export type HallencardUncheckedUpdateOneWithoutTransactionNestedInput = {
    create?: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
    connectOrCreate?: HallencardCreateOrConnectWithoutTransactionInput
    upsert?: HallencardUpsertWithoutTransactionInput
    disconnect?: HallencardWhereInput | boolean
    delete?: HallencardWhereInput | boolean
    connect?: HallencardWhereUniqueInput
    update?: XOR<XOR<HallencardUpdateToOneWithWhereWithoutTransactionInput, HallencardUpdateWithoutTransactionInput>, HallencardUncheckedUpdateWithoutTransactionInput>
  }

  export type TeamSeasonCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput> | TeamSeasonCreateWithoutSeasonInput[] | TeamSeasonUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutSeasonInput | TeamSeasonCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamSeasonCreateManySeasonInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput> | TeamMemberCreateWithoutSeasonInput[] | TeamMemberUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutSeasonInput | TeamMemberCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamMemberCreateManySeasonInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamSeasonUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput> | TeamSeasonCreateWithoutSeasonInput[] | TeamSeasonUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutSeasonInput | TeamSeasonCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamSeasonCreateManySeasonInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput> | TeamMemberCreateWithoutSeasonInput[] | TeamMemberUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutSeasonInput | TeamMemberCreateOrConnectWithoutSeasonInput[]
    createMany?: TeamMemberCreateManySeasonInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamSeasonUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput> | TeamSeasonCreateWithoutSeasonInput[] | TeamSeasonUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutSeasonInput | TeamSeasonCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutSeasonInput | TeamSeasonUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamSeasonCreateManySeasonInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutSeasonInput | TeamSeasonUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutSeasonInput | TeamSeasonUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput> | TeamMemberCreateWithoutSeasonInput[] | TeamMemberUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutSeasonInput | TeamMemberCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutSeasonInput | TeamMemberUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamMemberCreateManySeasonInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutSeasonInput | TeamMemberUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutSeasonInput | TeamMemberUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamSeasonUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput> | TeamSeasonCreateWithoutSeasonInput[] | TeamSeasonUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutSeasonInput | TeamSeasonCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutSeasonInput | TeamSeasonUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamSeasonCreateManySeasonInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutSeasonInput | TeamSeasonUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutSeasonInput | TeamSeasonUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput> | TeamMemberCreateWithoutSeasonInput[] | TeamMemberUncheckedCreateWithoutSeasonInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutSeasonInput | TeamMemberCreateOrConnectWithoutSeasonInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutSeasonInput | TeamMemberUpsertWithWhereUniqueWithoutSeasonInput[]
    createMany?: TeamMemberCreateManySeasonInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutSeasonInput | TeamMemberUpdateWithWhereUniqueWithoutSeasonInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutSeasonInput | TeamMemberUpdateManyWithWhereWithoutSeasonInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamSeasonCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput> | TeamSeasonCreateWithoutTeamInput[] | TeamSeasonUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamInput | TeamSeasonCreateOrConnectWithoutTeamInput[]
    createMany?: TeamSeasonCreateManyTeamInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamSeasonUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput> | TeamSeasonCreateWithoutTeamInput[] | TeamSeasonUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamInput | TeamSeasonCreateOrConnectWithoutTeamInput[]
    createMany?: TeamSeasonCreateManyTeamInputEnvelope
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type EnumTeamCategoryFieldUpdateOperationsInput = {
    set?: $Enums.TeamCategory
  }

  export type TeamSeasonUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput> | TeamSeasonCreateWithoutTeamInput[] | TeamSeasonUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamInput | TeamSeasonCreateOrConnectWithoutTeamInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutTeamInput | TeamSeasonUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamSeasonCreateManyTeamInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutTeamInput | TeamSeasonUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutTeamInput | TeamSeasonUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamSeasonUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput> | TeamSeasonCreateWithoutTeamInput[] | TeamSeasonUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamSeasonCreateOrConnectWithoutTeamInput | TeamSeasonCreateOrConnectWithoutTeamInput[]
    upsert?: TeamSeasonUpsertWithWhereUniqueWithoutTeamInput | TeamSeasonUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamSeasonCreateManyTeamInputEnvelope
    set?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    disconnect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    delete?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    connect?: TeamSeasonWhereUniqueInput | TeamSeasonWhereUniqueInput[]
    update?: TeamSeasonUpdateWithWhereUniqueWithoutTeamInput | TeamSeasonUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamSeasonUpdateManyWithWhereWithoutTeamInput | TeamSeasonUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutTeamSeasonsInput = {
    create?: XOR<TeamCreateWithoutTeamSeasonsInput, TeamUncheckedCreateWithoutTeamSeasonsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamSeasonsInput
    connect?: TeamWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutTeamsInput = {
    create?: XOR<SeasonCreateWithoutTeamsInput, SeasonUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTeamsInput
    connect?: SeasonWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLeadTeamsInput = {
    create?: XOR<UserCreateWithoutLeadTeamsInput, UserUncheckedCreateWithoutLeadTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutTeamSeasonsNestedInput = {
    create?: XOR<TeamCreateWithoutTeamSeasonsInput, TeamUncheckedCreateWithoutTeamSeasonsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutTeamSeasonsInput
    upsert?: TeamUpsertWithoutTeamSeasonsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutTeamSeasonsInput, TeamUpdateWithoutTeamSeasonsInput>, TeamUncheckedUpdateWithoutTeamSeasonsInput>
  }

  export type SeasonUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<SeasonCreateWithoutTeamsInput, SeasonUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutTeamsInput
    upsert?: SeasonUpsertWithoutTeamsInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutTeamsInput, SeasonUpdateWithoutTeamsInput>, SeasonUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateOneWithoutLeadTeamsNestedInput = {
    create?: XOR<UserCreateWithoutLeadTeamsInput, UserUncheckedCreateWithoutLeadTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeadTeamsInput
    upsert?: UserUpsertWithoutLeadTeamsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeadTeamsInput, UserUpdateWithoutLeadTeamsInput>, UserUncheckedUpdateWithoutLeadTeamsInput>
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type SeasonCreateNestedOneWithoutPlayersInput = {
    create?: XOR<SeasonCreateWithoutPlayersInput, SeasonUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutPlayersInput
    connect?: SeasonWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type SeasonUpdateOneRequiredWithoutPlayersNestedInput = {
    create?: XOR<SeasonCreateWithoutPlayersInput, SeasonUncheckedCreateWithoutPlayersInput>
    connectOrCreate?: SeasonCreateOrConnectWithoutPlayersInput
    upsert?: SeasonUpsertWithoutPlayersInput
    connect?: SeasonWhereUniqueInput
    update?: XOR<XOR<SeasonUpdateToOneWithWhereWithoutPlayersInput, SeasonUpdateWithoutPlayersInput>, SeasonUncheckedUpdateWithoutPlayersInput>
  }

  export type EnumNotificationSeverityFieldUpdateOperationsInput = {
    set?: $Enums.NotificationSeverity
  }

  export type CourtCreateNestedManyWithoutControlInterfacesInput = {
    create?: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput> | CourtCreateWithoutControlInterfacesInput[] | CourtUncheckedCreateWithoutControlInterfacesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutControlInterfacesInput | CourtCreateOrConnectWithoutControlInterfacesInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type CourtUncheckedCreateNestedManyWithoutControlInterfacesInput = {
    create?: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput> | CourtCreateWithoutControlInterfacesInput[] | CourtUncheckedCreateWithoutControlInterfacesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutControlInterfacesInput | CourtCreateOrConnectWithoutControlInterfacesInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
  }

  export type CourtUpdateManyWithoutControlInterfacesNestedInput = {
    create?: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput> | CourtCreateWithoutControlInterfacesInput[] | CourtUncheckedCreateWithoutControlInterfacesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutControlInterfacesInput | CourtCreateOrConnectWithoutControlInterfacesInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutControlInterfacesInput | CourtUpsertWithWhereUniqueWithoutControlInterfacesInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutControlInterfacesInput | CourtUpdateWithWhereUniqueWithoutControlInterfacesInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutControlInterfacesInput | CourtUpdateManyWithWhereWithoutControlInterfacesInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type CourtUncheckedUpdateManyWithoutControlInterfacesNestedInput = {
    create?: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput> | CourtCreateWithoutControlInterfacesInput[] | CourtUncheckedCreateWithoutControlInterfacesInput[]
    connectOrCreate?: CourtCreateOrConnectWithoutControlInterfacesInput | CourtCreateOrConnectWithoutControlInterfacesInput[]
    upsert?: CourtUpsertWithWhereUniqueWithoutControlInterfacesInput | CourtUpsertWithWhereUniqueWithoutControlInterfacesInput[]
    set?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    disconnect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    delete?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    connect?: CourtWhereUniqueInput | CourtWhereUniqueInput[]
    update?: CourtUpdateWithWhereUniqueWithoutControlInterfacesInput | CourtUpdateWithWhereUniqueWithoutControlInterfacesInput[]
    updateMany?: CourtUpdateManyWithWhereWithoutControlInterfacesInput | CourtUpdateManyWithWhereWithoutControlInterfacesInput[]
    deleteMany?: CourtScalarWhereInput | CourtScalarWhereInput[]
  }

  export type OrganisationMemberCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput> | OrganisationMemberCreateWithoutOrganisationInput[] | OrganisationMemberUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutOrganisationInput | OrganisationMemberCreateOrConnectWithoutOrganisationInput[]
    createMany?: OrganisationMemberCreateManyOrganisationInputEnvelope
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
  }

  export type OrganisationMemberUncheckedCreateNestedManyWithoutOrganisationInput = {
    create?: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput> | OrganisationMemberCreateWithoutOrganisationInput[] | OrganisationMemberUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutOrganisationInput | OrganisationMemberCreateOrConnectWithoutOrganisationInput[]
    createMany?: OrganisationMemberCreateManyOrganisationInputEnvelope
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
  }

  export type OrganisationMemberUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput> | OrganisationMemberCreateWithoutOrganisationInput[] | OrganisationMemberUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutOrganisationInput | OrganisationMemberCreateOrConnectWithoutOrganisationInput[]
    upsert?: OrganisationMemberUpsertWithWhereUniqueWithoutOrganisationInput | OrganisationMemberUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: OrganisationMemberCreateManyOrganisationInputEnvelope
    set?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    disconnect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    delete?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    update?: OrganisationMemberUpdateWithWhereUniqueWithoutOrganisationInput | OrganisationMemberUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: OrganisationMemberUpdateManyWithWhereWithoutOrganisationInput | OrganisationMemberUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
  }

  export type OrganisationMemberUncheckedUpdateManyWithoutOrganisationNestedInput = {
    create?: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput> | OrganisationMemberCreateWithoutOrganisationInput[] | OrganisationMemberUncheckedCreateWithoutOrganisationInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutOrganisationInput | OrganisationMemberCreateOrConnectWithoutOrganisationInput[]
    upsert?: OrganisationMemberUpsertWithWhereUniqueWithoutOrganisationInput | OrganisationMemberUpsertWithWhereUniqueWithoutOrganisationInput[]
    createMany?: OrganisationMemberCreateManyOrganisationInputEnvelope
    set?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    disconnect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    delete?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    update?: OrganisationMemberUpdateWithWhereUniqueWithoutOrganisationInput | OrganisationMemberUpdateWithWhereUniqueWithoutOrganisationInput[]
    updateMany?: OrganisationMemberUpdateManyWithWhereWithoutOrganisationInput | OrganisationMemberUpdateManyWithWhereWithoutOrganisationInput[]
    deleteMany?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
  }

  export type OrganisationCreateNestedOneWithoutMembersInput = {
    create?: XOR<OrganisationCreateWithoutMembersInput, OrganisationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMembersInput
    connect?: OrganisationWhereUniqueInput
  }

  export type OrganisationMemberCreateNestedOneWithoutChildMembersInput = {
    create?: XOR<OrganisationMemberCreateWithoutChildMembersInput, OrganisationMemberUncheckedCreateWithoutChildMembersInput>
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutChildMembersInput
    connect?: OrganisationMemberWhereUniqueInput
  }

  export type OrganisationMemberCreateNestedManyWithoutParentMemberInput = {
    create?: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput> | OrganisationMemberCreateWithoutParentMemberInput[] | OrganisationMemberUncheckedCreateWithoutParentMemberInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutParentMemberInput | OrganisationMemberCreateOrConnectWithoutParentMemberInput[]
    createMany?: OrganisationMemberCreateManyParentMemberInputEnvelope
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
  }

  export type OrganisationMemberUncheckedCreateNestedManyWithoutParentMemberInput = {
    create?: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput> | OrganisationMemberCreateWithoutParentMemberInput[] | OrganisationMemberUncheckedCreateWithoutParentMemberInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutParentMemberInput | OrganisationMemberCreateOrConnectWithoutParentMemberInput[]
    createMany?: OrganisationMemberCreateManyParentMemberInputEnvelope
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
  }

  export type OrganisationUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<OrganisationCreateWithoutMembersInput, OrganisationUncheckedCreateWithoutMembersInput>
    connectOrCreate?: OrganisationCreateOrConnectWithoutMembersInput
    upsert?: OrganisationUpsertWithoutMembersInput
    connect?: OrganisationWhereUniqueInput
    update?: XOR<XOR<OrganisationUpdateToOneWithWhereWithoutMembersInput, OrganisationUpdateWithoutMembersInput>, OrganisationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganisationMemberUpdateOneWithoutChildMembersNestedInput = {
    create?: XOR<OrganisationMemberCreateWithoutChildMembersInput, OrganisationMemberUncheckedCreateWithoutChildMembersInput>
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutChildMembersInput
    upsert?: OrganisationMemberUpsertWithoutChildMembersInput
    disconnect?: OrganisationMemberWhereInput | boolean
    delete?: OrganisationMemberWhereInput | boolean
    connect?: OrganisationMemberWhereUniqueInput
    update?: XOR<XOR<OrganisationMemberUpdateToOneWithWhereWithoutChildMembersInput, OrganisationMemberUpdateWithoutChildMembersInput>, OrganisationMemberUncheckedUpdateWithoutChildMembersInput>
  }

  export type OrganisationMemberUpdateManyWithoutParentMemberNestedInput = {
    create?: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput> | OrganisationMemberCreateWithoutParentMemberInput[] | OrganisationMemberUncheckedCreateWithoutParentMemberInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutParentMemberInput | OrganisationMemberCreateOrConnectWithoutParentMemberInput[]
    upsert?: OrganisationMemberUpsertWithWhereUniqueWithoutParentMemberInput | OrganisationMemberUpsertWithWhereUniqueWithoutParentMemberInput[]
    createMany?: OrganisationMemberCreateManyParentMemberInputEnvelope
    set?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    disconnect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    delete?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    update?: OrganisationMemberUpdateWithWhereUniqueWithoutParentMemberInput | OrganisationMemberUpdateWithWhereUniqueWithoutParentMemberInput[]
    updateMany?: OrganisationMemberUpdateManyWithWhereWithoutParentMemberInput | OrganisationMemberUpdateManyWithWhereWithoutParentMemberInput[]
    deleteMany?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
  }

  export type OrganisationMemberUncheckedUpdateManyWithoutParentMemberNestedInput = {
    create?: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput> | OrganisationMemberCreateWithoutParentMemberInput[] | OrganisationMemberUncheckedCreateWithoutParentMemberInput[]
    connectOrCreate?: OrganisationMemberCreateOrConnectWithoutParentMemberInput | OrganisationMemberCreateOrConnectWithoutParentMemberInput[]
    upsert?: OrganisationMemberUpsertWithWhereUniqueWithoutParentMemberInput | OrganisationMemberUpsertWithWhereUniqueWithoutParentMemberInput[]
    createMany?: OrganisationMemberCreateManyParentMemberInputEnvelope
    set?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    disconnect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    delete?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    connect?: OrganisationMemberWhereUniqueInput | OrganisationMemberWhereUniqueInput[]
    update?: OrganisationMemberUpdateWithWhereUniqueWithoutParentMemberInput | OrganisationMemberUpdateWithWhereUniqueWithoutParentMemberInput[]
    updateMany?: OrganisationMemberUpdateManyWithWhereWithoutParentMemberInput | OrganisationMemberUpdateManyWithWhereWithoutParentMemberInput[]
    deleteMany?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
  }

  export type EventCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventCategoryCreateNestedOneWithoutEventsInput = {
    create?: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventsInput
    connect?: EventCategoryWhereUniqueInput
  }

  export type UserCreateNestedManyWithoutLikedEventsInput = {
    create?: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput> | UserCreateWithoutLikedEventsInput[] | UserUncheckedCreateWithoutLikedEventsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLikedEventsInput | UserCreateOrConnectWithoutLikedEventsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutLikedEventsInput = {
    create?: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput> | UserCreateWithoutLikedEventsInput[] | UserUncheckedCreateWithoutLikedEventsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLikedEventsInput | UserCreateOrConnectWithoutLikedEventsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type EventCategoryUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventsInput
    upsert?: EventCategoryUpsertWithoutEventsInput
    connect?: EventCategoryWhereUniqueInput
    update?: XOR<XOR<EventCategoryUpdateToOneWithWhereWithoutEventsInput, EventCategoryUpdateWithoutEventsInput>, EventCategoryUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateManyWithoutLikedEventsNestedInput = {
    create?: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput> | UserCreateWithoutLikedEventsInput[] | UserUncheckedCreateWithoutLikedEventsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLikedEventsInput | UserCreateOrConnectWithoutLikedEventsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLikedEventsInput | UserUpsertWithWhereUniqueWithoutLikedEventsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLikedEventsInput | UserUpdateWithWhereUniqueWithoutLikedEventsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLikedEventsInput | UserUpdateManyWithWhereWithoutLikedEventsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutLikedEventsNestedInput = {
    create?: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput> | UserCreateWithoutLikedEventsInput[] | UserUncheckedCreateWithoutLikedEventsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutLikedEventsInput | UserCreateOrConnectWithoutLikedEventsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutLikedEventsInput | UserUpsertWithWhereUniqueWithoutLikedEventsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutLikedEventsInput | UserUpdateWithWhereUniqueWithoutLikedEventsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutLikedEventsInput | UserUpdateManyWithWhereWithoutLikedEventsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumReservationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[]
    notIn?: $Enums.ReservationStatus[]
    not?: NestedEnumReservationStatusFilter<$PrismaModel> | $Enums.ReservationStatus
  }

  export type NestedEnumReservationTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationType | EnumReservationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReservationType[] | null
    notIn?: $Enums.ReservationType[] | null
    not?: NestedEnumReservationTypeNullableFilter<$PrismaModel> | $Enums.ReservationType | null
  }

  export type NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationStatus | EnumReservationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationStatus[]
    notIn?: $Enums.ReservationStatus[]
    not?: NestedEnumReservationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ReservationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationStatusFilter<$PrismaModel>
    _max?: NestedEnumReservationStatusFilter<$PrismaModel>
  }

  export type NestedEnumReservationTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationType | EnumReservationTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReservationType[] | null
    notIn?: $Enums.ReservationType[] | null
    not?: NestedEnumReservationTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReservationType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReservationTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReservationTypeNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumReservationRuleCheckOnFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationRuleCheckOn | EnumReservationRuleCheckOnFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationRuleCheckOn[]
    notIn?: $Enums.ReservationRuleCheckOn[]
    not?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel> | $Enums.ReservationRuleCheckOn
  }

  export type NestedEnumReservationRuleCheckOnWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReservationRuleCheckOn | EnumReservationRuleCheckOnFieldRefInput<$PrismaModel>
    in?: $Enums.ReservationRuleCheckOn[]
    notIn?: $Enums.ReservationRuleCheckOn[]
    not?: NestedEnumReservationRuleCheckOnWithAggregatesFilter<$PrismaModel> | $Enums.ReservationRuleCheckOn
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel>
    _max?: NestedEnumReservationRuleCheckOnFilter<$PrismaModel>
  }

  export type NestedEnumAbonnementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AbonnementStatus | EnumAbonnementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbonnementStatus[]
    notIn?: $Enums.AbonnementStatus[]
    not?: NestedEnumAbonnementStatusFilter<$PrismaModel> | $Enums.AbonnementStatus
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumAbonnementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AbonnementStatus | EnumAbonnementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AbonnementStatus[]
    notIn?: $Enums.AbonnementStatus[]
    not?: NestedEnumAbonnementStatusWithAggregatesFilter<$PrismaModel> | $Enums.AbonnementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAbonnementStatusFilter<$PrismaModel>
    _max?: NestedEnumAbonnementStatusFilter<$PrismaModel>
  }

  export type NestedEnumPermissionStateFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionState | EnumPermissionStateFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionState[]
    notIn?: $Enums.PermissionState[]
    not?: NestedEnumPermissionStateFilter<$PrismaModel> | $Enums.PermissionState
  }

  export type NestedEnumPermissionStateWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionState | EnumPermissionStateFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionState[]
    notIn?: $Enums.PermissionState[]
    not?: NestedEnumPermissionStateWithAggregatesFilter<$PrismaModel> | $Enums.PermissionState
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionStateFilter<$PrismaModel>
    _max?: NestedEnumPermissionStateFilter<$PrismaModel>
  }

  export type NestedEnumTransactionReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReason | EnumTransactionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReason[]
    notIn?: $Enums.TransactionReason[]
    not?: NestedEnumTransactionReasonFilter<$PrismaModel> | $Enums.TransactionReason
  }

  export type NestedEnumTransactionReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionReason | EnumTransactionReasonFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionReason[]
    notIn?: $Enums.TransactionReason[]
    not?: NestedEnumTransactionReasonWithAggregatesFilter<$PrismaModel> | $Enums.TransactionReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionReasonFilter<$PrismaModel>
    _max?: NestedEnumTransactionReasonFilter<$PrismaModel>
  }

  export type NestedEnumTeamCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamCategory | EnumTeamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeamCategory[]
    notIn?: $Enums.TeamCategory[]
    not?: NestedEnumTeamCategoryFilter<$PrismaModel> | $Enums.TeamCategory
  }

  export type NestedEnumTeamCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TeamCategory | EnumTeamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.TeamCategory[]
    notIn?: $Enums.TeamCategory[]
    not?: NestedEnumTeamCategoryWithAggregatesFilter<$PrismaModel> | $Enums.TeamCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTeamCategoryFilter<$PrismaModel>
    _max?: NestedEnumTeamCategoryFilter<$PrismaModel>
  }

  export type NestedEnumNotificationSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationSeverity | EnumNotificationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationSeverity[]
    notIn?: $Enums.NotificationSeverity[]
    not?: NestedEnumNotificationSeverityFilter<$PrismaModel> | $Enums.NotificationSeverity
  }

  export type NestedEnumNotificationSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationSeverity | EnumNotificationSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationSeverity[]
    notIn?: $Enums.NotificationSeverity[]
    not?: NestedEnumNotificationSeverityWithAggregatesFilter<$PrismaModel> | $Enums.NotificationSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationSeverityFilter<$PrismaModel>
    _max?: NestedEnumNotificationSeverityFilter<$PrismaModel>
  }

  export type AbonnementCreateWithoutOwnerInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    court?: CourtCreateNestedOneWithoutAbonnementsInput
    transactions?: TransactionCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationCreateNestedManyWithoutAboInput
  }

  export type AbonnementUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutAboInput
  }

  export type AbonnementCreateOrConnectWithoutOwnerInput = {
    where: AbonnementWhereUniqueInput
    create: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput>
  }

  export type AbonnementCreateManyOwnerInputEnvelope = {
    data: AbonnementCreateManyOwnerInput | AbonnementCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutOwnerInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    court?: CourtCreateNestedOneWithoutReservationsInput
    abo?: AbonnementCreateNestedOneWithoutReservationsInput
    fellows?: UserCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutOwnerInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    fellows?: UserUncheckedCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutOwnerInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput>
  }

  export type ReservationCreateManyOwnerInputEnvelope = {
    data: ReservationCreateManyOwnerInput | ReservationCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutFellowsInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    court?: CourtCreateNestedOneWithoutReservationsInput
    abo?: AbonnementCreateNestedOneWithoutReservationsInput
    owner?: UserCreateNestedOneWithoutOwnedReservationsInput
    transactions?: TransactionCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutFellowsInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutFellowsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput>
  }

  export type TransactionCreateWithoutUserInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    createdAt?: Date | string
    deleted?: boolean
    hallencard?: HallencardCreateNestedOneWithoutTransactionInput
    reservation?: ReservationCreateNestedOneWithoutTransactionsInput
    abonnement?: AbonnementCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutUserInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
    hallencard?: HallencardUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutUserInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionCreateManyUserInputEnvelope = {
    data: TransactionCreateManyUserInput | TransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    team: TeamCreateNestedOneWithoutMembersInput
    season: SeasonCreateNestedOneWithoutPlayersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    teamId: number
    seasonId: number
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamSeasonCreateWithoutTeamLeaderInput = {
    nuGroupId: string
    nuTeamId: string
    leagueName: string
    team: TeamCreateNestedOneWithoutTeamSeasonsInput
    season: SeasonCreateNestedOneWithoutTeamsInput
  }

  export type TeamSeasonUncheckedCreateWithoutTeamLeaderInput = {
    teamId: number
    seasonId: number
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamSeasonCreateOrConnectWithoutTeamLeaderInput = {
    where: TeamSeasonWhereUniqueInput
    create: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput>
  }

  export type TeamSeasonCreateManyTeamLeaderInputEnvelope = {
    data: TeamSeasonCreateManyTeamLeaderInput | TeamSeasonCreateManyTeamLeaderInput[]
    skipDuplicates?: boolean
  }

  export type UserRoleCreateWithoutUsersInput = {
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionCreateNestedManyWithoutUserRoleInput
    prices?: PriceCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutValidForInput
  }

  export type UserRoleUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserRoleInput
    prices?: PriceUncheckedCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutValidForInput
  }

  export type UserRoleCreateOrConnectWithoutUsersInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
  }

  export type EventCreateWithoutLikedByUsersInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    category: EventCategoryCreateNestedOneWithoutEventsInput
  }

  export type EventUncheckedCreateWithoutLikedByUsersInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    categoryId: string
  }

  export type EventCreateOrConnectWithoutLikedByUsersInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput>
  }

  export type AbonnementUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AbonnementWhereUniqueInput
    update: XOR<AbonnementUpdateWithoutOwnerInput, AbonnementUncheckedUpdateWithoutOwnerInput>
    create: XOR<AbonnementCreateWithoutOwnerInput, AbonnementUncheckedCreateWithoutOwnerInput>
  }

  export type AbonnementUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AbonnementWhereUniqueInput
    data: XOR<AbonnementUpdateWithoutOwnerInput, AbonnementUncheckedUpdateWithoutOwnerInput>
  }

  export type AbonnementUpdateManyWithWhereWithoutOwnerInput = {
    where: AbonnementScalarWhereInput
    data: XOR<AbonnementUpdateManyMutationInput, AbonnementUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AbonnementScalarWhereInput = {
    AND?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
    OR?: AbonnementScalarWhereInput[]
    NOT?: AbonnementScalarWhereInput | AbonnementScalarWhereInput[]
    id?: StringFilter<"Abonnement"> | string
    name?: StringFilter<"Abonnement"> | string
    weekday?: IntFilter<"Abonnement"> | number
    start?: DateTimeFilter<"Abonnement"> | Date | string
    duration?: FloatFilter<"Abonnement"> | number
    status?: EnumAbonnementStatusFilter<"Abonnement"> | $Enums.AbonnementStatus
    courtId?: StringNullableFilter<"Abonnement"> | string | null
    ownerId?: StringNullableFilter<"Abonnement"> | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutOwnerInput, ReservationUncheckedUpdateWithoutOwnerInput>
    create: XOR<ReservationCreateWithoutOwnerInput, ReservationUncheckedCreateWithoutOwnerInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutOwnerInput, ReservationUncheckedUpdateWithoutOwnerInput>
  }

  export type ReservationUpdateManyWithWhereWithoutOwnerInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: StringFilter<"Reservation"> | string
    title?: StringFilter<"Reservation"> | string
    start?: DateTimeFilter<"Reservation"> | Date | string
    end?: DateTimeFilter<"Reservation"> | Date | string
    courtId?: StringNullableFilter<"Reservation"> | string | null
    status?: EnumReservationStatusFilter<"Reservation"> | $Enums.ReservationStatus
    type?: EnumReservationTypeNullableFilter<"Reservation"> | $Enums.ReservationType | null
    paypalTransactionId?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatNullableFilter<"Reservation"> | number | null
    taxRate?: FloatNullableFilter<"Reservation"> | number | null
    light?: BoolFilter<"Reservation"> | boolean
    radiator?: BoolFilter<"Reservation"> | boolean
    abonnementId?: StringNullableFilter<"Reservation"> | string | null
    ownerId?: StringNullableFilter<"Reservation"> | string | null
    createdAt?: DateTimeFilter<"Reservation"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Reservation"> | Date | string | null
  }

  export type ReservationUpsertWithWhereUniqueWithoutFellowsInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutFellowsInput, ReservationUncheckedUpdateWithoutFellowsInput>
    create: XOR<ReservationCreateWithoutFellowsInput, ReservationUncheckedCreateWithoutFellowsInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutFellowsInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutFellowsInput, ReservationUncheckedUpdateWithoutFellowsInput>
  }

  export type ReservationUpdateManyWithWhereWithoutFellowsInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutFellowsInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
    create: XOR<TransactionCreateWithoutUserInput, TransactionUncheckedCreateWithoutUserInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutUserInput, TransactionUncheckedUpdateWithoutUserInput>
  }

  export type TransactionUpdateManyWithWhereWithoutUserInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    userId?: StringNullableFilter<"Transaction"> | string | null
    value?: FloatFilter<"Transaction"> | number
    currency?: StringFilter<"Transaction"> | string
    reason?: EnumTransactionReasonFilter<"Transaction"> | $Enums.TransactionReason
    paymentInformation?: StringNullableFilter<"Transaction"> | string | null
    reservationId?: StringNullableFilter<"Transaction"> | string | null
    abonnementId?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    deleted?: BoolFilter<"Transaction"> | boolean
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    userId?: StringFilter<"TeamMember"> | string
    teamId?: IntFilter<"TeamMember"> | number
    seasonId?: IntFilter<"TeamMember"> | number
  }

  export type TeamSeasonUpsertWithWhereUniqueWithoutTeamLeaderInput = {
    where: TeamSeasonWhereUniqueInput
    update: XOR<TeamSeasonUpdateWithoutTeamLeaderInput, TeamSeasonUncheckedUpdateWithoutTeamLeaderInput>
    create: XOR<TeamSeasonCreateWithoutTeamLeaderInput, TeamSeasonUncheckedCreateWithoutTeamLeaderInput>
  }

  export type TeamSeasonUpdateWithWhereUniqueWithoutTeamLeaderInput = {
    where: TeamSeasonWhereUniqueInput
    data: XOR<TeamSeasonUpdateWithoutTeamLeaderInput, TeamSeasonUncheckedUpdateWithoutTeamLeaderInput>
  }

  export type TeamSeasonUpdateManyWithWhereWithoutTeamLeaderInput = {
    where: TeamSeasonScalarWhereInput
    data: XOR<TeamSeasonUpdateManyMutationInput, TeamSeasonUncheckedUpdateManyWithoutTeamLeaderInput>
  }

  export type TeamSeasonScalarWhereInput = {
    AND?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
    OR?: TeamSeasonScalarWhereInput[]
    NOT?: TeamSeasonScalarWhereInput | TeamSeasonScalarWhereInput[]
    teamId?: IntFilter<"TeamSeason"> | number
    seasonId?: IntFilter<"TeamSeason"> | number
    teamLeaderId?: StringNullableFilter<"TeamSeason"> | string | null
    nuGroupId?: StringFilter<"TeamSeason"> | string
    nuTeamId?: StringFilter<"TeamSeason"> | string
    leagueName?: StringFilter<"TeamSeason"> | string
  }

  export type UserRoleUpsertWithWhereUniqueWithoutUsersInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
    create: XOR<UserRoleCreateWithoutUsersInput, UserRoleUncheckedCreateWithoutUsersInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutUsersInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutUsersInput, UserRoleUncheckedUpdateWithoutUsersInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutUsersInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutUsersInput>
  }

  export type UserRoleScalarWhereInput = {
    AND?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    OR?: UserRoleScalarWhereInput[]
    NOT?: UserRoleScalarWhereInput | UserRoleScalarWhereInput[]
    id?: IntFilter<"UserRole"> | number
    title?: StringFilter<"UserRole"> | string
    description?: StringNullableFilter<"UserRole"> | string | null
    isDefault?: BoolFilter<"UserRole"> | boolean
    priority?: IntFilter<"UserRole"> | number
  }

  export type EventUpsertWithWhereUniqueWithoutLikedByUsersInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutLikedByUsersInput, EventUncheckedUpdateWithoutLikedByUsersInput>
    create: XOR<EventCreateWithoutLikedByUsersInput, EventUncheckedCreateWithoutLikedByUsersInput>
  }

  export type EventUpdateWithWhereUniqueWithoutLikedByUsersInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutLikedByUsersInput, EventUncheckedUpdateWithoutLikedByUsersInput>
  }

  export type EventUpdateManyWithWhereWithoutLikedByUsersInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutLikedByUsersInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    image?: StringNullableFilter<"Event"> | string | null
    start?: DateTimeFilter<"Event"> | Date | string
    end?: DateTimeNullableFilter<"Event"> | Date | string | null
    canceled?: BoolFilter<"Event"> | boolean
    revised?: BoolFilter<"Event"> | boolean
    link?: StringNullableFilter<"Event"> | string | null
    location?: StringNullableFilter<"Event"> | string | null
    categoryId?: StringFilter<"Event"> | string
  }

  export type CourtCreateWithoutAreaInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    abonnements?: AbonnementCreateNestedManyWithoutCourtInput
    reservations?: ReservationCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateWithoutAreaInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutCourtInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtCreateOrConnectWithoutAreaInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput>
  }

  export type CourtCreateManyAreaInputEnvelope = {
    data: CourtCreateManyAreaInput | CourtCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ReservationRuleCreateWithoutAffectedAreasInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleUncheckedCreateWithoutAffectedAreasInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleUncheckedCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtUncheckedCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleCreateOrConnectWithoutAffectedAreasInput = {
    where: ReservationRuleWhereUniqueInput
    create: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput>
  }

  export type PriceCreateWithoutAreasInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    roles?: UserRoleCreateNestedManyWithoutPricesInput
  }

  export type PriceUncheckedCreateWithoutAreasInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    roles?: UserRoleUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PriceCreateOrConnectWithoutAreasInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput>
  }

  export type CourtUpsertWithWhereUniqueWithoutAreaInput = {
    where: CourtWhereUniqueInput
    update: XOR<CourtUpdateWithoutAreaInput, CourtUncheckedUpdateWithoutAreaInput>
    create: XOR<CourtCreateWithoutAreaInput, CourtUncheckedCreateWithoutAreaInput>
  }

  export type CourtUpdateWithWhereUniqueWithoutAreaInput = {
    where: CourtWhereUniqueInput
    data: XOR<CourtUpdateWithoutAreaInput, CourtUncheckedUpdateWithoutAreaInput>
  }

  export type CourtUpdateManyWithWhereWithoutAreaInput = {
    where: CourtScalarWhereInput
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyWithoutAreaInput>
  }

  export type CourtScalarWhereInput = {
    AND?: CourtScalarWhereInput | CourtScalarWhereInput[]
    OR?: CourtScalarWhereInput[]
    NOT?: CourtScalarWhereInput | CourtScalarWhereInput[]
    id?: StringFilter<"Court"> | string
    name?: StringFilter<"Court"> | string
    shortName?: StringNullableFilter<"Court"> | string | null
    description?: StringNullableFilter<"Court"> | string | null
    order?: IntNullableFilter<"Court"> | number | null
    active?: BoolFilter<"Court"> | boolean
    activeFrom?: DateTimeNullableFilter<"Court"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Court"> | Date | string | null
    areaId?: IntFilter<"Court"> | number
  }

  export type ReservationRuleUpsertWithWhereUniqueWithoutAffectedAreasInput = {
    where: ReservationRuleWhereUniqueInput
    update: XOR<ReservationRuleUpdateWithoutAffectedAreasInput, ReservationRuleUncheckedUpdateWithoutAffectedAreasInput>
    create: XOR<ReservationRuleCreateWithoutAffectedAreasInput, ReservationRuleUncheckedCreateWithoutAffectedAreasInput>
  }

  export type ReservationRuleUpdateWithWhereUniqueWithoutAffectedAreasInput = {
    where: ReservationRuleWhereUniqueInput
    data: XOR<ReservationRuleUpdateWithoutAffectedAreasInput, ReservationRuleUncheckedUpdateWithoutAffectedAreasInput>
  }

  export type ReservationRuleUpdateManyWithWhereWithoutAffectedAreasInput = {
    where: ReservationRuleScalarWhereInput
    data: XOR<ReservationRuleUpdateManyMutationInput, ReservationRuleUncheckedUpdateManyWithoutAffectedAreasInput>
  }

  export type ReservationRuleScalarWhereInput = {
    AND?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
    OR?: ReservationRuleScalarWhereInput[]
    NOT?: ReservationRuleScalarWhereInput | ReservationRuleScalarWhereInput[]
    id?: StringFilter<"ReservationRule"> | string
    name?: StringFilter<"ReservationRule"> | string
    errorDescription?: StringNullableFilter<"ReservationRule"> | string | null
    checkOn?: EnumReservationRuleCheckOnFilter<"ReservationRule"> | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: StringNullableFilter<"ReservationRule"> | string | null
    value?: StringFilter<"ReservationRule"> | string
  }

  export type PriceUpsertWithWhereUniqueWithoutAreasInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutAreasInput, PriceUncheckedUpdateWithoutAreasInput>
    create: XOR<PriceCreateWithoutAreasInput, PriceUncheckedCreateWithoutAreasInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutAreasInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutAreasInput, PriceUncheckedUpdateWithoutAreasInput>
  }

  export type PriceUpdateManyWithWhereWithoutAreasInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutAreasInput>
  }

  export type PriceScalarWhereInput = {
    AND?: PriceScalarWhereInput | PriceScalarWhereInput[]
    OR?: PriceScalarWhereInput[]
    NOT?: PriceScalarWhereInput | PriceScalarWhereInput[]
    id?: StringFilter<"Price"> | string
    validFrom?: DateTimeNullableFilter<"Price"> | Date | string | null
    validTo?: DateTimeNullableFilter<"Price"> | Date | string | null
    isDefault?: BoolFilter<"Price"> | boolean
    mon?: BoolFilter<"Price"> | boolean
    tue?: BoolFilter<"Price"> | boolean
    wed?: BoolFilter<"Price"> | boolean
    thu?: BoolFilter<"Price"> | boolean
    fri?: BoolFilter<"Price"> | boolean
    sat?: BoolFilter<"Price"> | boolean
    sun?: BoolFilter<"Price"> | boolean
    from?: IntFilter<"Price"> | number
    to?: IntFilter<"Price"> | number
    value?: FloatFilter<"Price"> | number
    currency?: StringFilter<"Price"> | string
    taxes?: FloatFilter<"Price"> | number
  }

  export type AreaCreateWithoutCourtsInput = {
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedAreasInput
    prices?: PriceCreateNestedManyWithoutAreasInput
  }

  export type AreaUncheckedCreateWithoutCourtsInput = {
    id?: number
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedAreasInput
    prices?: PriceUncheckedCreateNestedManyWithoutAreasInput
  }

  export type AreaCreateOrConnectWithoutCourtsInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutCourtsInput, AreaUncheckedCreateWithoutCourtsInput>
  }

  export type AbonnementCreateWithoutCourtInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    owner?: UserCreateNestedOneWithoutAbonnementsInput
    transactions?: TransactionCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationCreateNestedManyWithoutAboInput
  }

  export type AbonnementUncheckedCreateWithoutCourtInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    ownerId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutAbonnementInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutAboInput
  }

  export type AbonnementCreateOrConnectWithoutCourtInput = {
    where: AbonnementWhereUniqueInput
    create: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput>
  }

  export type AbonnementCreateManyCourtInputEnvelope = {
    data: AbonnementCreateManyCourtInput | AbonnementCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutCourtInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    abo?: AbonnementCreateNestedOneWithoutReservationsInput
    owner?: UserCreateNestedOneWithoutOwnedReservationsInput
    fellows?: UserCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutCourtInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    fellows?: UserUncheckedCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutCourtInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput>
  }

  export type ReservationCreateManyCourtInputEnvelope = {
    data: ReservationCreateManyCourtInput | ReservationCreateManyCourtInput[]
    skipDuplicates?: boolean
  }

  export type ReservationRuleCreateWithoutAffectedCourtsInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleCreateNestedManyWithoutReservationRulesInput
    affectedAreas?: AreaCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleUncheckedCreateWithoutAffectedCourtsInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    validFor?: UserRoleUncheckedCreateNestedManyWithoutReservationRulesInput
    affectedAreas?: AreaUncheckedCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleCreateOrConnectWithoutAffectedCourtsInput = {
    where: ReservationRuleWhereUniqueInput
    create: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput>
  }

  export type ControlInterfaceCreateWithoutAffectedCourtsInput = {
    id?: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd?: boolean
    connectByOr?: boolean
  }

  export type ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput = {
    id?: string
    title: string
    description: string
    preBooking: number
    postBooking: number
    connectByAnd?: boolean
    connectByOr?: boolean
  }

  export type ControlInterfaceCreateOrConnectWithoutAffectedCourtsInput = {
    where: ControlInterfaceWhereUniqueInput
    create: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput>
  }

  export type AreaUpsertWithoutCourtsInput = {
    update: XOR<AreaUpdateWithoutCourtsInput, AreaUncheckedUpdateWithoutCourtsInput>
    create: XOR<AreaCreateWithoutCourtsInput, AreaUncheckedCreateWithoutCourtsInput>
    where?: AreaWhereInput
  }

  export type AreaUpdateToOneWithWhereWithoutCourtsInput = {
    where?: AreaWhereInput
    data: XOR<AreaUpdateWithoutCourtsInput, AreaUncheckedUpdateWithoutCourtsInput>
  }

  export type AreaUpdateWithoutCourtsInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedAreasNestedInput
    prices?: PriceUpdateManyWithoutAreasNestedInput
  }

  export type AreaUncheckedUpdateWithoutCourtsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedAreasNestedInput
    prices?: PriceUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type AbonnementUpsertWithWhereUniqueWithoutCourtInput = {
    where: AbonnementWhereUniqueInput
    update: XOR<AbonnementUpdateWithoutCourtInput, AbonnementUncheckedUpdateWithoutCourtInput>
    create: XOR<AbonnementCreateWithoutCourtInput, AbonnementUncheckedCreateWithoutCourtInput>
  }

  export type AbonnementUpdateWithWhereUniqueWithoutCourtInput = {
    where: AbonnementWhereUniqueInput
    data: XOR<AbonnementUpdateWithoutCourtInput, AbonnementUncheckedUpdateWithoutCourtInput>
  }

  export type AbonnementUpdateManyWithWhereWithoutCourtInput = {
    where: AbonnementScalarWhereInput
    data: XOR<AbonnementUpdateManyMutationInput, AbonnementUncheckedUpdateManyWithoutCourtInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutCourtInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutCourtInput, ReservationUncheckedUpdateWithoutCourtInput>
    create: XOR<ReservationCreateWithoutCourtInput, ReservationUncheckedCreateWithoutCourtInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutCourtInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutCourtInput, ReservationUncheckedUpdateWithoutCourtInput>
  }

  export type ReservationUpdateManyWithWhereWithoutCourtInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutCourtInput>
  }

  export type ReservationRuleUpsertWithWhereUniqueWithoutAffectedCourtsInput = {
    where: ReservationRuleWhereUniqueInput
    update: XOR<ReservationRuleUpdateWithoutAffectedCourtsInput, ReservationRuleUncheckedUpdateWithoutAffectedCourtsInput>
    create: XOR<ReservationRuleCreateWithoutAffectedCourtsInput, ReservationRuleUncheckedCreateWithoutAffectedCourtsInput>
  }

  export type ReservationRuleUpdateWithWhereUniqueWithoutAffectedCourtsInput = {
    where: ReservationRuleWhereUniqueInput
    data: XOR<ReservationRuleUpdateWithoutAffectedCourtsInput, ReservationRuleUncheckedUpdateWithoutAffectedCourtsInput>
  }

  export type ReservationRuleUpdateManyWithWhereWithoutAffectedCourtsInput = {
    where: ReservationRuleScalarWhereInput
    data: XOR<ReservationRuleUpdateManyMutationInput, ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsInput>
  }

  export type ControlInterfaceUpsertWithWhereUniqueWithoutAffectedCourtsInput = {
    where: ControlInterfaceWhereUniqueInput
    update: XOR<ControlInterfaceUpdateWithoutAffectedCourtsInput, ControlInterfaceUncheckedUpdateWithoutAffectedCourtsInput>
    create: XOR<ControlInterfaceCreateWithoutAffectedCourtsInput, ControlInterfaceUncheckedCreateWithoutAffectedCourtsInput>
  }

  export type ControlInterfaceUpdateWithWhereUniqueWithoutAffectedCourtsInput = {
    where: ControlInterfaceWhereUniqueInput
    data: XOR<ControlInterfaceUpdateWithoutAffectedCourtsInput, ControlInterfaceUncheckedUpdateWithoutAffectedCourtsInput>
  }

  export type ControlInterfaceUpdateManyWithWhereWithoutAffectedCourtsInput = {
    where: ControlInterfaceScalarWhereInput
    data: XOR<ControlInterfaceUpdateManyMutationInput, ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsInput>
  }

  export type ControlInterfaceScalarWhereInput = {
    AND?: ControlInterfaceScalarWhereInput | ControlInterfaceScalarWhereInput[]
    OR?: ControlInterfaceScalarWhereInput[]
    NOT?: ControlInterfaceScalarWhereInput | ControlInterfaceScalarWhereInput[]
    id?: StringFilter<"ControlInterface"> | string
    title?: StringFilter<"ControlInterface"> | string
    description?: StringFilter<"ControlInterface"> | string
    preBooking?: IntFilter<"ControlInterface"> | number
    postBooking?: IntFilter<"ControlInterface"> | number
    connectByAnd?: BoolFilter<"ControlInterface"> | boolean
    connectByOr?: BoolFilter<"ControlInterface"> | boolean
  }

  export type CourtCreateWithoutReservationsInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    area: AreaCreateNestedOneWithoutCourtsInput
    abonnements?: AbonnementCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtCreateOrConnectWithoutReservationsInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutReservationsInput, CourtUncheckedCreateWithoutReservationsInput>
  }

  export type AbonnementCreateWithoutReservationsInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    court?: CourtCreateNestedOneWithoutAbonnementsInput
    owner?: UserCreateNestedOneWithoutAbonnementsInput
    transactions?: TransactionCreateNestedManyWithoutAbonnementInput
  }

  export type AbonnementUncheckedCreateWithoutReservationsInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
    ownerId?: string | null
    transactions?: TransactionUncheckedCreateNestedManyWithoutAbonnementInput
  }

  export type AbonnementCreateOrConnectWithoutReservationsInput = {
    where: AbonnementWhereUniqueInput
    create: XOR<AbonnementCreateWithoutReservationsInput, AbonnementUncheckedCreateWithoutReservationsInput>
  }

  export type UserCreateWithoutOwnedReservationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutOwnedReservationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutOwnedReservationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutOwnedReservationsInput, UserUncheckedCreateWithoutOwnedReservationsInput>
  }

  export type UserCreateWithoutFellowedReservationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutFellowedReservationsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutFellowedReservationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput>
  }

  export type TransactionCreateWithoutReservationInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    createdAt?: Date | string
    deleted?: boolean
    user?: UserCreateNestedOneWithoutTransactionsInput
    hallencard?: HallencardCreateNestedOneWithoutTransactionInput
    abonnement?: AbonnementCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutReservationInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
    hallencard?: HallencardUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutReservationInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput>
  }

  export type TransactionCreateManyReservationInputEnvelope = {
    data: TransactionCreateManyReservationInput | TransactionCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type CourtUpsertWithoutReservationsInput = {
    update: XOR<CourtUpdateWithoutReservationsInput, CourtUncheckedUpdateWithoutReservationsInput>
    create: XOR<CourtCreateWithoutReservationsInput, CourtUncheckedCreateWithoutReservationsInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutReservationsInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutReservationsInput, CourtUncheckedUpdateWithoutReservationsInput>
  }

  export type CourtUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: AreaUpdateOneRequiredWithoutCourtsNestedInput
    abonnements?: AbonnementUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
    abonnements?: AbonnementUncheckedUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type AbonnementUpsertWithoutReservationsInput = {
    update: XOR<AbonnementUpdateWithoutReservationsInput, AbonnementUncheckedUpdateWithoutReservationsInput>
    create: XOR<AbonnementCreateWithoutReservationsInput, AbonnementUncheckedCreateWithoutReservationsInput>
    where?: AbonnementWhereInput
  }

  export type AbonnementUpdateToOneWithWhereWithoutReservationsInput = {
    where?: AbonnementWhereInput
    data: XOR<AbonnementUpdateWithoutReservationsInput, AbonnementUncheckedUpdateWithoutReservationsInput>
  }

  export type AbonnementUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    court?: CourtUpdateOneWithoutAbonnementsNestedInput
    owner?: UserUpdateOneWithoutAbonnementsNestedInput
    transactions?: TransactionUpdateManyWithoutAbonnementNestedInput
  }

  export type AbonnementUncheckedUpdateWithoutReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutAbonnementNestedInput
  }

  export type UserUpsertWithoutOwnedReservationsInput = {
    update: XOR<UserUpdateWithoutOwnedReservationsInput, UserUncheckedUpdateWithoutOwnedReservationsInput>
    create: XOR<UserCreateWithoutOwnedReservationsInput, UserUncheckedCreateWithoutOwnedReservationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutOwnedReservationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutOwnedReservationsInput, UserUncheckedUpdateWithoutOwnedReservationsInput>
  }

  export type UserUpdateWithoutOwnedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutOwnedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUpsertWithWhereUniqueWithoutFellowedReservationsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutFellowedReservationsInput, UserUncheckedUpdateWithoutFellowedReservationsInput>
    create: XOR<UserCreateWithoutFellowedReservationsInput, UserUncheckedCreateWithoutFellowedReservationsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutFellowedReservationsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutFellowedReservationsInput, UserUncheckedUpdateWithoutFellowedReservationsInput>
  }

  export type UserUpdateManyWithWhereWithoutFellowedReservationsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutFellowedReservationsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    image?: StringNullableFilter<"User"> | string | null
    auth0Id?: StringFilter<"User"> | string
    address?: StringNullableFilter<"User"> | string | null
    cityCode?: StringNullableFilter<"User"> | string | null
    cityName?: StringNullableFilter<"User"> | string | null
    countryCode?: StringNullableFilter<"User"> | string | null
    needsSetup?: BoolFilter<"User"> | boolean
    publicName?: BoolFilter<"User"> | boolean
    phoneNumber?: StringNullableFilter<"User"> | string | null
  }

  export type TransactionUpsertWithWhereUniqueWithoutReservationInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutReservationInput, TransactionUncheckedUpdateWithoutReservationInput>
    create: XOR<TransactionCreateWithoutReservationInput, TransactionUncheckedCreateWithoutReservationInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutReservationInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutReservationInput, TransactionUncheckedUpdateWithoutReservationInput>
  }

  export type TransactionUpdateManyWithWhereWithoutReservationInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutReservationInput>
  }

  export type UserRoleCreateWithoutReservationRulesInput = {
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionCreateNestedManyWithoutUserRoleInput
    users?: UserCreateNestedManyWithoutRolesInput
    prices?: PriceCreateNestedManyWithoutRolesInput
  }

  export type UserRoleUncheckedCreateWithoutReservationRulesInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    prices?: PriceUncheckedCreateNestedManyWithoutRolesInput
  }

  export type UserRoleCreateOrConnectWithoutReservationRulesInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput>
  }

  export type AreaCreateWithoutReservationRulesInput = {
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtCreateNestedManyWithoutAreaInput
    prices?: PriceCreateNestedManyWithoutAreasInput
  }

  export type AreaUncheckedCreateWithoutReservationRulesInput = {
    id?: number
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtUncheckedCreateNestedManyWithoutAreaInput
    prices?: PriceUncheckedCreateNestedManyWithoutAreasInput
  }

  export type AreaCreateOrConnectWithoutReservationRulesInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput>
  }

  export type CourtCreateWithoutReservationRulesInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    area: AreaCreateNestedOneWithoutCourtsInput
    abonnements?: AbonnementCreateNestedManyWithoutCourtInput
    reservations?: ReservationCreateNestedManyWithoutCourtInput
    controlInterfaces?: ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateWithoutReservationRulesInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutCourtInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCourtInput
    controlInterfaces?: ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtCreateOrConnectWithoutReservationRulesInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutReservationRulesInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutReservationRulesInput, UserRoleUncheckedUpdateWithoutReservationRulesInput>
    create: XOR<UserRoleCreateWithoutReservationRulesInput, UserRoleUncheckedCreateWithoutReservationRulesInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutReservationRulesInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutReservationRulesInput, UserRoleUncheckedUpdateWithoutReservationRulesInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutReservationRulesInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutReservationRulesInput>
  }

  export type AreaUpsertWithWhereUniqueWithoutReservationRulesInput = {
    where: AreaWhereUniqueInput
    update: XOR<AreaUpdateWithoutReservationRulesInput, AreaUncheckedUpdateWithoutReservationRulesInput>
    create: XOR<AreaCreateWithoutReservationRulesInput, AreaUncheckedCreateWithoutReservationRulesInput>
  }

  export type AreaUpdateWithWhereUniqueWithoutReservationRulesInput = {
    where: AreaWhereUniqueInput
    data: XOR<AreaUpdateWithoutReservationRulesInput, AreaUncheckedUpdateWithoutReservationRulesInput>
  }

  export type AreaUpdateManyWithWhereWithoutReservationRulesInput = {
    where: AreaScalarWhereInput
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyWithoutReservationRulesInput>
  }

  export type AreaScalarWhereInput = {
    AND?: AreaScalarWhereInput | AreaScalarWhereInput[]
    OR?: AreaScalarWhereInput[]
    NOT?: AreaScalarWhereInput | AreaScalarWhereInput[]
    id?: IntFilter<"Area"> | number
    name?: StringFilter<"Area"> | string
    shortName?: StringFilter<"Area"> | string
    activeFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    activeTo?: DateTimeNullableFilter<"Area"> | Date | string | null
    bookableFrom?: DateTimeNullableFilter<"Area"> | Date | string | null
    order?: IntNullableFilter<"Area"> | number | null
  }

  export type CourtUpsertWithWhereUniqueWithoutReservationRulesInput = {
    where: CourtWhereUniqueInput
    update: XOR<CourtUpdateWithoutReservationRulesInput, CourtUncheckedUpdateWithoutReservationRulesInput>
    create: XOR<CourtCreateWithoutReservationRulesInput, CourtUncheckedCreateWithoutReservationRulesInput>
  }

  export type CourtUpdateWithWhereUniqueWithoutReservationRulesInput = {
    where: CourtWhereUniqueInput
    data: XOR<CourtUpdateWithoutReservationRulesInput, CourtUncheckedUpdateWithoutReservationRulesInput>
  }

  export type CourtUpdateManyWithWhereWithoutReservationRulesInput = {
    where: CourtScalarWhereInput
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyWithoutReservationRulesInput>
  }

  export type CourtCreateWithoutAbonnementsInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    area: AreaCreateNestedOneWithoutCourtsInput
    reservations?: ReservationCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateWithoutAbonnementsInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
    reservations?: ReservationUncheckedCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput
    controlInterfaces?: ControlInterfaceUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtCreateOrConnectWithoutAbonnementsInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutAbonnementsInput, CourtUncheckedCreateWithoutAbonnementsInput>
  }

  export type UserCreateWithoutAbonnementsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutAbonnementsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutAbonnementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAbonnementsInput, UserUncheckedCreateWithoutAbonnementsInput>
  }

  export type TransactionCreateWithoutAbonnementInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    createdAt?: Date | string
    deleted?: boolean
    user?: UserCreateNestedOneWithoutTransactionsInput
    hallencard?: HallencardCreateNestedOneWithoutTransactionInput
    reservation?: ReservationCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutAbonnementInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    createdAt?: Date | string
    deleted?: boolean
    hallencard?: HallencardUncheckedCreateNestedOneWithoutTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAbonnementInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput>
  }

  export type TransactionCreateManyAbonnementInputEnvelope = {
    data: TransactionCreateManyAbonnementInput | TransactionCreateManyAbonnementInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutAboInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    court?: CourtCreateNestedOneWithoutReservationsInput
    owner?: UserCreateNestedOneWithoutOwnedReservationsInput
    fellows?: UserCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionCreateNestedManyWithoutReservationInput
  }

  export type ReservationUncheckedCreateWithoutAboInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    fellows?: UserUncheckedCreateNestedManyWithoutFellowedReservationsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutAboInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput>
  }

  export type ReservationCreateManyAboInputEnvelope = {
    data: ReservationCreateManyAboInput | ReservationCreateManyAboInput[]
    skipDuplicates?: boolean
  }

  export type CourtUpsertWithoutAbonnementsInput = {
    update: XOR<CourtUpdateWithoutAbonnementsInput, CourtUncheckedUpdateWithoutAbonnementsInput>
    create: XOR<CourtCreateWithoutAbonnementsInput, CourtUncheckedCreateWithoutAbonnementsInput>
    where?: CourtWhereInput
  }

  export type CourtUpdateToOneWithWhereWithoutAbonnementsInput = {
    where?: CourtWhereInput
    data: XOR<CourtUpdateWithoutAbonnementsInput, CourtUncheckedUpdateWithoutAbonnementsInput>
  }

  export type CourtUpdateWithoutAbonnementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: AreaUpdateOneRequiredWithoutCourtsNestedInput
    reservations?: ReservationUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutAbonnementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
    reservations?: ReservationUncheckedUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type UserUpsertWithoutAbonnementsInput = {
    update: XOR<UserUpdateWithoutAbonnementsInput, UserUncheckedUpdateWithoutAbonnementsInput>
    create: XOR<UserCreateWithoutAbonnementsInput, UserUncheckedCreateWithoutAbonnementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAbonnementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAbonnementsInput, UserUncheckedUpdateWithoutAbonnementsInput>
  }

  export type UserUpdateWithoutAbonnementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutAbonnementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type TransactionUpsertWithWhereUniqueWithoutAbonnementInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAbonnementInput, TransactionUncheckedUpdateWithoutAbonnementInput>
    create: XOR<TransactionCreateWithoutAbonnementInput, TransactionUncheckedCreateWithoutAbonnementInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAbonnementInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAbonnementInput, TransactionUncheckedUpdateWithoutAbonnementInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAbonnementInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAbonnementInput>
  }

  export type ReservationUpsertWithWhereUniqueWithoutAboInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutAboInput, ReservationUncheckedUpdateWithoutAboInput>
    create: XOR<ReservationCreateWithoutAboInput, ReservationUncheckedCreateWithoutAboInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutAboInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutAboInput, ReservationUncheckedUpdateWithoutAboInput>
  }

  export type ReservationUpdateManyWithWhereWithoutAboInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutAboInput>
  }

  export type PermissionCreateWithoutUserRoleInput = {
    router: string
    action: string
    allowed?: $Enums.PermissionState
  }

  export type PermissionUncheckedCreateWithoutUserRoleInput = {
    router: string
    action: string
    allowed?: $Enums.PermissionState
  }

  export type PermissionCreateOrConnectWithoutUserRoleInput = {
    where: PermissionWhereUniqueInput
    create: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput>
  }

  export type PermissionCreateManyUserRoleInputEnvelope = {
    data: PermissionCreateManyUserRoleInput | PermissionCreateManyUserRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutRolesInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutRolesInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutRolesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type PriceCreateWithoutRolesInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    areas?: AreaCreateNestedManyWithoutPricesInput
  }

  export type PriceUncheckedCreateWithoutRolesInput = {
    id?: string
    validFrom?: Date | string | null
    validTo?: Date | string | null
    isDefault?: boolean
    mon?: boolean
    tue?: boolean
    wed?: boolean
    thu?: boolean
    fri?: boolean
    sat?: boolean
    sun?: boolean
    from: number
    to: number
    value: number
    currency?: string
    taxes: number
    areas?: AreaUncheckedCreateNestedManyWithoutPricesInput
  }

  export type PriceCreateOrConnectWithoutRolesInput = {
    where: PriceWhereUniqueInput
    create: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput>
  }

  export type ReservationRuleCreateWithoutValidForInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    affectedAreas?: AreaCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleUncheckedCreateWithoutValidForInput = {
    id?: string
    name: string
    errorDescription?: string | null
    checkOn: $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: string | null
    value: string
    affectedAreas?: AreaUncheckedCreateNestedManyWithoutReservationRulesInput
    affectedCourts?: CourtUncheckedCreateNestedManyWithoutReservationRulesInput
  }

  export type ReservationRuleCreateOrConnectWithoutValidForInput = {
    where: ReservationRuleWhereUniqueInput
    create: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput>
  }

  export type PermissionUpsertWithWhereUniqueWithoutUserRoleInput = {
    where: PermissionWhereUniqueInput
    update: XOR<PermissionUpdateWithoutUserRoleInput, PermissionUncheckedUpdateWithoutUserRoleInput>
    create: XOR<PermissionCreateWithoutUserRoleInput, PermissionUncheckedCreateWithoutUserRoleInput>
  }

  export type PermissionUpdateWithWhereUniqueWithoutUserRoleInput = {
    where: PermissionWhereUniqueInput
    data: XOR<PermissionUpdateWithoutUserRoleInput, PermissionUncheckedUpdateWithoutUserRoleInput>
  }

  export type PermissionUpdateManyWithWhereWithoutUserRoleInput = {
    where: PermissionScalarWhereInput
    data: XOR<PermissionUpdateManyMutationInput, PermissionUncheckedUpdateManyWithoutUserRoleInput>
  }

  export type PermissionScalarWhereInput = {
    AND?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    OR?: PermissionScalarWhereInput[]
    NOT?: PermissionScalarWhereInput | PermissionScalarWhereInput[]
    router?: StringFilter<"Permission"> | string
    action?: StringFilter<"Permission"> | string
    userRoleId?: IntFilter<"Permission"> | number
    allowed?: EnumPermissionStateFilter<"Permission"> | $Enums.PermissionState
  }

  export type UserUpsertWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
    create: XOR<UserCreateWithoutRolesInput, UserUncheckedCreateWithoutRolesInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRolesInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRolesInput, UserUncheckedUpdateWithoutRolesInput>
  }

  export type UserUpdateManyWithWhereWithoutRolesInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRolesInput>
  }

  export type PriceUpsertWithWhereUniqueWithoutRolesInput = {
    where: PriceWhereUniqueInput
    update: XOR<PriceUpdateWithoutRolesInput, PriceUncheckedUpdateWithoutRolesInput>
    create: XOR<PriceCreateWithoutRolesInput, PriceUncheckedCreateWithoutRolesInput>
  }

  export type PriceUpdateWithWhereUniqueWithoutRolesInput = {
    where: PriceWhereUniqueInput
    data: XOR<PriceUpdateWithoutRolesInput, PriceUncheckedUpdateWithoutRolesInput>
  }

  export type PriceUpdateManyWithWhereWithoutRolesInput = {
    where: PriceScalarWhereInput
    data: XOR<PriceUpdateManyMutationInput, PriceUncheckedUpdateManyWithoutRolesInput>
  }

  export type ReservationRuleUpsertWithWhereUniqueWithoutValidForInput = {
    where: ReservationRuleWhereUniqueInput
    update: XOR<ReservationRuleUpdateWithoutValidForInput, ReservationRuleUncheckedUpdateWithoutValidForInput>
    create: XOR<ReservationRuleCreateWithoutValidForInput, ReservationRuleUncheckedCreateWithoutValidForInput>
  }

  export type ReservationRuleUpdateWithWhereUniqueWithoutValidForInput = {
    where: ReservationRuleWhereUniqueInput
    data: XOR<ReservationRuleUpdateWithoutValidForInput, ReservationRuleUncheckedUpdateWithoutValidForInput>
  }

  export type ReservationRuleUpdateManyWithWhereWithoutValidForInput = {
    where: ReservationRuleScalarWhereInput
    data: XOR<ReservationRuleUpdateManyMutationInput, ReservationRuleUncheckedUpdateManyWithoutValidForInput>
  }

  export type UserRoleCreateWithoutPermissionsInput = {
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    users?: UserCreateNestedManyWithoutRolesInput
    prices?: PriceCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutValidForInput
  }

  export type UserRoleUncheckedCreateWithoutPermissionsInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    prices?: PriceUncheckedCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutValidForInput
  }

  export type UserRoleCreateOrConnectWithoutPermissionsInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
  }

  export type UserRoleUpsertWithoutPermissionsInput = {
    update: XOR<UserRoleUpdateWithoutPermissionsInput, UserRoleUncheckedUpdateWithoutPermissionsInput>
    create: XOR<UserRoleCreateWithoutPermissionsInput, UserRoleUncheckedCreateWithoutPermissionsInput>
    where?: UserRoleWhereInput
  }

  export type UserRoleUpdateToOneWithWhereWithoutPermissionsInput = {
    where?: UserRoleWhereInput
    data: XOR<UserRoleUpdateWithoutPermissionsInput, UserRoleUncheckedUpdateWithoutPermissionsInput>
  }

  export type UserRoleUpdateWithoutPermissionsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    users?: UserUpdateManyWithoutRolesNestedInput
    prices?: PriceUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    prices?: PriceUncheckedUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutValidForNestedInput
  }

  export type TransactionCreateWithoutHallencardInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    createdAt?: Date | string
    deleted?: boolean
    user?: UserCreateNestedOneWithoutTransactionsInput
    reservation?: ReservationCreateNestedOneWithoutTransactionsInput
    abonnement?: AbonnementCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutHallencardInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
  }

  export type TransactionCreateOrConnectWithoutHallencardInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutHallencardInput, TransactionUncheckedCreateWithoutHallencardInput>
  }

  export type TransactionUpsertWithoutHallencardInput = {
    update: XOR<TransactionUpdateWithoutHallencardInput, TransactionUncheckedUpdateWithoutHallencardInput>
    create: XOR<TransactionCreateWithoutHallencardInput, TransactionUncheckedCreateWithoutHallencardInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutHallencardInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutHallencardInput, TransactionUncheckedUpdateWithoutHallencardInput>
  }

  export type TransactionUpdateWithoutHallencardInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutTransactionsNestedInput
    reservation?: ReservationUpdateOneWithoutTransactionsNestedInput
    abonnement?: AbonnementUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutHallencardInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleCreateWithoutPricesInput = {
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionCreateNestedManyWithoutUserRoleInput
    users?: UserCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutValidForInput
  }

  export type UserRoleUncheckedCreateWithoutPricesInput = {
    id?: number
    title: string
    description?: string | null
    isDefault?: boolean
    priority?: number
    permissions?: PermissionUncheckedCreateNestedManyWithoutUserRoleInput
    users?: UserUncheckedCreateNestedManyWithoutRolesInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutValidForInput
  }

  export type UserRoleCreateOrConnectWithoutPricesInput = {
    where: UserRoleWhereUniqueInput
    create: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput>
  }

  export type AreaCreateWithoutPricesInput = {
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtCreateNestedManyWithoutAreaInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedAreasInput
  }

  export type AreaUncheckedCreateWithoutPricesInput = {
    id?: number
    name: string
    shortName: string
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    bookableFrom?: Date | string | null
    order?: number | null
    courts?: CourtUncheckedCreateNestedManyWithoutAreaInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedAreasInput
  }

  export type AreaCreateOrConnectWithoutPricesInput = {
    where: AreaWhereUniqueInput
    create: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput>
  }

  export type UserRoleUpsertWithWhereUniqueWithoutPricesInput = {
    where: UserRoleWhereUniqueInput
    update: XOR<UserRoleUpdateWithoutPricesInput, UserRoleUncheckedUpdateWithoutPricesInput>
    create: XOR<UserRoleCreateWithoutPricesInput, UserRoleUncheckedCreateWithoutPricesInput>
  }

  export type UserRoleUpdateWithWhereUniqueWithoutPricesInput = {
    where: UserRoleWhereUniqueInput
    data: XOR<UserRoleUpdateWithoutPricesInput, UserRoleUncheckedUpdateWithoutPricesInput>
  }

  export type UserRoleUpdateManyWithWhereWithoutPricesInput = {
    where: UserRoleScalarWhereInput
    data: XOR<UserRoleUpdateManyMutationInput, UserRoleUncheckedUpdateManyWithoutPricesInput>
  }

  export type AreaUpsertWithWhereUniqueWithoutPricesInput = {
    where: AreaWhereUniqueInput
    update: XOR<AreaUpdateWithoutPricesInput, AreaUncheckedUpdateWithoutPricesInput>
    create: XOR<AreaCreateWithoutPricesInput, AreaUncheckedCreateWithoutPricesInput>
  }

  export type AreaUpdateWithWhereUniqueWithoutPricesInput = {
    where: AreaWhereUniqueInput
    data: XOR<AreaUpdateWithoutPricesInput, AreaUncheckedUpdateWithoutPricesInput>
  }

  export type AreaUpdateManyWithWhereWithoutPricesInput = {
    where: AreaScalarWhereInput
    data: XOR<AreaUpdateManyMutationInput, AreaUncheckedUpdateManyWithoutPricesInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type HallencardCreateWithoutTransactionInput = {
    code: string
    pin: string
    value: number
    printed: boolean
  }

  export type HallencardUncheckedCreateWithoutTransactionInput = {
    code: string
    pin: string
    value: number
    printed: boolean
  }

  export type HallencardCreateOrConnectWithoutTransactionInput = {
    where: HallencardWhereUniqueInput
    create: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
  }

  export type ReservationCreateWithoutTransactionsInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    createdAt?: Date | string
    deletedAt?: Date | string | null
    court?: CourtCreateNestedOneWithoutReservationsInput
    abo?: AbonnementCreateNestedOneWithoutReservationsInput
    owner?: UserCreateNestedOneWithoutOwnedReservationsInput
    fellows?: UserCreateNestedManyWithoutFellowedReservationsInput
  }

  export type ReservationUncheckedCreateWithoutTransactionsInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
    fellows?: UserUncheckedCreateNestedManyWithoutFellowedReservationsInput
  }

  export type ReservationCreateOrConnectWithoutTransactionsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutTransactionsInput, ReservationUncheckedCreateWithoutTransactionsInput>
  }

  export type AbonnementCreateWithoutTransactionsInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    court?: CourtCreateNestedOneWithoutAbonnementsInput
    owner?: UserCreateNestedOneWithoutAbonnementsInput
    reservations?: ReservationCreateNestedManyWithoutAboInput
  }

  export type AbonnementUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
    ownerId?: string | null
    reservations?: ReservationUncheckedCreateNestedManyWithoutAboInput
  }

  export type AbonnementCreateOrConnectWithoutTransactionsInput = {
    where: AbonnementWhereUniqueInput
    create: XOR<AbonnementCreateWithoutTransactionsInput, AbonnementUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type HallencardUpsertWithoutTransactionInput = {
    update: XOR<HallencardUpdateWithoutTransactionInput, HallencardUncheckedUpdateWithoutTransactionInput>
    create: XOR<HallencardCreateWithoutTransactionInput, HallencardUncheckedCreateWithoutTransactionInput>
    where?: HallencardWhereInput
  }

  export type HallencardUpdateToOneWithWhereWithoutTransactionInput = {
    where?: HallencardWhereInput
    data: XOR<HallencardUpdateWithoutTransactionInput, HallencardUncheckedUpdateWithoutTransactionInput>
  }

  export type HallencardUpdateWithoutTransactionInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type HallencardUncheckedUpdateWithoutTransactionInput = {
    code?: StringFieldUpdateOperationsInput | string
    pin?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    printed?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpsertWithoutTransactionsInput = {
    update: XOR<ReservationUpdateWithoutTransactionsInput, ReservationUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ReservationCreateWithoutTransactionsInput, ReservationUncheckedCreateWithoutTransactionsInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutTransactionsInput, ReservationUncheckedUpdateWithoutTransactionsInput>
  }

  export type ReservationUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    court?: CourtUpdateOneWithoutReservationsNestedInput
    abo?: AbonnementUpdateOneWithoutReservationsNestedInput
    owner?: UserUpdateOneWithoutOwnedReservationsNestedInput
    fellows?: UserUpdateManyWithoutFellowedReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fellows?: UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput
  }

  export type AbonnementUpsertWithoutTransactionsInput = {
    update: XOR<AbonnementUpdateWithoutTransactionsInput, AbonnementUncheckedUpdateWithoutTransactionsInput>
    create: XOR<AbonnementCreateWithoutTransactionsInput, AbonnementUncheckedCreateWithoutTransactionsInput>
    where?: AbonnementWhereInput
  }

  export type AbonnementUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: AbonnementWhereInput
    data: XOR<AbonnementUpdateWithoutTransactionsInput, AbonnementUncheckedUpdateWithoutTransactionsInput>
  }

  export type AbonnementUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    court?: CourtUpdateOneWithoutAbonnementsNestedInput
    owner?: UserUpdateOneWithoutAbonnementsNestedInput
    reservations?: ReservationUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    reservations?: ReservationUncheckedUpdateManyWithoutAboNestedInput
  }

  export type TeamSeasonCreateWithoutSeasonInput = {
    nuGroupId: string
    nuTeamId: string
    leagueName: string
    team: TeamCreateNestedOneWithoutTeamSeasonsInput
    teamLeader?: UserCreateNestedOneWithoutLeadTeamsInput
  }

  export type TeamSeasonUncheckedCreateWithoutSeasonInput = {
    teamId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamSeasonCreateOrConnectWithoutSeasonInput = {
    where: TeamSeasonWhereUniqueInput
    create: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput>
  }

  export type TeamSeasonCreateManySeasonInputEnvelope = {
    data: TeamSeasonCreateManySeasonInput | TeamSeasonCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutSeasonInput = {
    user: UserCreateNestedOneWithoutTeamsInput
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutSeasonInput = {
    userId: string
    teamId: number
  }

  export type TeamMemberCreateOrConnectWithoutSeasonInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput>
  }

  export type TeamMemberCreateManySeasonInputEnvelope = {
    data: TeamMemberCreateManySeasonInput | TeamMemberCreateManySeasonInput[]
    skipDuplicates?: boolean
  }

  export type TeamSeasonUpsertWithWhereUniqueWithoutSeasonInput = {
    where: TeamSeasonWhereUniqueInput
    update: XOR<TeamSeasonUpdateWithoutSeasonInput, TeamSeasonUncheckedUpdateWithoutSeasonInput>
    create: XOR<TeamSeasonCreateWithoutSeasonInput, TeamSeasonUncheckedCreateWithoutSeasonInput>
  }

  export type TeamSeasonUpdateWithWhereUniqueWithoutSeasonInput = {
    where: TeamSeasonWhereUniqueInput
    data: XOR<TeamSeasonUpdateWithoutSeasonInput, TeamSeasonUncheckedUpdateWithoutSeasonInput>
  }

  export type TeamSeasonUpdateManyWithWhereWithoutSeasonInput = {
    where: TeamSeasonScalarWhereInput
    data: XOR<TeamSeasonUpdateManyMutationInput, TeamSeasonUncheckedUpdateManyWithoutSeasonInput>
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutSeasonInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutSeasonInput, TeamMemberUncheckedUpdateWithoutSeasonInput>
    create: XOR<TeamMemberCreateWithoutSeasonInput, TeamMemberUncheckedCreateWithoutSeasonInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutSeasonInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutSeasonInput, TeamMemberUncheckedUpdateWithoutSeasonInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutSeasonInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutSeasonInput>
  }

  export type TeamSeasonCreateWithoutTeamInput = {
    nuGroupId: string
    nuTeamId: string
    leagueName: string
    season: SeasonCreateNestedOneWithoutTeamsInput
    teamLeader?: UserCreateNestedOneWithoutLeadTeamsInput
  }

  export type TeamSeasonUncheckedCreateWithoutTeamInput = {
    seasonId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamSeasonCreateOrConnectWithoutTeamInput = {
    where: TeamSeasonWhereUniqueInput
    create: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput>
  }

  export type TeamSeasonCreateManyTeamInputEnvelope = {
    data: TeamSeasonCreateManyTeamInput | TeamSeasonCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutTeamInput = {
    user: UserCreateNestedOneWithoutTeamsInput
    season: SeasonCreateNestedOneWithoutPlayersInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    userId: string
    seasonId: number
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamSeasonUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamSeasonWhereUniqueInput
    update: XOR<TeamSeasonUpdateWithoutTeamInput, TeamSeasonUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamSeasonCreateWithoutTeamInput, TeamSeasonUncheckedCreateWithoutTeamInput>
  }

  export type TeamSeasonUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamSeasonWhereUniqueInput
    data: XOR<TeamSeasonUpdateWithoutTeamInput, TeamSeasonUncheckedUpdateWithoutTeamInput>
  }

  export type TeamSeasonUpdateManyWithWhereWithoutTeamInput = {
    where: TeamSeasonScalarWhereInput
    data: XOR<TeamSeasonUpdateManyMutationInput, TeamSeasonUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutTeamSeasonsInput = {
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    members?: TeamMemberCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutTeamSeasonsInput = {
    id?: number
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutTeamSeasonsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutTeamSeasonsInput, TeamUncheckedCreateWithoutTeamSeasonsInput>
  }

  export type SeasonCreateWithoutTeamsInput = {
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    players?: TeamMemberCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutTeamsInput = {
    id?: number
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    players?: TeamMemberUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutTeamsInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutTeamsInput, SeasonUncheckedCreateWithoutTeamsInput>
  }

  export type UserCreateWithoutLeadTeamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutLeadTeamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutLeadTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeadTeamsInput, UserUncheckedCreateWithoutLeadTeamsInput>
  }

  export type TeamUpsertWithoutTeamSeasonsInput = {
    update: XOR<TeamUpdateWithoutTeamSeasonsInput, TeamUncheckedUpdateWithoutTeamSeasonsInput>
    create: XOR<TeamCreateWithoutTeamSeasonsInput, TeamUncheckedCreateWithoutTeamSeasonsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutTeamSeasonsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutTeamSeasonsInput, TeamUncheckedUpdateWithoutTeamSeasonsInput>
  }

  export type TeamUpdateWithoutTeamSeasonsInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutTeamSeasonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type SeasonUpsertWithoutTeamsInput = {
    update: XOR<SeasonUpdateWithoutTeamsInput, SeasonUncheckedUpdateWithoutTeamsInput>
    create: XOR<SeasonCreateWithoutTeamsInput, SeasonUncheckedCreateWithoutTeamsInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutTeamsInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutTeamsInput, SeasonUncheckedUpdateWithoutTeamsInput>
  }

  export type SeasonUpdateWithoutTeamsInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    players?: TeamMemberUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutTeamsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    players?: TeamMemberUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type UserUpsertWithoutLeadTeamsInput = {
    update: XOR<UserUpdateWithoutLeadTeamsInput, UserUncheckedUpdateWithoutLeadTeamsInput>
    create: XOR<UserCreateWithoutLeadTeamsInput, UserUncheckedCreateWithoutLeadTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeadTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeadTeamsInput, UserUncheckedUpdateWithoutLeadTeamsInput>
  }

  export type UserUpdateWithoutLeadTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLeadTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
    likedEvents?: EventCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
    likedEvents?: EventUncheckedCreateNestedManyWithoutLikedByUsersInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type TeamCreateWithoutMembersInput = {
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    teamSeasons?: TeamSeasonCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: number
    name: string
    shortName: string
    category: $Enums.TeamCategory
    orderNumber: number
    teamSeasons?: TeamSeasonUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type SeasonCreateWithoutPlayersInput = {
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    teams?: TeamSeasonCreateNestedManyWithoutSeasonInput
  }

  export type SeasonUncheckedCreateWithoutPlayersInput = {
    id?: number
    name: string
    shortName: string
    starting: Date | string
    ending: Date | string
    current?: boolean
    teams?: TeamSeasonUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type SeasonCreateOrConnectWithoutPlayersInput = {
    where: SeasonWhereUniqueInput
    create: XOR<SeasonCreateWithoutPlayersInput, SeasonUncheckedCreateWithoutPlayersInput>
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    teamSeasons?: TeamSeasonUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    category?: EnumTeamCategoryFieldUpdateOperationsInput | $Enums.TeamCategory
    orderNumber?: IntFieldUpdateOperationsInput | number
    teamSeasons?: TeamSeasonUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type SeasonUpsertWithoutPlayersInput = {
    update: XOR<SeasonUpdateWithoutPlayersInput, SeasonUncheckedUpdateWithoutPlayersInput>
    create: XOR<SeasonCreateWithoutPlayersInput, SeasonUncheckedCreateWithoutPlayersInput>
    where?: SeasonWhereInput
  }

  export type SeasonUpdateToOneWithWhereWithoutPlayersInput = {
    where?: SeasonWhereInput
    data: XOR<SeasonUpdateWithoutPlayersInput, SeasonUncheckedUpdateWithoutPlayersInput>
  }

  export type SeasonUpdateWithoutPlayersInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    teams?: TeamSeasonUpdateManyWithoutSeasonNestedInput
  }

  export type SeasonUncheckedUpdateWithoutPlayersInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    starting?: DateTimeFieldUpdateOperationsInput | Date | string
    ending?: DateTimeFieldUpdateOperationsInput | Date | string
    current?: BoolFieldUpdateOperationsInput | boolean
    teams?: TeamSeasonUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type CourtCreateWithoutControlInterfacesInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    area: AreaCreateNestedOneWithoutCourtsInput
    abonnements?: AbonnementCreateNestedManyWithoutCourtInput
    reservations?: ReservationCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtUncheckedCreateWithoutControlInterfacesInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
    areaId: number
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutCourtInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutCourtInput
    reservationRules?: ReservationRuleUncheckedCreateNestedManyWithoutAffectedCourtsInput
  }

  export type CourtCreateOrConnectWithoutControlInterfacesInput = {
    where: CourtWhereUniqueInput
    create: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput>
  }

  export type CourtUpsertWithWhereUniqueWithoutControlInterfacesInput = {
    where: CourtWhereUniqueInput
    update: XOR<CourtUpdateWithoutControlInterfacesInput, CourtUncheckedUpdateWithoutControlInterfacesInput>
    create: XOR<CourtCreateWithoutControlInterfacesInput, CourtUncheckedCreateWithoutControlInterfacesInput>
  }

  export type CourtUpdateWithWhereUniqueWithoutControlInterfacesInput = {
    where: CourtWhereUniqueInput
    data: XOR<CourtUpdateWithoutControlInterfacesInput, CourtUncheckedUpdateWithoutControlInterfacesInput>
  }

  export type CourtUpdateManyWithWhereWithoutControlInterfacesInput = {
    where: CourtScalarWhereInput
    data: XOR<CourtUpdateManyMutationInput, CourtUncheckedUpdateManyWithoutControlInterfacesInput>
  }

  export type OrganisationMemberCreateWithoutOrganisationInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    parentMember?: OrganisationMemberCreateNestedOneWithoutChildMembersInput
    childMembers?: OrganisationMemberCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberUncheckedCreateWithoutOrganisationInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    parentMemberId?: string | null
    childMembers?: OrganisationMemberUncheckedCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberCreateOrConnectWithoutOrganisationInput = {
    where: OrganisationMemberWhereUniqueInput
    create: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput>
  }

  export type OrganisationMemberCreateManyOrganisationInputEnvelope = {
    data: OrganisationMemberCreateManyOrganisationInput | OrganisationMemberCreateManyOrganisationInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationMemberUpsertWithWhereUniqueWithoutOrganisationInput = {
    where: OrganisationMemberWhereUniqueInput
    update: XOR<OrganisationMemberUpdateWithoutOrganisationInput, OrganisationMemberUncheckedUpdateWithoutOrganisationInput>
    create: XOR<OrganisationMemberCreateWithoutOrganisationInput, OrganisationMemberUncheckedCreateWithoutOrganisationInput>
  }

  export type OrganisationMemberUpdateWithWhereUniqueWithoutOrganisationInput = {
    where: OrganisationMemberWhereUniqueInput
    data: XOR<OrganisationMemberUpdateWithoutOrganisationInput, OrganisationMemberUncheckedUpdateWithoutOrganisationInput>
  }

  export type OrganisationMemberUpdateManyWithWhereWithoutOrganisationInput = {
    where: OrganisationMemberScalarWhereInput
    data: XOR<OrganisationMemberUpdateManyMutationInput, OrganisationMemberUncheckedUpdateManyWithoutOrganisationInput>
  }

  export type OrganisationMemberScalarWhereInput = {
    AND?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
    OR?: OrganisationMemberScalarWhereInput[]
    NOT?: OrganisationMemberScalarWhereInput | OrganisationMemberScalarWhereInput[]
    id?: StringFilter<"OrganisationMember"> | string
    fullName?: StringFilter<"OrganisationMember"> | string
    function?: StringNullableFilter<"OrganisationMember"> | string | null
    image?: StringNullableFilter<"OrganisationMember"> | string | null
    email?: StringNullableFilter<"OrganisationMember"> | string | null
    phone?: StringNullableFilter<"OrganisationMember"> | string | null
    orderID?: IntNullableFilter<"OrganisationMember"> | number | null
    organisationId?: StringFilter<"OrganisationMember"> | string
    parentMemberId?: StringNullableFilter<"OrganisationMember"> | string | null
  }

  export type OrganisationCreateWithoutMembersInput = {
    id?: string
    slug: string
    title: string
  }

  export type OrganisationUncheckedCreateWithoutMembersInput = {
    id?: string
    slug: string
    title: string
  }

  export type OrganisationCreateOrConnectWithoutMembersInput = {
    where: OrganisationWhereUniqueInput
    create: XOR<OrganisationCreateWithoutMembersInput, OrganisationUncheckedCreateWithoutMembersInput>
  }

  export type OrganisationMemberCreateWithoutChildMembersInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisation: OrganisationCreateNestedOneWithoutMembersInput
    parentMember?: OrganisationMemberCreateNestedOneWithoutChildMembersInput
  }

  export type OrganisationMemberUncheckedCreateWithoutChildMembersInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisationId: string
    parentMemberId?: string | null
  }

  export type OrganisationMemberCreateOrConnectWithoutChildMembersInput = {
    where: OrganisationMemberWhereUniqueInput
    create: XOR<OrganisationMemberCreateWithoutChildMembersInput, OrganisationMemberUncheckedCreateWithoutChildMembersInput>
  }

  export type OrganisationMemberCreateWithoutParentMemberInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisation: OrganisationCreateNestedOneWithoutMembersInput
    childMembers?: OrganisationMemberCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberUncheckedCreateWithoutParentMemberInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisationId: string
    childMembers?: OrganisationMemberUncheckedCreateNestedManyWithoutParentMemberInput
  }

  export type OrganisationMemberCreateOrConnectWithoutParentMemberInput = {
    where: OrganisationMemberWhereUniqueInput
    create: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput>
  }

  export type OrganisationMemberCreateManyParentMemberInputEnvelope = {
    data: OrganisationMemberCreateManyParentMemberInput | OrganisationMemberCreateManyParentMemberInput[]
    skipDuplicates?: boolean
  }

  export type OrganisationUpsertWithoutMembersInput = {
    update: XOR<OrganisationUpdateWithoutMembersInput, OrganisationUncheckedUpdateWithoutMembersInput>
    create: XOR<OrganisationCreateWithoutMembersInput, OrganisationUncheckedCreateWithoutMembersInput>
    where?: OrganisationWhereInput
  }

  export type OrganisationUpdateToOneWithWhereWithoutMembersInput = {
    where?: OrganisationWhereInput
    data: XOR<OrganisationUpdateWithoutMembersInput, OrganisationUncheckedUpdateWithoutMembersInput>
  }

  export type OrganisationUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganisationUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type OrganisationMemberUpsertWithoutChildMembersInput = {
    update: XOR<OrganisationMemberUpdateWithoutChildMembersInput, OrganisationMemberUncheckedUpdateWithoutChildMembersInput>
    create: XOR<OrganisationMemberCreateWithoutChildMembersInput, OrganisationMemberUncheckedCreateWithoutChildMembersInput>
    where?: OrganisationMemberWhereInput
  }

  export type OrganisationMemberUpdateToOneWithWhereWithoutChildMembersInput = {
    where?: OrganisationMemberWhereInput
    data: XOR<OrganisationMemberUpdateWithoutChildMembersInput, OrganisationMemberUncheckedUpdateWithoutChildMembersInput>
  }

  export type OrganisationMemberUpdateWithoutChildMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisation?: OrganisationUpdateOneRequiredWithoutMembersNestedInput
    parentMember?: OrganisationMemberUpdateOneWithoutChildMembersNestedInput
  }

  export type OrganisationMemberUncheckedUpdateWithoutChildMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: StringFieldUpdateOperationsInput | string
    parentMemberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganisationMemberUpsertWithWhereUniqueWithoutParentMemberInput = {
    where: OrganisationMemberWhereUniqueInput
    update: XOR<OrganisationMemberUpdateWithoutParentMemberInput, OrganisationMemberUncheckedUpdateWithoutParentMemberInput>
    create: XOR<OrganisationMemberCreateWithoutParentMemberInput, OrganisationMemberUncheckedCreateWithoutParentMemberInput>
  }

  export type OrganisationMemberUpdateWithWhereUniqueWithoutParentMemberInput = {
    where: OrganisationMemberWhereUniqueInput
    data: XOR<OrganisationMemberUpdateWithoutParentMemberInput, OrganisationMemberUncheckedUpdateWithoutParentMemberInput>
  }

  export type OrganisationMemberUpdateManyWithWhereWithoutParentMemberInput = {
    where: OrganisationMemberScalarWhereInput
    data: XOR<OrganisationMemberUpdateManyMutationInput, OrganisationMemberUncheckedUpdateManyWithoutParentMemberInput>
  }

  export type EventCreateWithoutCategoryInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    likedByUsers?: UserCreateNestedManyWithoutLikedEventsInput
  }

  export type EventUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
    likedByUsers?: UserUncheckedCreateNestedManyWithoutLikedEventsInput
  }

  export type EventCreateOrConnectWithoutCategoryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventCreateManyCategoryInputEnvelope = {
    data: EventCreateManyCategoryInput | EventCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
  }

  export type EventUpdateManyWithWhereWithoutCategoryInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EventCategoryCreateWithoutEventsInput = {
    id?: string
    slug: string
    title: string
  }

  export type EventCategoryUncheckedCreateWithoutEventsInput = {
    id?: string
    slug: string
    title: string
  }

  export type EventCategoryCreateOrConnectWithoutEventsInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
  }

  export type UserCreateWithoutLikedEventsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationCreateNestedManyWithoutFellowsInput
    transactions?: TransactionCreateNestedManyWithoutUserInput
    teams?: TeamMemberCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleCreateNestedManyWithoutUsersInput
  }

  export type UserUncheckedCreateWithoutLikedEventsInput = {
    id?: string
    name?: string | null
    email?: string | null
    image?: string | null
    auth0Id: string
    address?: string | null
    cityCode?: string | null
    cityName?: string | null
    countryCode?: string | null
    needsSetup?: boolean
    publicName?: boolean
    phoneNumber?: string | null
    abonnements?: AbonnementUncheckedCreateNestedManyWithoutOwnerInput
    ownedReservations?: ReservationUncheckedCreateNestedManyWithoutOwnerInput
    fellowedReservations?: ReservationUncheckedCreateNestedManyWithoutFellowsInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    leadTeams?: TeamSeasonUncheckedCreateNestedManyWithoutTeamLeaderInput
    roles?: UserRoleUncheckedCreateNestedManyWithoutUsersInput
  }

  export type UserCreateOrConnectWithoutLikedEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput>
  }

  export type EventCategoryUpsertWithoutEventsInput = {
    update: XOR<EventCategoryUpdateWithoutEventsInput, EventCategoryUncheckedUpdateWithoutEventsInput>
    create: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    where?: EventCategoryWhereInput
  }

  export type EventCategoryUpdateToOneWithWhereWithoutEventsInput = {
    where?: EventCategoryWhereInput
    data: XOR<EventCategoryUpdateWithoutEventsInput, EventCategoryUncheckedUpdateWithoutEventsInput>
  }

  export type EventCategoryUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type EventCategoryUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpsertWithWhereUniqueWithoutLikedEventsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutLikedEventsInput, UserUncheckedUpdateWithoutLikedEventsInput>
    create: XOR<UserCreateWithoutLikedEventsInput, UserUncheckedCreateWithoutLikedEventsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutLikedEventsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutLikedEventsInput, UserUncheckedUpdateWithoutLikedEventsInput>
  }

  export type UserUpdateManyWithWhereWithoutLikedEventsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutLikedEventsInput>
  }

  export type AbonnementCreateManyOwnerInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    courtId?: string | null
  }

  export type ReservationCreateManyOwnerInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionCreateManyUserInput = {
    id?: string
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
  }

  export type TeamMemberCreateManyUserInput = {
    teamId: number
    seasonId: number
  }

  export type TeamSeasonCreateManyTeamLeaderInput = {
    teamId: number
    seasonId: number
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type AbonnementUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    court?: CourtUpdateOneWithoutAbonnementsNestedInput
    transactions?: TransactionUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    court?: CourtUpdateOneWithoutReservationsNestedInput
    abo?: AbonnementUpdateOneWithoutReservationsNestedInput
    fellows?: UserUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fellows?: UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationUpdateWithoutFellowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    court?: CourtUpdateOneWithoutReservationsNestedInput
    abo?: AbonnementUpdateOneWithoutReservationsNestedInput
    owner?: UserUpdateOneWithoutOwnedReservationsNestedInput
    transactions?: TransactionUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutFellowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutFellowsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    hallencard?: HallencardUpdateOneWithoutTransactionNestedInput
    reservation?: ReservationUpdateOneWithoutTransactionsNestedInput
    abonnement?: AbonnementUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    hallencard?: HallencardUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TeamMemberUpdateWithoutUserInput = {
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    season?: SeasonUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamSeasonUpdateWithoutTeamLeaderInput = {
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutTeamSeasonsNestedInput
    season?: SeasonUpdateOneRequiredWithoutTeamsNestedInput
  }

  export type TeamSeasonUncheckedUpdateWithoutTeamLeaderInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamSeasonUncheckedUpdateManyWithoutTeamLeaderInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    seasonId?: IntFieldUpdateOperationsInput | number
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUpdateManyWithoutUserRoleNestedInput
    prices?: PriceUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUncheckedUpdateManyWithoutUserRoleNestedInput
    prices?: PriceUncheckedUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type EventUpdateWithoutLikedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutLikedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type EventUncheckedUpdateManyWithoutLikedByUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: StringFieldUpdateOperationsInput | string
  }

  export type CourtCreateManyAreaInput = {
    id?: string
    name: string
    shortName?: string | null
    description?: string | null
    order?: number | null
    active?: boolean
    activeFrom?: Date | string | null
    activeTo?: Date | string | null
  }

  export type CourtUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abonnements?: AbonnementUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput
    controlInterfaces?: ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateManyWithoutAreaInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationRuleUpdateWithoutAffectedAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateWithoutAffectedAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUncheckedUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUncheckedUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateManyWithoutAffectedAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
  }

  export type PriceUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    roles?: UserRoleUpdateManyWithoutPricesNestedInput
  }

  export type PriceUncheckedUpdateWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    roles?: UserRoleUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PriceUncheckedUpdateManyWithoutAreasInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
  }

  export type AbonnementCreateManyCourtInput = {
    id?: string
    name: string
    weekday: number
    start: Date | string
    duration: number
    status: $Enums.AbonnementStatus
    ownerId?: string | null
  }

  export type ReservationCreateManyCourtInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    abonnementId?: string | null
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type AbonnementUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    owner?: UserUpdateOneWithoutAbonnementsNestedInput
    transactions?: TransactionUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: TransactionUncheckedUpdateManyWithoutAbonnementNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutAboNestedInput
  }

  export type AbonnementUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    weekday?: IntFieldUpdateOperationsInput | number
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: FloatFieldUpdateOperationsInput | number
    status?: EnumAbonnementStatusFieldUpdateOperationsInput | $Enums.AbonnementStatus
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReservationUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    abo?: AbonnementUpdateOneWithoutReservationsNestedInput
    owner?: UserUpdateOneWithoutOwnedReservationsNestedInput
    fellows?: UserUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fellows?: UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutCourtInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReservationRuleUpdateWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUpdateManyWithoutReservationRulesNestedInput
    affectedAreas?: AreaUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    validFor?: UserRoleUncheckedUpdateManyWithoutReservationRulesNestedInput
    affectedAreas?: AreaUncheckedUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
  }

  export type ControlInterfaceUpdateWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ControlInterfaceUncheckedUpdateWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preBooking?: IntFieldUpdateOperationsInput | number
    postBooking?: IntFieldUpdateOperationsInput | number
    connectByAnd?: BoolFieldUpdateOperationsInput | boolean
    connectByOr?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TransactionCreateManyReservationInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    abonnementId?: string | null
    createdAt?: Date | string
    deleted?: boolean
  }

  export type UserUpdateWithoutFellowedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutFellowedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutFellowedReservationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TransactionUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutTransactionsNestedInput
    hallencard?: HallencardUpdateOneWithoutTransactionNestedInput
    abonnement?: AbonnementUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    hallencard?: HallencardUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutReservationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    abonnementId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserRoleUpdateWithoutReservationRulesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUpdateManyWithoutUserRoleNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    prices?: PriceUpdateManyWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutReservationRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUncheckedUpdateManyWithoutUserRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    prices?: PriceUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutReservationRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type AreaUpdateWithoutReservationRulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUpdateManyWithoutAreaNestedInput
    prices?: PriceUpdateManyWithoutAreasNestedInput
  }

  export type AreaUncheckedUpdateWithoutReservationRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUncheckedUpdateManyWithoutAreaNestedInput
    prices?: PriceUncheckedUpdateManyWithoutAreasNestedInput
  }

  export type AreaUncheckedUpdateManyWithoutReservationRulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CourtUpdateWithoutReservationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: AreaUpdateOneRequiredWithoutCourtsNestedInput
    abonnements?: AbonnementUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUpdateManyWithoutCourtNestedInput
    controlInterfaces?: ControlInterfaceUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutReservationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
    abonnements?: AbonnementUncheckedUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCourtNestedInput
    controlInterfaces?: ControlInterfaceUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateManyWithoutReservationRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type TransactionCreateManyAbonnementInput = {
    id?: string
    userId?: string | null
    value: number
    currency: string
    reason: $Enums.TransactionReason
    paymentInformation?: string | null
    reservationId?: string | null
    createdAt?: Date | string
    deleted?: boolean
  }

  export type ReservationCreateManyAboInput = {
    id?: string
    title: string
    start: Date | string
    end: Date | string
    courtId?: string | null
    status: $Enums.ReservationStatus
    type?: $Enums.ReservationType | null
    paypalTransactionId?: string | null
    price?: number | null
    taxRate?: number | null
    light: boolean
    radiator: boolean
    ownerId?: string | null
    createdAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type TransactionUpdateWithoutAbonnementInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutTransactionsNestedInput
    hallencard?: HallencardUpdateOneWithoutTransactionNestedInput
    reservation?: ReservationUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAbonnementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    hallencard?: HallencardUncheckedUpdateOneWithoutTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutAbonnementInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    reason?: EnumTransactionReasonFieldUpdateOperationsInput | $Enums.TransactionReason
    paymentInformation?: NullableStringFieldUpdateOperationsInput | string | null
    reservationId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ReservationUpdateWithoutAboInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    court?: CourtUpdateOneWithoutReservationsNestedInput
    owner?: UserUpdateOneWithoutOwnedReservationsNestedInput
    fellows?: UserUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateWithoutAboInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fellows?: UserUncheckedUpdateManyWithoutFellowedReservationsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutAboInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: DateTimeFieldUpdateOperationsInput | Date | string
    courtId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumReservationStatusFieldUpdateOperationsInput | $Enums.ReservationStatus
    type?: NullableEnumReservationTypeFieldUpdateOperationsInput | $Enums.ReservationType | null
    paypalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    light?: BoolFieldUpdateOperationsInput | boolean
    radiator?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PermissionCreateManyUserRoleInput = {
    router: string
    action: string
    allowed?: $Enums.PermissionState
  }

  export type PermissionUpdateWithoutUserRoleInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type PermissionUncheckedUpdateWithoutUserRoleInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type PermissionUncheckedUpdateManyWithoutUserRoleInput = {
    router?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    allowed?: EnumPermissionStateFieldUpdateOperationsInput | $Enums.PermissionState
  }

  export type UserUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    likedEvents?: EventUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    likedEvents?: EventUncheckedUpdateManyWithoutLikedByUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PriceUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    areas?: AreaUpdateManyWithoutPricesNestedInput
  }

  export type PriceUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
    areas?: AreaUncheckedUpdateManyWithoutPricesNestedInput
  }

  export type PriceUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    validFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    validTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    mon?: BoolFieldUpdateOperationsInput | boolean
    tue?: BoolFieldUpdateOperationsInput | boolean
    wed?: BoolFieldUpdateOperationsInput | boolean
    thu?: BoolFieldUpdateOperationsInput | boolean
    fri?: BoolFieldUpdateOperationsInput | boolean
    sat?: BoolFieldUpdateOperationsInput | boolean
    sun?: BoolFieldUpdateOperationsInput | boolean
    from?: IntFieldUpdateOperationsInput | number
    to?: IntFieldUpdateOperationsInput | number
    value?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    taxes?: FloatFieldUpdateOperationsInput | number
  }

  export type ReservationRuleUpdateWithoutValidForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    affectedAreas?: AreaUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateWithoutValidForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
    affectedAreas?: AreaUncheckedUpdateManyWithoutReservationRulesNestedInput
    affectedCourts?: CourtUncheckedUpdateManyWithoutReservationRulesNestedInput
  }

  export type ReservationRuleUncheckedUpdateManyWithoutValidForInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    errorDescription?: NullableStringFieldUpdateOperationsInput | string | null
    checkOn?: EnumReservationRuleCheckOnFieldUpdateOperationsInput | $Enums.ReservationRuleCheckOn
    ruleCheckPluginName?: NullableStringFieldUpdateOperationsInput | string | null
    value?: StringFieldUpdateOperationsInput | string
  }

  export type UserRoleUpdateWithoutPricesInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUpdateManyWithoutUserRoleNestedInput
    users?: UserUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    permissions?: PermissionUncheckedUpdateManyWithoutUserRoleNestedInput
    users?: UserUncheckedUpdateManyWithoutRolesNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutValidForNestedInput
  }

  export type UserRoleUncheckedUpdateManyWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
  }

  export type AreaUpdateWithoutPricesInput = {
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUpdateManyWithoutAreaNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedAreasNestedInput
  }

  export type AreaUncheckedUpdateWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    courts?: CourtUncheckedUpdateManyWithoutAreaNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedAreasNestedInput
  }

  export type AreaUncheckedUpdateManyWithoutPricesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    shortName?: StringFieldUpdateOperationsInput | string
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bookableFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TeamSeasonCreateManySeasonInput = {
    teamId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamMemberCreateManySeasonInput = {
    userId: string
    teamId: number
  }

  export type TeamSeasonUpdateWithoutSeasonInput = {
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
    team?: TeamUpdateOneRequiredWithoutTeamSeasonsNestedInput
    teamLeader?: UserUpdateOneWithoutLeadTeamsNestedInput
  }

  export type TeamSeasonUncheckedUpdateWithoutSeasonInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamSeasonUncheckedUpdateManyWithoutSeasonInput = {
    teamId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberUpdateWithoutSeasonInput = {
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutSeasonInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUncheckedUpdateManyWithoutSeasonInput = {
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamSeasonCreateManyTeamInput = {
    seasonId: number
    teamLeaderId?: string | null
    nuGroupId: string
    nuTeamId: string
    leagueName: string
  }

  export type TeamMemberCreateManyTeamInput = {
    userId: string
    seasonId: number
  }

  export type TeamSeasonUpdateWithoutTeamInput = {
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
    season?: SeasonUpdateOneRequiredWithoutTeamsNestedInput
    teamLeader?: UserUpdateOneWithoutLeadTeamsNestedInput
  }

  export type TeamSeasonUncheckedUpdateWithoutTeamInput = {
    seasonId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamSeasonUncheckedUpdateManyWithoutTeamInput = {
    seasonId?: IntFieldUpdateOperationsInput | number
    teamLeaderId?: NullableStringFieldUpdateOperationsInput | string | null
    nuGroupId?: StringFieldUpdateOperationsInput | string
    nuTeamId?: StringFieldUpdateOperationsInput | string
    leagueName?: StringFieldUpdateOperationsInput | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    user?: UserUpdateOneRequiredWithoutTeamsNestedInput
    season?: SeasonUpdateOneRequiredWithoutPlayersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    seasonId?: IntFieldUpdateOperationsInput | number
  }

  export type CourtUpdateWithoutControlInterfacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    area?: AreaUpdateOneRequiredWithoutCourtsNestedInput
    abonnements?: AbonnementUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateWithoutControlInterfacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
    abonnements?: AbonnementUncheckedUpdateManyWithoutCourtNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutCourtNestedInput
    reservationRules?: ReservationRuleUncheckedUpdateManyWithoutAffectedCourtsNestedInput
  }

  export type CourtUncheckedUpdateManyWithoutControlInterfacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    shortName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: NullableIntFieldUpdateOperationsInput | number | null
    active?: BoolFieldUpdateOperationsInput | boolean
    activeFrom?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    activeTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    areaId?: IntFieldUpdateOperationsInput | number
  }

  export type OrganisationMemberCreateManyOrganisationInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    parentMemberId?: string | null
  }

  export type OrganisationMemberUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    parentMember?: OrganisationMemberUpdateOneWithoutChildMembersNestedInput
    childMembers?: OrganisationMemberUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberUncheckedUpdateWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    parentMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    childMembers?: OrganisationMemberUncheckedUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberUncheckedUpdateManyWithoutOrganisationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    parentMemberId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrganisationMemberCreateManyParentMemberInput = {
    id?: string
    fullName: string
    function?: string | null
    image?: string | null
    email?: string | null
    phone?: string | null
    orderID?: number | null
    organisationId: string
  }

  export type OrganisationMemberUpdateWithoutParentMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisation?: OrganisationUpdateOneRequiredWithoutMembersNestedInput
    childMembers?: OrganisationMemberUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberUncheckedUpdateWithoutParentMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: StringFieldUpdateOperationsInput | string
    childMembers?: OrganisationMemberUncheckedUpdateManyWithoutParentMemberNestedInput
  }

  export type OrganisationMemberUncheckedUpdateManyWithoutParentMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    function?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    orderID?: NullableIntFieldUpdateOperationsInput | number | null
    organisationId?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateManyCategoryInput = {
    id?: string
    title: string
    description?: string | null
    image?: string | null
    start: Date | string
    end?: Date | string | null
    canceled?: boolean
    revised?: boolean
    link?: string | null
    location?: string | null
  }

  export type EventUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    likedByUsers?: UserUpdateManyWithoutLikedEventsNestedInput
  }

  export type EventUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    likedByUsers?: UserUncheckedUpdateManyWithoutLikedEventsNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    start?: DateTimeFieldUpdateOperationsInput | Date | string
    end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceled?: BoolFieldUpdateOperationsInput | boolean
    revised?: BoolFieldUpdateOperationsInput | boolean
    link?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpdateWithoutLikedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateWithoutLikedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    abonnements?: AbonnementUncheckedUpdateManyWithoutOwnerNestedInput
    ownedReservations?: ReservationUncheckedUpdateManyWithoutOwnerNestedInput
    fellowedReservations?: ReservationUncheckedUpdateManyWithoutFellowsNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    leadTeams?: TeamSeasonUncheckedUpdateManyWithoutTeamLeaderNestedInput
    roles?: UserRoleUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type UserUncheckedUpdateManyWithoutLikedEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    auth0Id?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    cityCode?: NullableStringFieldUpdateOperationsInput | string | null
    cityName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCode?: NullableStringFieldUpdateOperationsInput | string | null
    needsSetup?: BoolFieldUpdateOperationsInput | boolean
    publicName?: BoolFieldUpdateOperationsInput | boolean
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaCountOutputTypeDefaultArgs instead
     */
    export type AreaCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourtCountOutputTypeDefaultArgs instead
     */
    export type CourtCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourtCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationCountOutputTypeDefaultArgs instead
     */
    export type ReservationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationRuleCountOutputTypeDefaultArgs instead
     */
    export type ReservationRuleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationRuleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AbonnementCountOutputTypeDefaultArgs instead
     */
    export type AbonnementCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AbonnementCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleCountOutputTypeDefaultArgs instead
     */
    export type UserRoleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceCountOutputTypeDefaultArgs instead
     */
    export type PriceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonCountOutputTypeDefaultArgs instead
     */
    export type SeasonCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ControlInterfaceCountOutputTypeDefaultArgs instead
     */
    export type ControlInterfaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ControlInterfaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationCountOutputTypeDefaultArgs instead
     */
    export type OrganisationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationMemberCountOutputTypeDefaultArgs instead
     */
    export type OrganisationMemberCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationMemberCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryCountOutputTypeDefaultArgs instead
     */
    export type EventCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VerificationTokenDefaultArgs instead
     */
    export type VerificationTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VerificationTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AreaDefaultArgs instead
     */
    export type AreaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AreaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourtDefaultArgs instead
     */
    export type CourtArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourtDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationDefaultArgs instead
     */
    export type ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationRuleDefaultArgs instead
     */
    export type ReservationRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AbonnementDefaultArgs instead
     */
    export type AbonnementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AbonnementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserRoleDefaultArgs instead
     */
    export type UserRoleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserRoleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PermissionDefaultArgs instead
     */
    export type PermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PermissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HallencardDefaultArgs instead
     */
    export type HallencardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HallencardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceDefaultArgs instead
     */
    export type PriceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionDefaultArgs instead
     */
    export type TransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SeasonDefaultArgs instead
     */
    export type SeasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SeasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamSeasonDefaultArgs instead
     */
    export type TeamSeasonArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamSeasonDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BenefitDefaultArgs instead
     */
    export type BenefitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BenefitDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ControlInterfaceDefaultArgs instead
     */
    export type ControlInterfaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ControlInterfaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationDefaultArgs instead
     */
    export type OrganisationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrganisationMemberDefaultArgs instead
     */
    export type OrganisationMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrganisationMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryDefaultArgs instead
     */
    export type EventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}